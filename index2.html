<!DOCTYPE html>
<!--
################################################################
# UPDATED: 2025-11-10 - Veo3 Video Generation Integration
# - Auto-parse Project URL (labs.google/fx/.../project/xxx/scenes/xxx)
# - Extract projectId & sceneId automatically from URL
# - Manual setup workflow (no auto-create)
################################################################
-->
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Whisk AI - Image Generator</title>
    <link rel="icon" href="data:,">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #1a73e8;
            --primary-hover: #1557b0;
            --success-color: #34a853;
            --success-hover: #2d8e47;
            --warning-color: #f9ab00;
            --danger-color: #ea4335;
            --bg-main: #0f1419;
            --bg-sidebar: #1a1f2e;
            --bg-card: #252d3d;
            --bg-hover: #2d3548;
            --text-primary: #e8eaed;
            --text-secondary: #9aa0a6;
            --border-color: #3c4454;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Inter', sans-serif;
            background: var(--bg-main);
            color: var(--text-primary);
            line-height: 1.6;
            overflow: hidden;
        }

        /* App Layout - Full Screen */
        .app-container {
            display: flex;
            height: 100vh;
            width: 100vw;
        }

        /* Sidebar - Fixed Width */
        .sidebar {
            width: 380px;
            background: var(--bg-sidebar);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .sidebar.hidden {
            display: none;
        }

        /* Video tab sidebar */
        .video-sidebar {
            width: 380px;
            background: var(--bg-card);
            border-radius: 8px;
            padding: 16px;
            overflow-y: auto;
            flex-shrink: 0;
            height: 100%;
        }

        .sidebar::-webkit-scrollbar { width: 8px; }
        .video-sidebar::-webkit-scrollbar { width: 8px; }
        .video-sidebar::-webkit-scrollbar-track { background: transparent; }
        .video-sidebar::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }
        .video-sidebar::-webkit-scrollbar-thumb:hover { background: #4a5568; }
        .sidebar::-webkit-scrollbar-track { background: transparent; }
        .sidebar::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }
        .sidebar::-webkit-scrollbar-thumb:hover { background: #4a5568; }

        /* Main Content - Takes Remaining Space */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Header */
        .header {
            background: var(--bg-sidebar);
            padding: 16px 24px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 16px;
        }

        .header-title {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 20px;
            font-weight: 700;
            color: var(--primary-color);
        }

        .header-actions {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        .status-badge {
            padding: 6px 14px;
            border-radius: 16px;
            font-size: 13px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .status-badge.ready {
            background: rgba(52, 168, 83, 0.15);
            color: var(--success-color);
            border: 1px solid var(--success-color);
        }

        .status-badge.waiting {
            background: rgba(249, 171, 0, 0.15);
            color: var(--warning-color);
            border: 1px solid var(--warning-color);
        }

        .status-badge::before {
            content: '';
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        /* Buttons */
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .btn-primary {
            background: var(--primary-color);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: var(--primary-hover);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(26,115,232,0.4);
        }

        .btn-secondary {
            background: var(--bg-card);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover:not(:disabled) {
            background: var(--bg-hover);
            border-color: var(--primary-color);
        }

        .btn-success {
            background: var(--success-color);
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            background: var(--success-hover);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(52, 168, 83, 0.4);
        }

        /* Sidebar Content */
        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .sidebar-header h2 {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .sidebar-subtitle {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .sidebar-body {
            padding: 20px;
        }

        /* Form Controls */
        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        textarea, select, input[type="number"] {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 14px;
            font-family: inherit;
            background: var(--bg-card);
            color: var(--text-primary);
            transition: all 0.2s;
        }

        textarea {
            resize: vertical;
            min-height: 120px;
            font-family: 'Consolas', 'Monaco', monospace;
        }

        textarea:focus, select:focus, input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(26,115,232,0.15);
        }

        .help-text {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 6px;
        }

        /* Reference Section */
        .reference-section {
            background: var(--bg-card);
            border-radius: 8px;
            padding: 14px;
            margin-bottom: 20px;
            border: 2px dashed var(--border-color);
            transition: all 0.2s;
        }

        .reference-section.has-image {
            border-color: var(--primary-color);
            background: rgba(26, 115, 232, 0.1);
        }

        .reference-preview {
            margin-top: 12px;
            text-align: center;
        }

        .reference-preview img {
            max-width: 100%;
            max-height: 180px;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .reference-actions {
            margin-top: 12px;
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .reference-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 8px;
        }

        .reference-item {
            position: relative;
            border-radius: 6px;
            overflow: hidden;
            background: var(--bg-main);
            border: 2px solid var(--border-color);
        }

        .reference-item img {
            width: 100%;
            height: 100px;
            object-fit: cover;
            display: block;
        }

        .reference-item-remove {
            position: absolute;
            top: 4px;
            right: 4px;
            background: rgba(255, 0, 0, 0.8);
            color: white;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .reference-item-remove:hover {
            background: rgba(255, 0, 0, 1);
            transform: scale(1.1);
        }

        /* Settings Grid */
        .settings-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 20px;
        }

        /* Folder Picker */
        .folder-picker {
            background: var(--bg-card);
            border-radius: 8px;
            padding: 14px;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
        }

        .folder-path {
            padding: 10px;
            background: var(--bg-main);
            border-radius: 6px;
            font-size: 12px;
            color: var(--text-secondary);
            margin: 10px 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            border: 1px solid var(--border-color);
        }

        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 4px;
            background: var(--bg-card);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 16px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--success-color));
            transition: width 0.3s;
        }

        .image-counter {
            text-align: center;
            margin-top: 12px;
            font-size: 13px;
            color: var(--text-secondary);
        }

        .image-counter strong {
            color: var(--primary-color);
            font-size: 20px;
        }

        /* Gallery */
        .gallery-container {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
        }

        .gallery-container::-webkit-scrollbar { width: 10px; }
        .gallery-container::-webkit-scrollbar-track { background: var(--bg-main); }
        .gallery-container::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 5px;
        }
        .gallery-container::-webkit-scrollbar-thumb:hover { background: #4a5568; }

        .gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 12px;
        }

        @media (min-width: 1400px) {
            .gallery {
                grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            }
        }

        @media (min-width: 1800px) {
            .gallery {
                grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            }
        }

        .image-card {
            background: var(--bg-card);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            transition: all 0.3s;
            border: 1px solid var(--border-color);
            position: relative;
            cursor: move;
        }

        .image-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 24px rgba(0,0,0,0.3);
            border-color: var(--primary-color);
        }

        .image-card img {
            width: 100%;
            height: 120px;
            object-fit: cover;
            cursor: pointer;
            transition: transform 0.3s;
        }

        .image-card:hover img {
            transform: scale(1.05);
        }

        .image-info {
            padding: 8px;
        }

        .image-prompt {
            font-size: 11px;
            color: var(--text-primary);
            margin-bottom: 4px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            line-height: 1.3;
        }

        .image-seed {
            font-size: 9px;
            color: var(--text-secondary);
            margin-bottom: 6px;
        }

        .image-actions {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }

        .btn-icon {
            padding: 4px 8px;
            font-size: 9px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-main);
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .btn-icon:hover {
            background: var(--bg-hover);
            border-color: var(--primary-color);
            color: var(--primary-color);
            transform: translateY(-1px);
        }

        /* Loading Card */
        .loading-card {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 60px 20px;
            text-align: center;
            border: 1px solid var(--border-color);
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid var(--border-color);
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 13px;
            color: var(--text-secondary);
        }

        /* Empty State */
        .empty-state {
            grid-column: 1 / -1;
            text-align: center;
            padding: 100px 20px;
            color: var(--text-secondary);
        }

        .empty-state svg {
            width: 80px;
            height: 80px;
            margin: 0 auto 24px;
            opacity: 0.3;
            stroke: currentColor;
        }

        .empty-state h3 {
            font-size: 18px;
            margin-bottom: 12px;
            color: var(--text-primary);
        }

        .empty-state p {
            font-size: 14px;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.9);
            z-index: 1000;
            padding: 40px;
            align-items: center;
            justify-content: center;
        }

        .modal.active { display: flex; }

        .modal-content {
            max-width: 90%;
            max-height: 90vh;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .modal-image {
            max-width: 100%;
            max-height: 80vh;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        }

        .modal-info {
            position: absolute;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 16px 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 400px;
            min-width: 300px;
        }

        .modal-prompt {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.95);
            margin-bottom: 12px;
            font-weight: 500;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 12px;
        }

        .modal-close {
            position: absolute;
            top: -50px;
            right: 0;
            background: white;
            color: #000;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transition: all 0.2s;
        }

        .modal-close:hover {
            background: var(--primary-color);
            color: white;
            transform: rotate(90deg);
        }

        .modal-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.9);
            color: #000;
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            z-index: 10;
        }

        .modal-nav:hover {
            background: var(--primary-color);
            color: white;
            transform: translateY(-50%) scale(1.1);
        }

        .modal-nav:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .modal-nav-prev { left: 20px; }
        .modal-nav-next { right: 20px; }

        .modal-prompt-container {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            margin-bottom: 12px;
        }

        .modal-prompt {
            flex: 1;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.95);
            font-weight: 500;
        }

        .modal-seed {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 10px;
            font-weight: 500;
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .sidebar {
                width: 320px;
            }
            .gallery {
                grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            }
        }

        @media (max-width: 768px) {
            .app-container {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid var(--border-color);
                max-height: 50vh;
            }
            .video-sidebar {
                width: 100%;
                max-height: 50vh;
            }
            .gallery {
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            }
        }

        /* ==================== TABS + VIDEO TAB ==================== */
        .tabs {
            display: flex;
            gap: 4px;
            padding: 0 24px;
            background: var(--bg-sidebar);
            border-bottom: 1px solid var(--border-color);
        }

        .tab {
            padding: 12px 24px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            border-bottom: 2px solid transparent;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .tab:hover { color: var(--text-primary); }
        .tab.active { color: var(--primary-color); border-bottom-color: var(--primary-color); }

        .tab-content { display: none; flex: 1; overflow: hidden; }
        .tab-content.active { display: flex; flex-direction: column; }

        /* Video Layout */
        .video-layout {
            display: flex;
            gap: 20px;
            height: 100%;
            padding: 24px;
            overflow: hidden;
        }

        .prompt-panel {
            width: 300px;
            background: var(--bg-sidebar);
            padding: 20px;
            border-radius: 8px;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .scenes {
            flex: 1;
            overflow-y: auto;
            padding-right: 12px;
        }

        .scene-row {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 24px;
            background: var(--bg-card);
            padding: 16px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .scene-image {
            position: relative;
            width: 200px;
            height: 150px;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid var(--border-color);
            flex-shrink: 0;
            background: var(--bg-main);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .scene-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .scene-image .remove-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            background: rgba(234, 67, 53, 0.9);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            line-height: 20px;
            font-weight: bold;
            z-index: 10;
        }

        .scene-image .remove-btn:hover {
            background: var(--danger-color);
        }

        .scene-counter {
            position: absolute;
            top: 8px;
            left: 8px;
            background: var(--primary-color);
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            z-index: 10;
        }

        .scene-prompt {
            flex: 1;
        }

        .scene-prompt textarea {
            width: 100%;
            min-height: 80px;
            background: var(--bg-main);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 10px;
            font-family: inherit;
            font-size: 14px;
            resize: vertical;
        }

        .scene-prompt.extend {
            background: rgba(234, 67, 53, 0.1);
            border: 1px solid var(--danger-color);
            padding: 12px;
            border-radius: 8px;
        }

        .arrow {
            font-size: 24px;
            color: var(--text-secondary);
            flex-shrink: 0;
        }

        /* Video Progress */
        .video-progress {
            background: var(--bg-card);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 16px;
            border: 1px solid var(--border-color);
        }

        /* Variant Viewer */
        .variant-viewer {
            background: var(--bg-card);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 16px;
            border: 1px solid var(--border-color);
            text-align: center;
        }

        .variant-controls {
            display: flex;
            gap: 12px;
            align-items: center;
            justify-content: center;
            margin: 16px 0;
        }

        .variant-controls button {
            padding: 8px 16px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
        }

        .variant-controls button:hover {
            background: var(--primary-hover);
        }

        .variant-controls span {
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 600;
            min-width: 60px;
        }

        /* Autocomplete Dropdown */
        .mention-autocomplete {
            position: absolute;
            background: var(--bg-sidebar);
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
            min-width: 250px;
            display: none;
        }

        .mention-autocomplete.active {
            display: block;
        }

        .mention-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            cursor: pointer;
            transition: background 0.2s;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .mention-item:hover,
        .mention-item.selected {
            background: rgba(26, 115, 232, 0.2);
        }

        .mention-item img {
            width: 50px;
            height: 50px;
            border-radius: 6px;
            object-fit: cover;
            border: 2px solid rgba(255,255,255,0.1);
        }

        .mention-item-info {
            flex: 1;
        }

        .mention-item-name {
            font-size: 13px;
            font-weight: 600;
            color: var(--primary-color);
        }

        .mention-item-type {
            font-size: 10px;
            color: var(--text-secondary);
        }

        .mention-empty {
            padding: 12px;
            text-align: center;
            color: var(--text-secondary);
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <h2>üé® Whisk AI Generator</h2>
                <p class="sidebar-subtitle">Create stunning images with AI</p>
            </div>

            <div class="sidebar-body">
                <!-- Quick Links -->
                <div style="margin-bottom: 24px; display: flex; gap: 8px;">
                    <a href="lanes-manager.html" class="btn btn-primary" style="flex: 1; text-decoration: none; text-align: center;">‚öôÔ∏è Qu·∫£n l√Ω Lanes</a>
                    <a href="index4.html" class="btn btn-secondary" style="flex: 1; text-decoration: none; text-align: center;">üß™ Test (Index4)</a>
                </div>

                <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
                <!-- PROMPTS INPUT - PH·∫¶N CH√çNH -->
                <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
                <div class="form-group" style="border: 2px solid var(--primary-color); border-radius: 12px; padding: 16px; background: rgba(26, 115, 232, 0.05); margin-bottom: 24px;">
                    <label style="font-size: 15px; font-weight: 700; margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
                        <span style="font-size: 24px;">‚úçÔ∏è</span>
                        <span>M√¥ T·∫£ ·∫¢nh</span>
                    </label>
                    <textarea id="promptsInput" placeholder="@ben ƒëang ·ªü trong @phongngu&#10;@lucy ƒëi ra ph√≤ng kh√°ch&#10;@ben v√† @lucy ch∆°i c√πng nhau" style="min-height: 120px;"></textarea>
                    <div class="help-text" style="margin-top: 8px;">
                        üí° <strong>M·ªói d√≤ng = 1 ·∫£nh</strong><br>
                        üîñ <strong>D√πng @t√™n</strong> ƒë·ªÉ g·ªçi nh√¢n v·∫≠t/c·∫£nh ƒë√£ t·∫°o
                    </div>
                </div>

                <!-- Settings Row -->
                <div class="settings-row" style="margin-bottom: 20px;">
                    <div class="form-group">
                        <label>üìê T·ª∑ L·ªá</label>
                        <select id="aspectRatio">
                            <option value="IMAGE_ASPECT_RATIO_LANDSCAPE">Ngang</option>
                            <option value="IMAGE_ASPECT_RATIO_PORTRAIT">D·ªçc</option>
                            <option value="IMAGE_ASPECT_RATIO_SQUARE">Vu√¥ng</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label>üé≤ Seed</label>
                        <input type="number" id="seedInput" placeholder="Auto">
                    </div>
                </div>

                <!-- Batch Quantity Row -->
                <div class="form-group" style="margin-bottom: 20px;">
                    <label>üî¢ S·ªë l∆∞·ª£ng ·∫£nh gen ƒë·ªìng lo·∫°t</label>
                    <select id="imageBatchQuantity">
                        <option value="1">1 ·∫£nh</option>
                        <option value="2">2 ·∫£nh</option>
                        <option value="3" selected>3 ·∫£nh</option>
                        <option value="4">4 ·∫£nh</option>
                        <option value="5">5 ·∫£nh</option>
                        <option value="6">6 ·∫£nh</option>
                        <option value="7">7 ·∫£nh</option>
                        <option value="8">8 ·∫£nh</option>
                        <option value="9">9 ·∫£nh</option>
                        <option value="10">10 ·∫£nh</option>
                    </select>
                    <div class="help-text">S·ªë ·∫£nh s·∫Ω ƒë∆∞·ª£c t·∫°o cho m·ªói prompt</div>
                </div>

                <!-- Style & Reference Mode -->
                <div class="form-group">
                    <label>üé® Phong C√°ch</label>
                    <select id="stylePreset" onchange="handleStyleChange()">
                        <option value="">-- Kh√¥ng √°p d·ª•ng --</option>
                        <option value="realistic">üì∑ Realistic Photo</option>
                        <option value="anime">üéå Anime Style</option>
                        <option value="oil-painting">üñºÔ∏è Oil Painting</option>
                        <option value="watercolor">üíß Watercolor</option>
                        <option value="3d-render">üéÆ 3D Render</option>
                        <option value="sketch">‚úèÔ∏è Pencil Sketch</option>
                        <option value="vintage">üì∏ Vintage Photo</option>
                        <option value="cyberpunk">üåÉ Cyberpunk</option>
                        <option value="fantasy">‚ú® Fantasy Art</option>
                        <option value="minimalist">‚ö™ Minimalist</option>
                    </select>
                </div>

                <div class="form-group">
                    <label>üîó Batch Reference Mode</label>
                    <select id="batchReferenceMode">
                        <option value="auto" selected>‚ú® Auto - T·ª± ƒë·ªông nh·∫≠n d·∫°ng (Continue)</option>
                        <option value="none">Kh√¥ng d√πng reference</option>
                        <option value="first">D√πng ·∫£nh ƒë·∫ßu l√†m reference</option>
                        <option value="chain">Chain - M·ªói ·∫£nh reference ·∫£nh tr∆∞·ªõc</option>
                    </select>
                    <div class="help-text">Auto: N·∫øu prompt c√≥ (Continue) ‚Üí d√πng ·∫£nh tr∆∞·ªõc l√†m ref. Chain: Ti·∫øn h√≥a d·∫ßn.</div>
                </div>

                <!-- Image Folder Selection -->
                <div style="margin-bottom: 12px; padding: 12px; background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 6px;">
                    <label style="display: block; font-size: 12px; font-weight: 600; margin-bottom: 6px; color: var(--text-primary);">
                        üìÅ Th∆∞ m·ª•c l∆∞u ·∫£nh:
                    </label>
                    <div style="display: flex; gap: 6px;">
                        <input type="text" id="imageFolderPath" placeholder="D:\D·ª± √°n\·∫¢nh" value="D:\D·ª± √°n\·∫¢nh" style="flex: 1; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; font-size: 12px; background: var(--bg-main); color: var(--text-primary);" />
                        <button onclick="selectImageFolder()" class="btn btn-secondary" style="padding: 8px 12px; font-size: 11px; white-space: nowrap;">
                            üìÇ Ch·ªçn
                        </button>
                    </div>
                    <div style="font-size: 10px; color: var(--text-secondary); margin-top: 4px;">
                        ·∫¢nh s·∫Ω t·ª± ƒë·ªông l∆∞u v√†o th∆∞ m·ª•c n√†y khi generate
                    </div>
                    <div style="margin-top: 8px;">
                        <label style="font-size: 11px; display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="checkbox" id="autoDownload" checked>
                            T·ª± ƒë·ªông t·∫£i v·ªÅ
                        </label>
                    </div>
                </div>

                <!-- Generate Button -->
                <button class="btn btn-success" onclick="generateBatch()" id="generateBtn" style="width: 100%; padding: 14px; font-size: 15px; margin-bottom: 12px;" disabled>
                    ‚ú® T·∫°o ·∫¢nh
                </button>

                <!-- Clear All Button -->
                <button class="btn btn-danger" onclick="clearAllImages()" id="clearAllBtn" style="width: 100%; padding: 10px; font-size: 13px; margin-bottom: 12px; background: #dc2626; border-color: #dc2626;">
                    üóëÔ∏è Clear All Images
                </button>

                <div id="progressBar" class="progress-bar" style="display: none; margin-bottom: 12px;">
                    <div class="progress-fill" id="progressFill"></div>
                </div>

                <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
                <!-- IMAGE PROJECT MANAGEMENT -->
                <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
                <div class="reference-section" style="border: 2px solid #f59e0b; background: rgba(245, 158, 11, 0.05); margin-bottom: 20px;">
                    <label style="font-size: 13px; font-weight: 600; display: block; margin-bottom: 8px;">
                        üñºÔ∏è Qu·∫£n L√Ω D·ª± √Ån ·∫¢nh
                    </label>
                    <div class="help-text">L∆∞u v√† load to√†n b·ªô ·∫£nh ƒë√£ gen</div>

                    <div style="margin-top: 12px;">
                        <!-- Image Project Name -->
                        <label style="font-size: 11px; color: var(--text-secondary); display: block; margin-bottom: 4px;">üè∑Ô∏è T√™n d·ª± √°n ·∫£nh:</label>
                        <input type="text" id="imageProjectName" placeholder="VD: Space-Journey, Character-Designs..." style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid var(--border-color); background: var(--bg-main); color: var(--text-primary); font-size: 12px; margin-bottom: 8px;">

                        <!-- Image Project Selector -->
                        <label style="font-size: 11px; color: var(--text-secondary); display: block; margin-bottom: 4px;">üìã Ch·ªçn d·ª± √°n ·∫£nh:</label>
                        <select id="imageProjectSelector" onchange="loadSelectedImageProject()" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid var(--border-color); background: var(--bg-main); color: var(--text-primary); font-size: 12px; margin-bottom: 8px;">
                            <option value="">-- Ch·ªçn d·ª± √°n --</option>
                        </select>

                        <!-- Action Buttons -->
                        <div style="display: flex; gap: 6px;">
                            <button class="btn btn-primary" onclick="saveImageProject()" style="flex: 1; font-size: 12px;">
                                üíæ L∆∞u D·ª± √Ån ·∫¢nh
                            </button>
                            <button class="btn btn-secondary" onclick="refreshImageProjectList()" style="flex: 1; font-size: 12px;">
                                üîÑ Refresh
                            </button>
                        </div>
                        <div class="help-text" style="margin-top: 6px;">üí° L∆∞u to√†n b·ªô <span id="imageCount">0</span> ·∫£nh trong gallery ƒë·ªÉ load l·∫°i sau</div>
                    </div>
                </div>

                <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
                <!-- PROJECT MANAGEMENT -->
                <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
                <div class="reference-section" style="border: 2px solid #3b82f6; background: rgba(59, 130, 246, 0.05); margin-bottom: 20px;">
                    <label style="font-size: 13px; font-weight: 600; display: block; margin-bottom: 8px;">
                        üìÅ Qu·∫£n L√Ω D·ª± √Ån Reference
                    </label>
                    <div class="help-text">L∆∞u v√† load references theo d·ª± √°n</div>

                    <div style="margin-top: 12px;">
                        <!-- Ref Folder Path -->
                        <label style="font-size: 11px; color: var(--text-secondary); display: block; margin-bottom: 4px;">üìÇ ƒê∆∞·ªùng d·∫´n th∆∞ m·ª•c Ref:</label>
                        <input type="text" id="refFolderPath" placeholder="D:\1\Ref" value="D:\1\Ref" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid var(--border-color); background: var(--bg-main); color: var(--text-primary); font-size: 12px; margin-bottom: 8px;">

                        <!-- Project Name -->
                        <label style="font-size: 11px; color: var(--text-secondary); display: block; margin-bottom: 4px;">üè∑Ô∏è T√™n d·ª± √°n:</label>
                        <input type="text" id="projectName" placeholder="VD: Hoat-hinh, Truyen-tranh..." style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid var(--border-color); background: var(--bg-main); color: var(--text-primary); font-size: 12px; margin-bottom: 8px;">

                        <!-- Project Selector -->
                        <label style="font-size: 11px; color: var(--text-secondary); display: block; margin-bottom: 4px;">üìã Ch·ªçn d·ª± √°n c√≥ s·∫µn:</label>
                        <select id="projectSelector" onchange="loadSelectedProject()" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid var(--border-color); background: var(--bg-main); color: var(--text-primary); font-size: 12px; margin-bottom: 8px;">
                            <option value="">-- Ch·ªçn d·ª± √°n --</option>
                        </select>

                        <!-- Action Buttons -->
                        <div style="display: flex; gap: 6px;">
                            <button class="btn btn-primary" onclick="saveCurrentProject()" style="flex: 1; font-size: 12px;">
                                üíæ L∆∞u D·ª± √Ån
                            </button>
                            <button class="btn btn-secondary" onclick="refreshProjectList()" style="flex: 1; font-size: 12px;">
                                üîÑ Refresh
                            </button>
                        </div>
                        <div class="help-text" style="margin-top: 6px;">üí° D·ª± √°n s·∫Ω l∆∞u t·∫•t c·∫£ references v√†o th∆∞ m·ª•c c√πng t√™n</div>
                    </div>
                </div>

                <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
                <!-- CREATE REFERENCE -->
                <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
                <div class="reference-section" style="border: 2px solid #10b981; background: rgba(16, 185, 129, 0.05); margin-bottom: 20px;">
                    <label style="font-size: 13px; font-weight: 600; display: block; margin-bottom: 8px;">
                        ‚≠ê T·∫°o Reference M·ªõi
                    </label>
                    <div class="help-text">T·∫°o nh√¢n v·∫≠t/c·∫£nh v·ªõi t√™n g·ªçi ƒë·ªÉ d√πng l·∫°i</div>

                    <div style="margin-top: 12px;">
                        <input type="text" id="referenceName" placeholder="T√™n (VD: ben, lucy, phongngu)" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid var(--border-color); background: var(--bg-main); color: var(--text-primary); font-size: 13px; margin-bottom: 8px;">

                        <select id="referenceType" class="select" style="width: 100%; margin-bottom: 8px;">
                            <option value="character">üë§ Nh√¢n V·∫≠t</option>
                            <option value="scene">üèûÔ∏è Khung C·∫£nh</option>
                        </select>

                        <textarea id="referencePrompt" placeholder="M√¥ t·∫£ chi ti·∫øt..." style="width: 100%; min-height: 60px; padding: 8px; border-radius: 6px; border: 1px solid var(--border-color); background: var(--bg-main); color: var(--text-primary); font-size: 13px; resize: vertical; margin-bottom: 8px;"></textarea>

                        <button class="btn btn-success" onclick="generateReferenceImage()" style="width: 100%;">
                            ‚ú® T·∫°o Reference
                        </button>
                    </div>
                </div>

                <!-- Reference Library -->
                <div class="reference-section" id="referenceSection" style="margin-bottom: 20px;">
                    <label style="font-size: 13px; font-weight: 600; display: block; margin-bottom: 8px;">
                        üñºÔ∏è Th∆∞ Vi·ªán Reference
                    </label>
                    <div class="help-text">Click üîç ƒë·ªÉ xem, √ó ƒë·ªÉ x√≥a</div>

                    <!-- Tabs -->
                    <div style="display: flex; gap: 8px; margin: 12px 0;">
                        <button class="btn btn-secondary" id="tabCharacters" onclick="switchReferenceTab('character')" style="flex: 1; font-size: 11px;">
                            üë§ <span id="countCharacters">0</span>
                        </button>
                        <button class="btn btn-secondary" id="tabScenes" onclick="switchReferenceTab('scene')" style="flex: 1; font-size: 11px;">
                            üèûÔ∏è <span id="countScenes">0</span>
                        </button>
                    </div>

                    <div id="referenceGridCharacters" class="reference-grid" style="display: none;"></div>
                    <div id="referenceGridScenes" class="reference-grid" style="display: none;"></div>

                    <button class="btn btn-secondary" onclick="uploadReferenceImage()" style="width: 100%; margin-top: 8px;">
                        üì§ Upload
                    </button>
                    <input type="file" id="referenceFileInput" accept="image/*" style="display: none;" onchange="handleReferenceFileUpload(event)">
                </div>

<!-- Save & Switch to Video -->
                <button class="btn btn-success" onclick="saveAndSwitchToVideo()" id="saveVideoBtn" style="width: 100%; margin-top: 12px; padding: 12px; font-size: 14px;" disabled>
                    üíæ L∆∞u & Chuy·ªÉn Video
                </button>
                <div class="image-counter">
                    ƒê√£ t·∫°o: <strong id="imageCount">0</strong> ·∫£nh
                </div>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Header -->
            <header class="header">
                <div class="header-title">
                    <svg width="28" height="28" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M21 3H3c-1.11 0-2 .89-2 2v12c0 1.1.89 2 2 2h5v2h8v-2h5c1.1 0 2-.9 2-2V5c0-1.11-.9-2-2-2zm0 14H3V5h18v12z"/>
                    </svg>
                    Whisk AI + Veo3
                </div>
                <div class="header-actions">
                    <button class="btn btn-secondary" onclick="VideoModule.saveCurrentImages()" style="font-size: 12px; padding: 6px 12px;">üíæ L∆∞u</button>
                    <button class="btn btn-success" onclick="VideoModule.confirmMoveToVideoSingle()" style="font-size: 12px; padding: 6px 12px;">‚û°Ô∏è 1 ·∫£nh 1 scene</button>
                    <button class="btn btn-success" onclick="VideoModule.confirmMoveToVideo()" style="font-size: 12px; padding: 6px 12px;">‚û°Ô∏è 2 ·∫£nh 1 scene</button>
                    <div id="videoDownloadProgress" style="display: none; font-size: 11px; color: var(--primary-color); margin-left: 12px; padding: 6px 12px; background: rgba(139, 92, 246, 0.1); border-radius: 4px; border: 1px solid var(--primary-color); white-space: nowrap;">
                        <span id="videoDownloadProgressText">üì• ƒêang t·∫£i: 0/0</span>
                    </div>
                </div>
            </header>

            <!-- Tabs -->
            <div class="tabs">
                <button class="tab active" onclick="switchTab('images', event)">üì∑ Images</button>
                <button class="tab" onclick="switchTab('video', event)">üé¨ Video</button>
            </div>

            <!-- Images Tab -->
            <div id="imagesTab" class="tab-content active">
                <!-- Gallery -->
                <div class="gallery-container">
                    <div class="gallery" id="gallery">
                        <div class="empty-state">
                            <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
                            </svg>
                            <h3>Ch∆∞a c√≥ ·∫£nh n√†o</h3>
                            <p>Nh·∫≠p m√¥ t·∫£ ·ªü sidebar v√† nh·∫•n "T·∫°o ·∫¢nh" ƒë·ªÉ b·∫Øt ƒë·∫ßu</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Video Tab -->
            <div id="videoTab" class="tab-content">
                <div style="display: flex; height: 100%; gap: 16px; overflow: hidden;">

                    <!-- Left Sidebar: Veo3 Generator -->
                    <div class="video-sidebar">
                        <h3 style="font-size: 16px; margin-bottom: 16px; color: var(--text-primary);">‚öôÔ∏è Video Controls</h3>

                        <!-- Bulk Prompts Input -->
                        <div style="margin-bottom: 16px; padding: 12px; background: rgba(26, 115, 232, 0.05); border: 1px solid var(--primary-color); border-radius: 8px;">
                            <label style="display: block; font-size: 13px; font-weight: 600; margin-bottom: 8px;">üìù Paste Prompts</label>
                            <textarea id="bulkPrompts" placeholder="A smooth camera pan across the scene&#10;(Continue) The camera zooms in slowly&#10;Bright colors fill the frame" 
                                style="width: 100%; min-height: 120px; padding: 8px; background: var(--bg-main); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 12px; resize: vertical;"></textarea>
                            <div style="font-size: 11px; color: var(--text-secondary); margin-top: 6px;">
                                üí° M·ªói d√≤ng = 1 scene<br>
                                ‚è© D√≤ng b·∫Øt ƒë·∫ßu <code>(Continue)</code> = extend video
                            </div>
                            <button class="btn btn-primary" onclick="transferPromptsToScenes()" style="width: 100%; margin-top: 8px; font-size: 12px;">
                                ‚û°Ô∏è Transfer to Scenes
                            </button>
                        </div>

                        <hr style="margin: 16px 0; border: none; border-top: 1px solid var(--border-color);">

                        <!-- Bulk Image Upload -->
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; font-size: 13px; font-weight: 600; margin-bottom: 8px;">üñºÔ∏è Upload Images</label>
                            <label for="bulkImageUpload" id="dropZone" style="display: block; width: 100%; padding: 12px; background: var(--bg-main); border: 2px dashed var(--border-color); border-radius: 6px; text-align: center; cursor: pointer; transition: all 0.2s;">
                                <span style="font-size: 32px; display: block; margin-bottom: 4px;">üì§</span>
                                <span style="font-size: 12px; color: var(--text-secondary);">Click or drag & drop 2+ images</span>
                            </label>
                            <input type="file" id="bulkImageUpload" multiple accept="image/*" style="display: none;" onchange="handleBulkImageUpload(event)">
                            <div style="font-size: 11px; color: var(--text-secondary); margin-top: 6px;">
                                üìå Select 2+ images ‚Üí auto-create scenes: 1-2, 2-3, 3-4...
                            </div>
                        </div>

                        <hr style="margin: 16px 0; border: none; border-top: 1px solid var(--border-color);">

                        <!-- Project Setup -->
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; font-size: 13px; font-weight: 600; margin-bottom: 8px;">üîó Project Setup</label>
                            <input type="text" id="projectUrl" placeholder="https://labs.google/fx/.../project/xxx/scenes/xxx"
                                oninput="autoExtractProjectScene()" onpaste="setTimeout(autoExtractProjectScene, 100)"
                                style="width: 100%; padding: 8px; background: var(--bg-main); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 11px; margin-bottom: 8px;">
                            
                            <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 8px; margin-bottom: 8px;">
                                <input type="text" id="projectId" placeholder="Project ID" readonly
                                    style="padding: 6px; background: var(--bg-main); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 11px;">
                                <input type="text" id="sceneId" placeholder="Scene" readonly
                                    style="padding: 6px; background: var(--bg-main); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 11px;">
                            </div>

                            <button class="btn btn-secondary" onclick="extractProjectScene()" style="width: 100%; font-size: 12px; padding: 8px;">
                                üìã Extract from URL
                            </button>
                        </div>

                        <hr style="margin: 16px 0; border: none; border-top: 1px solid var(--border-color);">

                        <!-- Video Settings -->
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; font-size: 13px; font-weight: 600; margin-bottom: 8px;">‚öôÔ∏è Video Options</label>

                            <div style="margin-bottom: 10px;">
                                <label style="display: block; font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Aspect Ratio</label>
                                <select id="videoAspectRatio" style="width: 100%; padding: 6px; background: var(--bg-main); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 12px;">
                                    <option value="VIDEO_ASPECT_RATIO_LANDSCAPE">üñ•Ô∏è Landscape (16:9)</option>
                                    <option value="VIDEO_ASPECT_RATIO_PORTRAIT">üì± Portrait (9:16)</option>
                                    <option value="VIDEO_ASPECT_RATIO_SQUARE">‚¨ú Square (1:1)</option>
                                </select>
                            </div>

                            <div style="margin-bottom: 10px;">
                                <label style="display: block; font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Versions per Scene</label>
                                <input type="number" id="videoVersions" value="2" min="1" max="4"
                                    style="width: 100%; padding: 6px; background: var(--bg-main); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 12px;">
                            </div>

                            <div style="margin-bottom: 10px;">
                                <label style="display: block; font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">üî¢ S·ªë video gen ƒë·ªìng lo·∫°t</label>
                                <select id="videoBatchQuantity" style="width: 100%; padding: 6px; background: var(--bg-main); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 12px;">
                                    <option value="1">1 video</option>
                                    <option value="2" selected>2 video</option>
                                    <option value="3">3 video</option>
                                    <option value="4">4 video</option>
                                    <option value="5">5 video</option>
                                    <option value="6">6 video</option>
                                    <option value="7">7 video</option>
                                    <option value="8">8 video</option>
                                    <option value="9">9 video</option>
                                    <option value="10">10 video</option>
                                </select>
                                <div style="font-size: 10px; color: var(--text-secondary); margin-top: 4px;">
                                    S·ªë video s·∫Ω ƒë∆∞·ª£c t·∫°o cho m·ªói scene
                                </div>
                            </div>

                            <label style="display: flex; align-items: center; gap: 8px; font-size: 12px; cursor: pointer;">
                                <input type="checkbox" id="videoAutoDownload" checked>
                                <span>üíæ Auto-download after generation</span>
                            </label>
                        </div>

                        <hr style="margin: 16px 0; border: none; border-top: 1px solid var(--border-color);">

                        <!-- Output Folder Selection -->
                        <div style="margin-bottom: 12px; padding: 12px; background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 6px;">
                            <label style="display: block; font-size: 12px; font-weight: 600; margin-bottom: 6px; color: var(--text-primary);">
                                üìÅ Th∆∞ m·ª•c t·∫£i video:
                            </label>
                            <div style="display: flex; gap: 6px;">
                                <input type="text" id="outputFolderPath" placeholder="C:\Users\Work\Videos\Veo3" style="flex: 1; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; font-size: 12px; background: var(--bg-main); color: var(--text-primary);" />
                                <button onclick="openOutputFolder()" class="btn btn-primary" style="padding: 8px 12px; font-size: 11px; white-space: nowrap;">
                                    üìÇ M·ªü
                                </button>
                                <button onclick="resetOutputFolder()" class="btn btn-secondary" style="padding: 8px 12px; font-size: 11px; white-space: nowrap;">
                                    üîÑ M·∫∑c ƒë·ªãnh
                                </button>
                            </div>
                            <div style="font-size: 10px; color: var(--text-secondary); margin-top: 4px;">
                                ƒê·ªÉ tr·ªëng = th∆∞ m·ª•c m·∫∑c ƒë·ªãnh (./videos)
                            </div>
                        </div>

                        <hr style="margin: 16px 0; border: none; border-top: 1px solid var(--border-color);">

                        <!-- Reference to Video -->
                        <div style="margin-bottom: 12px; padding: 12px; background: rgba(139, 92, 246, 0.05); border: 2px solid #8b5cf6; border-radius: 6px;">
                            <label style="display: block; font-size: 13px; font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">
                                üé® Reference to Video
                            </label>
                            <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px;">
                                D√πng 3 ·∫£nh reference ƒë·ªÉ t·∫°o video (ingredient to video)
                            </div>

                            <!-- Project Selector (linked to Images tab) -->
                            <label style="font-size: 11px; color: var(--text-secondary); display: block; margin-bottom: 4px;">üìÅ Load t·ª´ d·ª± √°n:</label>
                            <select id="videoRefProjectSelector" onchange="loadRefProjectToVideo()" style="width: 100%; padding: 6px; border-radius: 4px; border: 1px solid var(--border-color); background: var(--bg-main); color: var(--text-primary); font-size: 11px; margin-bottom: 8px;">
                                <option value="">-- Ch·ªçn d·ª± √°n --</option>
                            </select>

                            <!-- Quick access to saved references -->
                            <div id="videoRefQuickList" style="display: none; margin-bottom: 8px; max-height: 120px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 4px; padding: 6px; background: var(--bg-main);">
                                <!-- Will be populated with references from selected project -->
                            </div>

                            <button class="btn btn-secondary" onclick="syncReferencesFromImages()" style="width: 100%; font-size: 11px; padding: 6px;">
                                üîÑ Sync t·ª´ tab Images
                            </button>

                            <!-- Auto Prompt Detection -->
                            <div style="margin-top: 12px; padding: 8px; background: rgba(255, 255, 255, 0.03); border-radius: 4px; border: 1px solid rgba(139, 92, 246, 0.3);">
                                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 11px; color: var(--text-primary);">
                                    <input type="checkbox" id="autoPromptDetection" onchange="toggleAutoPromptDetection()" checked style="cursor: pointer;">
                                    <span>‚ú® Auto prompt (detect @mentions)</span>
                                </label>
                                <div style="font-size: 10px; color: var(--text-secondary); margin-top: 4px; margin-left: 20px;">
                                    T·ª± ƒë·ªông chuy·ªÉn sang Reference to Video khi prompt c√≥ @mentions
                                </div>
                            </div>
                        </div>

                        <hr style="margin: 16px 0; border: none; border-top: 1px solid var(--border-color);">

                        <!-- Test Gen Video t·ª´ MediaID -->
                        <div style="margin-bottom: 16px; padding: 12px; background: rgba(249, 171, 0, 0.05); border: 2px solid var(--warning-color); border-radius: 6px;">
                            <label style="display: block; font-size: 13px; font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">
                                üß™ Test Gen Video t·ª´ MediaID
                            </label>
                            <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px;">
                                Test nhanh video generation v·ªõi 2 MediaID c√≥ s·∫µn
                            </div>

                            <div style="margin-bottom: 8px;">
                                <label style="font-size: 11px; color: var(--text-secondary); display: block; margin-bottom: 4px;">Start Image MediaID:</label>
                                <input type="text" id="testStartMediaId"
                                    value="CAMaJDAyMTY1NzAxLTBkMmQtNDQzMy1iNTRkLWRmZjQ0YTE0OTNkZSIEQ0lvQiokNjYxZGZkNDYtMzQ2Yi00MWJlLTg1OTctMGRkOGJmZjQ0ZTMx"
                                    style="width: 100%; padding: 6px; background: var(--bg-main); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 10px; font-family: monospace;">
                            </div>

                            <div style="margin-bottom: 8px;">
                                <label style="font-size: 11px; color: var(--text-secondary); display: block; margin-bottom: 4px;">End Image MediaID:</label>
                                <input type="text" id="testEndMediaId"
                                    value="CAMaJDAyMTY1NzAxLTBkMmQtNDQzMy1iNTRkLWRmZjQ0YTE0OTNkZSIEQ0lzQiokYzJmOTcwYTctMmIwNS00Yjc2LWI3NzgtMWE5YWFlYTBlNTBm"
                                    style="width: 100%; padding: 6px; background: var(--bg-main); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 10px; font-family: monospace;">
                            </div>

                            <div style="margin-bottom: 8px;">
                                <label style="font-size: 11px; color: var(--text-secondary); display: block; margin-bottom: 4px;">Prompt:</label>
                                <input type="text" id="testPrompt"
                                    value="camera xoay v√≤ng tr√≤n"
                                    placeholder="Enter video prompt..."
                                    style="width: 100%; padding: 6px; background: var(--bg-main); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 11px;">
                            </div>

                            <button class="btn btn-warning" onclick="testGenerateFromMediaId()" style="width: 100%; font-size: 12px; padding: 8px;">
                                üöÄ Test Generate
                            </button>

                            <div id="testResult" style="display: none; margin-top: 8px; padding: 8px; background: var(--bg-main); border-radius: 4px; font-size: 11px; color: var(--text-primary); border: 1px solid var(--border-color);">
                                <!-- Test result will show here -->
                            </div>
                        </div>

                        <hr style="margin: 16px 0; border: none; border-top: 1px solid var(--border-color);">

                        <!-- Actions -->
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            <button class="btn btn-success" onclick="generateAllVideos()" id="genAllVideosBtn" style="width: 100%; padding: 12px; font-size: 14px; font-weight: 700;">
                                üé¨ Generate All Videos
                            </button>

                            <!-- Check Error Scenes Buttons (hidden by default, shown after gen all completes) -->
                            <div id="checkErrorButtons" style="display: none; flex-direction: row; gap: 8px;">
                                <button class="btn btn-warning" onclick="checkErrorScenes('single')" style="flex: 1; padding: 10px; font-size: 13px; font-weight: 600;">
                                    üîç Ki·ªÉm tra (1 ·∫£nh 1 scene)
                                </button>
                                <button class="btn btn-warning" onclick="checkErrorScenes('double')" style="flex: 1; padding: 10px; font-size: 13px; font-weight: 600;">
                                    üîç Ki·ªÉm tra (2 ·∫£nh 1 scene)
                                </button>
                            </div>

                            <!-- Generate Progress -->
                            <div id="generateProgress" style="display: none; background: rgba(139, 92, 246, 0.1); padding: 12px; border-radius: 6px; border: 1px solid var(--primary-color);">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 6px; color: var(--text-primary); font-size: 12px; font-weight: 600;">
                                    <span id="generateProgressText">‚è≥ ƒêang generate: 0/0</span>
                                    <span id="generateProgressPercent">0%</span>
                                </div>
                                <div style="width: 100%; height: 8px; background: rgba(0,0,0,0.2); border-radius: 4px; overflow: hidden;">
                                    <div id="generateProgressBar" style="width: 0%; height: 100%; background: linear-gradient(90deg, var(--primary-color), #a78bfa); transition: width 0.3s ease;"></div>
                                </div>
                                <div id="generateProgressDetail" style="font-size: 10px; color: var(--text-secondary); margin-top: 6px;">
                                    ƒêang x·ª≠ l√Ω...
                                </div>
                            </div>

                            <button class="btn btn-secondary" onclick="syncVideosFromGoogle()" id="syncVideosBtn" style="width: 100%; padding: 10px; font-size: 13px;">
                                üîÑ Sync Videos t·ª´ Google
                            </button>
                            <button class="btn btn-primary" onclick="downloadAllVideos()" id="downloadAllVideosBtn" style="width: 100%; padding: 10px; font-size: 13px;" disabled>
                                üíæ Download All Selected
                            </button>
                        </div>

                        <!-- Download Progress -->
                        <div id="downloadProgress" style="display: none; background: var(--bg-card); padding: 16px; border-radius: 8px; margin-top: 12px; border: 1px solid var(--border-color);">
                            <h4 style="margin: 0 0 12px 0; color: var(--text-primary); font-size: 13px; text-align: center;">üíæ ƒêang t·∫£i video...</h4>
                            <div style="margin-bottom: 12px;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 6px; color: var(--text-secondary); font-size: 12px;">
                                    <span id="downloadProgressText">0/0</span>
                                    <span id="downloadProgressPercent">0%</span>
                                </div>
                                <div style="width: 100%; height: 6px; background: var(--bg-main); border-radius: 3px; overflow: hidden;">
                                    <div id="downloadProgressBar" style="width: 0%; height: 100%; background: var(--primary-color); transition: width 0.3s;"></div>
                                </div>
                            </div>
                            <div id="downloadFileList" style="max-height: 150px; overflow-y: auto; margin-bottom: 12px; font-size: 11px;">
                                <!-- File download status will be added here -->
                            </div>
                            <button onclick="closeDownloadProgress()" class="btn btn-secondary" style="width: 100%; display: none; padding: 6px; font-size: 12px;" id="downloadCloseBtn">
                                ‚úì ƒê√≥ng
                            </button>
                        </div>
                    </div>
                       <!-- Main Content: Scenes Management -->
                    <div style="flex: 1; min-width: 0; background: var(--bg-card); border-radius: 8px; padding: 20px; display: flex; flex-direction: column; overflow: hidden;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                            <h3 style="font-size: 18px; color: var(--text-primary); display: flex; align-items: center; gap: 8px; margin: 0;">
                                üé¨ Scenes
                                <span id="scenesCount" style="font-size: 14px; color: var(--text-secondary); font-weight: normal;">(0)</span>
                            </h3>
                            <button class="btn btn-secondary" onclick="clearAllScenes()" style="font-size: 12px; padding: 6px 12px;">
                                üóëÔ∏è Clear All
                            </button>
                        </div>
                        
                        <div id="videoScenes" style="flex: 1; overflow-y: auto; padding: 8px;">
                            <div id="emptyScenesMessage" style="text-align: center; color: var(--text-secondary); padding: 60px 20px;">
                                Ch∆∞a c√≥ scenes.<br><br>
                                üìå <strong>Option 1:</strong> Gen ·∫£nh ‚Üí Nh·∫•n "üíæ L∆∞u & Chuy·ªÉn Video"<br>
                                üìå <strong>Option 2:</strong> Upload ·∫£nh t·ª´ m√°y (2+ images)<br>
                                üìå <strong>Option 3:</strong> Paste prompts ‚Üí Transfer to Scenes<br>
                                üìå <strong>Option 4:</strong> T·∫°o scene tr·ªëng v√† upload ·∫£nh sau<br><br>
                                <button class="btn btn-primary" onclick="addEmptyScene()" style="padding: 10px 20px; font-size: 14px;">‚ûï Th√™m Scene M·ªõi</button>
                            </div>
                        </div>
                    </div>
                            </p>
                        </div>
                    </div>

                </div>
            </div>
        </main>
    </div>

    <!-- Modal -->
    <div class="modal" id="imageModal" onclick="closeModal(event)">
        <div class="modal-content" onclick="event.stopPropagation()">
            <button class="modal-close" onclick="closeModal()">√ó</button>

            <!-- Batch Navigation -->
            <button class="modal-nav modal-nav-prev" id="modalPrevBatch" onclick="navigateBatch(-1)" title="Batch tr∆∞·ªõc">‚óÑ</button>
            <button class="modal-nav modal-nav-next" id="modalNextBatch" onclick="navigateBatch(1)" title="Batch sau">‚ñ∫</button>

            <img class="modal-image" id="modalImage" src="" alt="">

            <div class="modal-info">
                <div class="modal-prompt-container">
                    <div class="modal-prompt" id="modalPrompt"></div>
                    <button class="btn-icon" onclick="editModalPrompt()" id="modalEditBtn" title="Ch·ªânh s·ª≠a prompt" style="padding: 4px 8px; font-size: 10px; margin-left: 8px;">‚úèÔ∏è</button>
                </div>

                <div class="modal-seed" id="modalSeed"></div>

                <!-- Version Navigation -->
                <div class="modal-version-nav" id="modalVersionNav" style="display: none; margin: 12px 0; text-align: center;">
                    <button class="btn-icon" onclick="navigateModalVersion('prev')" id="modalVerPrev">‚Üê</button>
                    <span id="modalVersionInfo" style="margin: 0 12px; font-size: 13px; color: var(--text-secondary);"></span>
                    <button class="btn-icon" onclick="navigateModalVersion('next')" id="modalVerNext">‚Üí</button>
                    <button class="btn btn-primary" onclick="selectCurrentVersion()" id="modalSelectVersion" style="margin-left: 12px; padding: 6px 12px; font-size: 12px;">‚úì Ch·ªçn version n√†y</button>
                </div>

                <div class="modal-actions" id="modalActions">
                    <button class="btn btn-primary" onclick="regenerateModalImage()" id="regenNormalBtn">üîÑ Regen</button>
                    <button class="btn btn-primary" onclick="regenerateReference()" id="regenRefBtn" style="display: none;">üîÑ Regen Reference</button>
                    <button class="btn btn-primary" onclick="downloadCurrentImage()">üì• T·∫£i v·ªÅ</button>
                    <button class="btn btn-secondary" onclick="closeModal()">ƒê√≥ng</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Insert Image Modal -->
    <div class="modal" id="insertModal" onclick="closeInsertModal(event)">
        <div class="modal-content" onclick="event.stopPropagation()" style="max-width: 600px;">
            <button class="modal-close" onclick="closeInsertModal()">√ó</button>
            <h3 style="margin: 0 0 20px 0; color: var(--text-primary);">Ch√®n ·∫¢nh M·ªõi</h3>

            <div class="form-group">
                <label>‚úçÔ∏è Prompt</label>
                <textarea id="insertPrompt" placeholder="VD: @ben ƒëang nh√¨n ra c·ª≠a s·ªï" style="min-height: 100px;"></textarea>
                <div class="help-text">D√πng @t√™n ƒë·ªÉ g·ªçi reference ƒë√£ t·∫°o</div>
            </div>

            <div style="display: flex; gap: 12px; margin-top: 20px;">
                <button class="btn btn-primary" onclick="confirmInsert()" style="flex: 1;">
                    ‚ú® T·∫°o & Ch√®n
                </button>
                <button class="btn btn-secondary" onclick="closeInsertModal()" style="flex: 1;">
                    H·ªßy
                </button>
            </div>
        </div>
    </div>

    <!-- Video Preview Modal -->
    <div id="videoPreviewModal" style="display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.95); z-index: 10000; flex-direction: column; align-items: center; justify-content: center; padding: 40px;" onclick="closeVideoPreview()">
        <video id="videoPreviewPlayer" controls autoplay style="max-width: 90%; max-height: 80vh; border-radius: 8px; box-shadow: 0 8px 32px rgba(0,0,0,0.5);" onclick="event.stopPropagation()"></video>
        <button onclick="closeVideoPreview()" style="margin-top: 24px; padding: 12px 32px; background: var(--danger-color); color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer;">
            ‚úï Close
        </button>
    </div>

    <!-- Image Preview Modal -->
    <div id="imagePreviewModal" style="display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.95); z-index: 10000; flex-direction: column; align-items: center; justify-content: center; padding: 40px;" onclick="closeImagePreview()">
        <img id="imagePreviewImg" style="max-width: 90%; max-height: 80vh; border-radius: 8px; box-shadow: 0 8px 32px rgba(0,0,0,0.5); object-fit: contain;" onclick="event.stopPropagation()">
        <button onclick="closeImagePreview()" style="margin-top: 24px; padding: 12px 32px; background: var(--danger-color); color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer;">
            ‚úï Close
        </button>
    </div>

    <script>
        // Tab switching function (defined early for onclick handlers)
        function switchTab(tabName, event) {
            // Remove active class from all tabs and contents
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

            // Add active class to clicked tab and corresponding content
            if (event && event.target) {
                event.target.classList.add('active');
            }

            const contentId = tabName === 'images' ? 'imagesTab' : 'videoTab';
            const content = document.getElementById(contentId);
            if (content) {
                content.classList.add('active');
            }

            // Toggle Images sidebar visibility
            const sidebar = document.querySelector('.sidebar');
            if (sidebar) {
                if (tabName === 'video') {
                    sidebar.classList.add('hidden');  // Hide Images sidebar when in Video tab
                } else {
                    sidebar.classList.remove('hidden');  // Show Images sidebar when in Images tab
                }
            }
        }

        // State
        let images = [];
        let downloadFolderHandle = null;
        let currentModalImage = null;
        let namedReferences = {
            characters: {}, // { name: { imageUrl, prompt, seed, generationId } }
            scenes: {}      // { name: { imageUrl, prompt, seed, generationId } }
        };
        let currentReferenceTab = 'character';

        // Batch reference chain: tracks which image references which
        // Format: { imageId: { referenceId, generationId } }
        let batchReferenceChain = {};

        // Track highest batch index to continue numbering
        let maxBatchIndex = -1;

        // Insert modal state
        let pendingInsertAfterImageId = null;

        // VideoModule for tab switching and video operations
        const VideoModule = {
            switchTab(tabName, event) {
                // Delegate to global switchTab function
                switchTab(tabName, event);
            },

            saveCurrentImages() {
                if (images.length === 0) {
                    alert('‚ö†Ô∏è No images to save!');
                    return;
                }
                downloadAllImages();
            },

            confirmMoveToVideo() {
                saveAndSwitchToVideo();
            },

            confirmMoveToVideoSingle() {
                saveAndSwitchToVideo_Single();
            }
        };

        // Load saved folder from localStorage on startup
        window.addEventListener('DOMContentLoaded', () => {
            // Load saved image folder
            loadImageFolder();

            // Auto-load saved projectId/sceneId
            loadSavedProjectIds();

            // Load saved output folder for Veo3 videos
            loadOutputFolder();

            // Add event listener to save output folder when changed
            const outputFolderInput = document.getElementById('outputFolderPath');
            if (outputFolderInput) {
                outputFolderInput.addEventListener('change', saveOutputFolder);
                outputFolderInput.addEventListener('blur', saveOutputFolder);
            }

            // Add event listener to save image folder when changed
            const imageFolderInput = document.getElementById('imageFolderPath');
            if (imageFolderInput) {
                imageFolderInput.addEventListener('change', saveImageFolder);
                imageFolderInput.addEventListener('blur', saveImageFolder);
            }
        });

        // Style presets
        const stylePresets = {
            'realistic': 'professional photography, highly detailed, realistic, 8k resolution',
            'anime': 'anime style, vibrant colors, manga art, japanese animation',
            'oil-painting': 'oil painting style, traditional art, fine art, painterly',
            'watercolor': 'watercolor painting, soft colors, artistic, hand-painted',
            '3d-render': '3d render, octane render, unreal engine, photorealistic cgi',
            'sketch': 'pencil sketch, hand-drawn, black and white, artistic drawing',
            'vintage': 'vintage photograph, retro, old photo, film grain, nostalgic',
            'cyberpunk': 'cyberpunk style, neon lights, futuristic, sci-fi, dark atmosphere',
            'fantasy': 'fantasy art, magical, epic, dreamlike, mystical',
            'minimalist': 'minimalist, simple, clean, modern, minimal design'
        };

        function handleStyleChange() {
            // Style will be applied when generating
        }

        // Chrome & Token functions
        async function launchChrome() {
            try {
                const res = await fetch('/api/launch-chrome', { method: 'POST' });
                const data = await res.json();
                if (data.success) {
                    updateStatus('ready', 'S·∫µn s√†ng');
                    document.getElementById('captureBtn').disabled = false;
                    if (!data.needsLogin) {
                        document.getElementById('generateBtn').disabled = false;
                    }

                    // M·ªü th√™m tab Flow cho video generation
                    setTimeout(() => {
                        fetch('/api/open-flow-tab', { method: 'POST' }).catch(err => {
                            console.log('Flow tab open failed (non-critical):', err);
                        });
                    }, 2000);
                } else {
                    alert('L·ªói: ' + data.error);
                }
            } catch (err) {
                alert('Kh√¥ng th·ªÉ kh·ªüi ƒë·ªông: ' + err.message);
            }
        }

        async function captureToken() {
            try {
                const res = await fetch('/api/capture-token', { method: 'POST' });
                const data = await res.json();
                if (data.success) {
                    updateStatus('ready', 'ƒê√£ k·∫øt n·ªëi');
                    document.getElementById('generateBtn').disabled = false;
                } else {
                    alert('L·ªói: ' + data.error);
                }
            } catch (err) {
                alert('Kh√¥ng th·ªÉ l·∫•y token: ' + err.message);
            }
        }

        async function resetSession() {
            try {
                const res = await fetch('/api/reset', { method: 'POST' });
                const data = await res.json();
                if (data.success) {
                    alert('ƒê√£ reset!');
                }
            } catch (err) {
                alert('L·ªói: ' + err.message);
            }
        }

        function updateStatus(type, text) {
            const badge = document.getElementById('statusBadge');
            badge.className = `status-badge ${type}`;
            badge.textContent = text;
        }

        // Reference Image
        // Named References System
        function switchReferenceTab(type) {
            currentReferenceTab = type;

            // Update tab buttons
            document.getElementById('tabCharacters').className = type === 'character' ? 'btn btn-primary' : 'btn btn-secondary';
            document.getElementById('tabScenes').className = type === 'scene' ? 'btn btn-primary' : 'btn btn-secondary';

            // Show/hide grids
            document.getElementById('referenceGridCharacters').style.display = type === 'character' ? 'grid' : 'none';
            document.getElementById('referenceGridScenes').style.display = type === 'scene' ? 'grid' : 'none';
        }

        function updateReferenceLibrary() {
            const charCount = Object.keys(namedReferences.characters).length;
            const sceneCount = Object.keys(namedReferences.scenes).length;

            document.getElementById('countCharacters').textContent = charCount;
            document.getElementById('countScenes').textContent = sceneCount;

            // Render characters grid
            const charGrid = document.getElementById('referenceGridCharacters');
            charGrid.innerHTML = Object.entries(namedReferences.characters).map(([name, ref]) => {
                const hasHistory = ref.versions && ref.versions.length > 1;
                const versionBadge = hasHistory ?
                    `<div style="position: absolute; top: 4px; right: 4px; background: rgba(26,115,232,0.9); color: white; padding: 2px 6px; border-radius: 8px; font-size: 9px; font-weight: 600;">v${ref.versions.length}</div>` : '';
                return `
                    <div class="reference-item">
                        ${versionBadge}
                        <img src="${ref.imageUrl}" alt="@${name}">
                        <div style="position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.8); color: white; padding: 4px; font-size: 10px; text-align: center;">
                            @${name}
                        </div>
                        <button class="reference-item-remove" onclick="deleteReference('characters', '${name}')" title="X√≥a">√ó</button>
                        <button onclick="viewReference('characters', '${name}')" style="position: absolute; top: 4px; left: 4px; background: rgba(26,115,232,0.9); color: white; border: none; width: 24px; height: 24px; border-radius: 50%; font-size: 14px; cursor: pointer;">üîç</button>
                    </div>
                `;
            }).join('');

            // Render scenes grid
            const sceneGrid = document.getElementById('referenceGridScenes');
            sceneGrid.innerHTML = Object.entries(namedReferences.scenes).map(([name, ref]) => {
                const hasHistory = ref.versions && ref.versions.length > 1;
                const versionBadge = hasHistory ?
                    `<div style="position: absolute; top: 4px; right: 4px; background: rgba(26,115,232,0.9); color: white; padding: 2px 6px; border-radius: 8px; font-size: 9px; font-weight: 600;">v${ref.versions.length}</div>` : '';
                return `
                    <div class="reference-item">
                        ${versionBadge}
                        <img src="${ref.imageUrl}" alt="@${name}">
                        <div style="position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.8); color: white; padding: 4px; font-size: 10px; text-align: center;">
                            @${name}
                        </div>
                        <button class="reference-item-remove" onclick="deleteReference('scenes', '${name}')" title="X√≥a">√ó</button>
                        <button onclick="viewReference('scenes', '${name}')" style="position: absolute; top: 4px; left: 4px; background: rgba(26,115,232,0.9); color: white; border: none; width: 24px; height: 24px; border-radius: 50%; font-size: 14px; cursor: pointer;">üîç</button>
                    </div>
                `;
            }).join('');

            // Show default tab
            if (charCount > 0) {
                switchReferenceTab('character');
            } else if (sceneCount > 0) {
                switchReferenceTab('scene');
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PROJECT MANAGEMENT FUNCTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        function saveCurrentProject() {
            const projectName = document.getElementById('projectName').value.trim();
            if (!projectName) {
                alert('‚ö†Ô∏è Vui l√≤ng nh·∫≠p t√™n d·ª± √°n!');
                return;
            }

            // Get all projects from localStorage
            const projects = JSON.parse(localStorage.getItem('ref_projects') || '{}');

            // Save current references to project
            projects[projectName] = {
                characters: namedReferences.characters,
                scenes: namedReferences.scenes,
                savedAt: new Date().toISOString(),
                refFolderPath: document.getElementById('refFolderPath').value
            };

            // Save to localStorage
            localStorage.setItem('ref_projects', JSON.stringify(projects));

            // Update project selector
            refreshProjectList();

            // Set selector to current project
            document.getElementById('projectSelector').value = projectName;

            console.log(`‚úÖ ƒê√£ l∆∞u d·ª± √°n "${projectName}" v·ªõi ${Object.keys(namedReferences.characters).length} characters v√† ${Object.keys(namedReferences.scenes).length} scenes`);
            alert(`‚úÖ ƒê√£ l∆∞u d·ª± √°n "${projectName}"!`);
        }

        function loadSelectedProject() {
            const projectName = document.getElementById('projectSelector').value;
            if (!projectName) return;

            const projects = JSON.parse(localStorage.getItem('ref_projects') || '{}');
            const project = projects[projectName];

            if (!project) {
                alert('‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y d·ª± √°n!');
                return;
            }

            // Load references
            namedReferences.characters = project.characters || {};
            namedReferences.scenes = project.scenes || {};

            // Update UI
            updateReferenceLibrary();

            // Set project name and folder path
            document.getElementById('projectName').value = projectName;
            if (project.refFolderPath) {
                document.getElementById('refFolderPath').value = project.refFolderPath;
            }

            console.log(`‚úÖ ƒê√£ load d·ª± √°n "${projectName}"`);
            alert(`‚úÖ ƒê√£ load d·ª± √°n "${projectName}" v·ªõi ${Object.keys(namedReferences.characters).length} characters v√† ${Object.keys(namedReferences.scenes).length} scenes!`);
        }

        function refreshProjectList() {
            const projects = JSON.parse(localStorage.getItem('ref_projects') || '{}');
            const selector = document.getElementById('projectSelector');

            // Clear and rebuild options
            selector.innerHTML = '<option value="">-- Ch·ªçn d·ª± √°n --</option>';

            Object.keys(projects).sort().forEach(projectName => {
                const option = document.createElement('option');
                option.value = projectName;
                option.textContent = `üìÅ ${projectName}`;
                selector.appendChild(option);
            });

            console.log(`üîÑ ƒê√£ refresh danh s√°ch d·ª± √°n: ${Object.keys(projects).length} projects`);
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // IMAGE PROJECT MANAGEMENT FUNCTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        function saveImageProject() {
            const projectName = document.getElementById('imageProjectName').value.trim();
            if (!projectName) {
                alert('‚ö†Ô∏è Vui l√≤ng nh·∫≠p t√™n d·ª± √°n ·∫£nh!');
                return;
            }

            if (images.length === 0) {
                alert('‚ö†Ô∏è Kh√¥ng c√≥ ·∫£nh n√†o ƒë·ªÉ l∆∞u!');
                return;
            }

            // Get all image projects from localStorage
            const projects = JSON.parse(localStorage.getItem('image_projects') || '{}');

            // Save current images to project (include all data)
            projects[projectName] = {
                images: images.map(img => ({
                    id: img.id,
                    prompt: img.prompt,
                    batchIndex: img.batchIndex,
                    placeholder: img.placeholder,
                    currentVersion: img.currentVersion,
                    versions: img.versions
                })),
                savedAt: new Date().toISOString(),
                imageCount: images.length
            };

            // Save to localStorage
            localStorage.setItem('image_projects', JSON.stringify(projects));

            // Update project selector
            refreshImageProjectList();

            // Set selector to current project
            document.getElementById('imageProjectSelector').value = projectName;

            console.log(`‚úÖ ƒê√£ l∆∞u d·ª± √°n ·∫£nh "${projectName}" v·ªõi ${images.length} ·∫£nh`);
            alert(`‚úÖ ƒê√£ l∆∞u d·ª± √°n ·∫£nh "${projectName}"!\n\nS·ªë ·∫£nh: ${images.length}`);
        }

        function loadSelectedImageProject() {
            const projectName = document.getElementById('imageProjectSelector').value;
            if (!projectName) return;

            const projects = JSON.parse(localStorage.getItem('image_projects') || '{}');
            const project = projects[projectName];

            if (!project) {
                alert('‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y d·ª± √°n ·∫£nh!');
                return;
            }

            // Clear current images
            images = [];
            const gallery = document.getElementById('gallery');
            gallery.innerHTML = '';

            // Load images from project
            project.images.forEach(imgData => {
                images.push({
                    id: imgData.id,
                    prompt: imgData.prompt,
                    batchIndex: imgData.batchIndex,
                    placeholder: imgData.placeholder,
                    currentVersion: imgData.currentVersion,
                    versions: imgData.versions
                });

                renderImageCard(images[images.length - 1]);
            });

            // Update UI
            updateImageCount();

            // Set project name
            document.getElementById('imageProjectName').value = projectName;

            console.log(`‚úÖ ƒê√£ load d·ª± √°n ·∫£nh "${projectName}" v·ªõi ${images.length} ·∫£nh`);
            alert(`‚úÖ ƒê√£ load d·ª± √°n ·∫£nh "${projectName}"!\n\nS·ªë ·∫£nh: ${images.length}`);
        }

        function refreshImageProjectList() {
            const projects = JSON.parse(localStorage.getItem('image_projects') || '{}');
            const selector = document.getElementById('imageProjectSelector');

            // Clear and rebuild options
            selector.innerHTML = '<option value="">-- Ch·ªçn d·ª± √°n --</option>';

            Object.keys(projects).sort().forEach(projectName => {
                const project = projects[projectName];
                const option = document.createElement('option');
                option.value = projectName;
                option.textContent = `üñºÔ∏è ${projectName} (${project.imageCount} ·∫£nh)`;
                selector.appendChild(option);
            });

            console.log(`üîÑ ƒê√£ refresh danh s√°ch d·ª± √°n ·∫£nh: ${Object.keys(projects).length} projects`);
        }

        // Auto-refresh image project list on load
        window.addEventListener('DOMContentLoaded', () => {
            refreshImageProjectList();
        });

        // Sync project selector from Images tab to Video tab
        function syncReferencesFromImages() {
            const projects = JSON.parse(localStorage.getItem('ref_projects') || '{}');
            const videoSelector = document.getElementById('videoRefProjectSelector');

            if (!videoSelector) return;

            // Clear and rebuild options
            videoSelector.innerHTML = '<option value="">-- Ch·ªçn d·ª± √°n --</option>';

            Object.keys(projects).sort().forEach(projectName => {
                const option = document.createElement('option');
                option.value = projectName;
                option.textContent = `üìÅ ${projectName}`;
                videoSelector.appendChild(option);
            });

            console.log(`üîÑ Synced ${Object.keys(projects).length} projects to Video tab`);
            alert(`‚úÖ ƒê√£ sync ${Object.keys(projects).length} d·ª± √°n t·ª´ tab Images!`);
        }

        // Load selected reference project to Video tab
        function loadRefProjectToVideo() {
            const videoSelector = document.getElementById('videoRefProjectSelector');
            const quickList = document.getElementById('videoRefQuickList');

            if (!videoSelector || !quickList) return;

            const projectName = videoSelector.value;

            if (!projectName) {
                quickList.style.display = 'none';
                quickList.innerHTML = '';
                return;
            }

            const projects = JSON.parse(localStorage.getItem('ref_projects') || '{}');
            const project = projects[projectName];

            if (!project) {
                alert('‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y d·ª± √°n!');
                return;
            }

            // Display quick list of references
            const characters = project.characters || {};
            const scenes = project.scenes || {};

            const totalRefs = Object.keys(characters).length + Object.keys(scenes).length;

            if (totalRefs === 0) {
                quickList.innerHTML = '<div style="font-size: 11px; color: var(--text-secondary); padding: 4px;">Ch∆∞a c√≥ reference n√†o</div>';
                quickList.style.display = 'block';
                return;
            }

            let html = '';

            // Characters
            if (Object.keys(characters).length > 0) {
                html += '<div style="font-size: 11px; font-weight: 600; margin-bottom: 4px; color: var(--text-primary);">üë§ Characters:</div>';
                Object.keys(characters).forEach(name => {
                    html += `<div style="font-size: 10px; padding: 2px 4px; margin-bottom: 2px; color: var(--text-secondary);">@${name}</div>`;
                });
            }

            // Scenes
            if (Object.keys(scenes).length > 0) {
                html += '<div style="font-size: 11px; font-weight: 600; margin: 8px 0 4px 0; color: var(--text-primary);">üé¨ Scenes:</div>';
                Object.keys(scenes).forEach(name => {
                    html += `<div style="font-size: 10px; padding: 2px 4px; margin-bottom: 2px; color: var(--text-secondary);">@${name}</div>`;
                });
            }

            quickList.innerHTML = html;
            quickList.style.display = 'block';

            console.log(`‚úÖ Loaded project "${projectName}": ${totalRefs} references`);
        }

        // Auto-load project list on page load
        window.addEventListener('DOMContentLoaded', () => {
            refreshProjectList();
            syncReferencesFromImages();  // Also sync to Video tab
        });

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        function deleteReference(category, name) {
            if (!confirm(`X√≥a @${name}?`)) return;
            delete namedReferences[category][name];
            updateReferenceLibrary();
        }

        function viewReference(category, name) {
            const ref = namedReferences[category][name];
            if (!ref) return;

            // Migrate to version history if needed
            if (!ref.versions) {
                ref.versions = [{
                    imageUrl: ref.imageUrl,
                    generationId: ref.generationId,
                    seed: ref.seed,
                    timestamp: Date.now()
                }];
                ref.currentVersion = 0;
            }

            const currentVer = ref.versions[ref.currentVersion || 0];
            const hasHistory = ref.versions.length > 1;
            const currentVersionNum = ref.versions.length - (ref.currentVersion || 0);

            // Open modal to view and regenerate
            const modal = document.getElementById('imageModal');
            document.getElementById('modalImage').src = currentVer.imageUrl;

            // Create editable interface for reference
            const promptDiv = document.getElementById('modalPrompt');
            promptDiv.innerHTML = `
                <div style="display: flex; align-items: flex-start; gap: 8px; margin-bottom: 8px;">
                    <div style="flex: 1;">
                        <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 4px;">T√™n:</div>
                        <div id="refNameDisplay" style="font-size: 16px; font-weight: 600; color: var(--primary-color);">@${name}</div>
                    </div>
                    <button class="btn-icon" onclick="editReferenceName()" title="ƒê·ªïi t√™n" style="padding: 4px 8px; font-size: 10px;">‚úèÔ∏è T√™n</button>
                </div>
                <div style="display: flex; align-items: flex-start; gap: 8px;">
                    <div style="flex: 1;">
                        <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 4px;">M√¥ t·∫£:</div>
                        <div id="refPromptDisplay" style="font-size: 14px;">${ref.prompt}</div>
                    </div>
                    <button class="btn-icon" onclick="editReferencePrompt()" title="S·ª≠a m√¥ t·∫£" style="padding: 4px 8px; font-size: 10px;">‚úèÔ∏è M√¥ t·∫£</button>
                </div>
            `;

            document.getElementById('modalSeed').textContent = `Seed: ${currentVer.seed || 'auto'} | ${category === 'characters' ? 'üë§ Nh√¢n V·∫≠t' : 'üèûÔ∏è Khung C·∫£nh'}`;

            // Show version navigation if has history
            const versionNav = document.getElementById('modalVersionNav');
            if (hasHistory) {
                versionNav.style.display = 'block';
                document.getElementById('modalVersionInfo').textContent = `[${currentVersionNum}/${ref.versions.length}]`;
                document.getElementById('modalVerPrev').disabled = (ref.currentVersion || 0) >= ref.versions.length - 1;
                document.getElementById('modalVerNext').disabled = (ref.currentVersion || 0) <= 0;

                // Show "Select this version" button only when viewing an old version
                const selectBtn = document.getElementById('modalSelectVersion');
                if ((ref.currentVersion || 0) > 0) {
                    selectBtn.style.display = 'inline-block';
                } else {
                    selectBtn.style.display = 'none';
                }
            } else {
                versionNav.style.display = 'none';
            }

            document.getElementById('modalPrevBatch').style.display = 'none';
            document.getElementById('modalNextBatch').style.display = 'none';

            // Show reference regen button
            document.getElementById('regenNormalBtn').style.display = 'none';
            document.getElementById('regenRefBtn').style.display = 'inline-block';

            modal.classList.add('active');

            // Store reference info for regen and editing
            window.currentViewingReference = { category, name, ref };
        }

        function navigateReferenceVersion(direction) {
            if (!window.currentViewingReference) return;
            const { category, name, ref } = window.currentViewingReference;

            if (!ref.versions) return;

            const currentVer = ref.currentVersion || 0;

            if (direction === 'prev' && currentVer < ref.versions.length - 1) {
                ref.currentVersion = currentVer + 1;
                namedReferences[category][name] = ref;
                viewReference(category, name);
            } else if (direction === 'next' && currentVer > 0) {
                ref.currentVersion = currentVer - 1;
                namedReferences[category][name] = ref;
                viewReference(category, name);
            }
        }

        async function selectCurrentVersion() {
            if (!window.currentViewingReference) return;
            const { category, name, ref } = window.currentViewingReference;

            if (!ref.versions || ref.versions.length === 0) return;

            const currentVerIndex = ref.currentVersion || 0;
            const selectedVersion = ref.versions[currentVerIndex];

            // Update reference with selected version data
            ref.imageUrl = selectedVersion.imageUrl;
            ref.generationId = selectedVersion.generationId;
            ref.seed = selectedVersion.seed;

            // Save to namedReferences
            namedReferences[category][name] = ref;

            // Auto-download selected version to project folder
            const projectName = document.getElementById('projectName').value.trim();
            const refFolderPath = document.getElementById('refFolderPath').value.trim();

            if (projectName && refFolderPath) {
                try {
                    await autoDownloadReference(name, selectedVersion.imageUrl, false);
                    console.log(`‚úÖ Selected version ${ref.versions.length - currentVerIndex}/${ref.versions.length} as current`);
                } catch (err) {
                    console.error('Failed to download selected version:', err);
                }
            }

            // Update UI
            updateReferenceLibrary();

            // Show success message
            const versionNum = ref.versions.length - currentVerIndex;
            alert(`‚úÖ ƒê√£ ch·ªçn version ${versionNum}/${ref.versions.length} l√†m version ch√≠nh cho @${name}`);

            // Refresh modal to show updated state
            viewReference(category, name);
        }

        function editReferenceName() {
            if (!window.currentViewingReference) return;
            const { category, name, ref } = window.currentViewingReference;

            const nameDiv = document.getElementById('refNameDisplay');
            nameDiv.innerHTML = `
                <input type="text" id="editRefName" value="${name}" style="width: 100%; padding: 6px; border: 1px solid var(--primary-color); border-radius: 4px; background: var(--bg-main); color: var(--text-primary); font-size: 14px;">
                <div style="display: flex; gap: 4px; margin-top: 4px;">
                    <button class="btn-icon" onclick="saveReferenceName()" style="flex: 1; background: var(--primary-color); color: white;">‚úì</button>
                    <button class="btn-icon" onclick="viewReference('${category}', '${name}')" style="flex: 1;">‚úó</button>
                </div>
            `;
            document.getElementById('editRefName').focus();
        }

        function saveReferenceName() {
            if (!window.currentViewingReference) return;
            const { category, name: oldName, ref } = window.currentViewingReference;

            const input = document.getElementById('editRefName');
            if (!input) return;

            const newName = input.value.trim().toLowerCase();
            if (!newName) {
                alert('T√™n kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng!');
                return;
            }

            if (newName !== oldName && namedReferences[category][newName]) {
                alert(`T√™n @${newName} ƒë√£ t·ªìn t·∫°i!`);
                return;
            }

            // Remove old entry
            delete namedReferences[category][oldName];

            // Add with new name
            namedReferences[category][newName] = {
                ...ref,
                name: newName
            };

            updateReferenceLibrary();
            closeModal();
            alert(`‚úÖ ƒê√£ ƒë·ªïi t√™n @${oldName} ‚Üí @${newName}`);
        }

        function editReferencePrompt() {
            if (!window.currentViewingReference) return;
            const { category, name, ref } = window.currentViewingReference;

            const promptDiv = document.getElementById('refPromptDisplay');
            promptDiv.innerHTML = `
                <textarea id="editRefPrompt" style="width: 100%; min-height: 80px; padding: 8px; border: 1px solid var(--primary-color); border-radius: 4px; background: var(--bg-main); color: var(--text-primary); font-size: 13px; resize: vertical;">${ref.prompt}</textarea>
                <div style="display: flex; gap: 4px; margin-top: 4px;">
                    <button class="btn-icon" onclick="saveReferencePrompt()" style="flex: 1; background: var(--primary-color); color: white;">‚úì</button>
                    <button class="btn-icon" onclick="viewReference('${category}', '${name}')" style="flex: 1;">‚úó</button>
                </div>
            `;
            document.getElementById('editRefPrompt').focus();
        }

        function saveReferencePrompt() {
            if (!window.currentViewingReference) return;
            const { category, name, ref } = window.currentViewingReference;

            const textarea = document.getElementById('editRefPrompt');
            if (!textarea) return;

            const newPrompt = textarea.value.trim();
            if (!newPrompt) {
                alert('M√¥ t·∫£ kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng!');
                return;
            }

            // Update prompt
            namedReferences[category][name].prompt = newPrompt;

            updateReferenceLibrary();
            viewReference(category, name); // Refresh view
            alert('‚úÖ ƒê√£ c·∫≠p nh·∫≠t m√¥ t·∫£!');
        }

        async function regenerateReference() {
            if (!window.currentViewingReference) {
                alert('Kh√¥ng c√≥ reference ƒë·ªÉ gen l·∫°i!');
                return;
            }

            const { category, name, ref } = window.currentViewingReference;

            // Ask user for regen strategy
            const choice = confirm(
                `C√°ch t·∫°o l·∫°i @${name}:\n\n` +
                `OK = Gi·ªØ nguy√™n seed (nh√¢n v·∫≠t t∆∞∆°ng t·ª±)\n` +
                `Cancel = Seed m·ªõi (variation kh√°c)\n\n` +
                `Seed hi·ªán t·∫°i: ${ref.seed}`
            );

            const loadingId = `loading-regen-ref-${Date.now()}`;
            addLoadingCard(loadingId, `T·∫°o l·∫°i @${name}`);
            closeModal();

            try {
                const aspectRatio = document.getElementById('aspectRatio').value;

                // Strategy based on user choice
                let result;
                if (choice) {
                    // Keep same seed - should maintain character appearance
                    console.log(`Regen with SAME SEED ${ref.seed} for consistency`);
                    result = await generateSingleWithReference(
                        ref.prompt,
                        aspectRatio,
                        ref.seed,  // USE SAME SEED!
                        {
                            imageUrl: ref.imageUrl,
                            generationId: ref.generationId
                        }
                    );
                } else {
                    // New seed - create variation
                    console.log('Regen with NEW SEED for variation');
                    result = await generateSingleWithReference(
                        ref.prompt,
                        aspectRatio,
                        null,  // New seed
                        {
                            imageUrl: ref.imageUrl,
                            generationId: ref.generationId
                        }
                    );
                }

                removeLoadingCard(loadingId);

                if (result.success) {
                    // Add version history to references
                    if (!ref.versions) {
                        // Migrate old format to version history
                        ref.versions = [{
                            imageUrl: ref.imageUrl,
                            generationId: ref.generationId,
                            seed: ref.seed,
                            timestamp: Date.now() - 1000
                        }];
                        ref.currentVersion = 0;
                    }

                    // Add new version at the beginning
                    ref.versions.unshift({
                        imageUrl: result.imageUrl,
                        generationId: result.generationId,
                        seed: result.seed,
                        timestamp: Date.now()
                    });

                    // Set to newest version
                    ref.currentVersion = 0;

                    // Update reference with new current version
                    const currentVer = ref.versions[0];
                    namedReferences[category][name] = {
                        ...ref,
                        imageUrl: currentVer.imageUrl,
                        generationId: currentVer.generationId,
                        seed: currentVer.seed,
                        name: name
                    };

                    // Auto-download regenerated reference (with backup)
                    await autoDownloadReference(name, result.imageUrl, true);

                    updateReferenceLibrary();
                    alert(`‚úÖ ƒê√£ t·∫°o version m·ªõi cho @${name}!\nT·ªïng: ${ref.versions.length} versions\nSeed: ${result.seed}`);
                } else {
                    alert(`L·ªói: ${result.error}`);
                }
            } catch (err) {
                removeLoadingCard(loadingId);
                console.error('Regenerate reference error:', err);
            }
        }

        function uploadReferenceImage() {
            const name = prompt('T√™n cho reference n√†y:');
            if (!name) return;

            document.getElementById('referenceFileInput').dataset.tempName = name.toLowerCase();
            document.getElementById('referenceFileInput').click();
        }

        async function handleReferenceFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const name = event.target.dataset.tempName || 'uploaded';
            const reader = new FileReader();

            reader.onload = (e) => {
                namedReferences.scenes[name] = {
                    imageUrl: e.target.result,
                    prompt: file.name,
                    seed: 'uploaded',
                    generationId: null,
                    name: name
                };

                updateReferenceLibrary();
            };

            reader.readAsDataURL(file);
            event.target.value = '';
        }

        // Parse @mentions in prompt and resolve to reference images
        function parsePromptWithReferences(prompt) {
            const mentions = prompt.match(/@(\w+)/g);
            if (!mentions) return { prompt, references: [] };

            const references = [];
            let parsedPrompt = prompt;

            mentions.forEach(mention => {
                const name = mention.substring(1).toLowerCase();

                // Check in characters first, then scenes
                let ref = namedReferences.characters[name] || namedReferences.scenes[name];

                if (ref) {
                    references.push(ref);
                    // Replace @name with actual description for API
                    parsedPrompt = parsedPrompt.replace(mention, ref.prompt);
                }
            });

            return { prompt: parsedPrompt, references };
        }

        // Legacy compatibility
        function setReferenceImage(imageUrl, prompt, seed, generationId) {
            // Not used anymore with named system
        }

        function clearReference() {
            // Not used anymore
        }

        // Folder Selection
        async function selectDownloadFolder() {
            try {
                if ('showDirectoryPicker' in window) {
                    downloadFolderHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
                    document.getElementById('folderPath').textContent = downloadFolderHandle.name;

                    // Save folder name to localStorage
                    localStorage.setItem('whisk_folder_name', downloadFolderHandle.name);
                    console.log(`Saved folder: ${downloadFolderHandle.name}`);

                    // Update button states
                    updateImageCount();
                } else {
                    alert('Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ File System Access API');
                }
            } catch (err) {
                if (err.name !== 'AbortError') {
                    console.error('Folder selection error:', err);
                }
            }
        }

        // Generate Reference Image
        async function generateReferenceImage() {
            const name = document.getElementById('referenceName').value.trim().toLowerCase();
            const prompt = document.getElementById('referencePrompt').value.trim();
            const refType = document.getElementById('referenceType').value;

            if (!name) {
                alert('Vui l√≤ng nh·∫≠p t√™n g·ªçi!');
                return;
            }

            if (!prompt) {
                alert('Vui l√≤ng nh·∫≠p m√¥ t·∫£!');
                return;
            }

            // Check if name already exists
            const category = refType === 'character' ? 'characters' : 'scenes';
            if (namedReferences[category][name]) {
                if (!confirm(`"@${name}" ƒë√£ t·ªìn t·∫°i. T·∫°o l·∫°i?`)) return;
            }

            const typeEmoji = refType === 'character' ? 'üë§' : 'üèûÔ∏è';
            const loadingId = `loading-ref-${Date.now()}`;
            addLoadingCard(loadingId, `${typeEmoji} @${name}`);

            try {
                const aspectRatio = document.getElementById('aspectRatio').value;
                const result = await generateSingleWithReference(prompt, aspectRatio, null, null);

                removeLoadingCard(loadingId);

                if (result.success) {
                    // Check if updating existing reference (for backup)
                    const isRegen = namedReferences[category][name] !== undefined;

                    // Save to named references with version history
                    namedReferences[category][name] = {
                        imageUrl: result.imageUrl,
                        prompt: prompt,
                        seed: result.seed,
                        generationId: result.generationId,
                        name: name,
                        versions: [{
                            imageUrl: result.imageUrl,
                            generationId: result.generationId,
                            seed: result.seed,
                            timestamp: Date.now()
                        }],
                        currentVersion: 0
                    };

                    // Auto-download reference to project folder
                    await autoDownloadReference(name, result.imageUrl, isRegen);

                    // Clear inputs
                    document.getElementById('referenceName').value = '';
                    document.getElementById('referencePrompt').value = '';

                    // Update UI
                    updateReferenceLibrary();

                    alert(`‚úÖ ƒê√£ t·∫°o @${name}!`);
                } else {
                    alert(`L·ªói: ${result.error}`);
                }
            } catch (err) {
                removeLoadingCard(loadingId);
                console.error('Reference generation error:', err);
                alert('L·ªói khi t·∫°o reference!');
            }
        }

        // Auto-parse scene prompts
        function parseScenePrompts(text) {
            const lines = text.split('\n').filter(p => p.trim());
            const parsedPrompts = [];

            lines.forEach(line => {
                line = line.trim();

                // Match patterns:
                // - "Scene 1:", "Scene 2:", etc.
                // - "C·∫£nh 1:", "C·∫£nh 2:", etc.
                // - "1.", "2.", etc.
                // - "1;", "2;", etc.
                // - "1:", "2:", etc.
                const scenePatterns = [
                    /^Scene\s+\d+\s*[:;]/i,      // Scene 1: or Scene 1;
                    /^C·∫£nh\s+\d+\s*[:;]/i,       // C·∫£nh 1: or C·∫£nh 1;
                    /^\d+\s*[:;.]/               // 1: or 1; or 1.
                ];

                let matched = false;
                for (const pattern of scenePatterns) {
                    const match = line.match(pattern);
                    if (match) {
                        // Extract text after the separator
                        const separator = match[0];
                        const promptText = line.substring(separator.length).trim();
                        if (promptText) {
                            parsedPrompts.push(promptText);
                            matched = true;
                            console.log(`üìù Parsed scene: "${separator}" ‚Üí "${promptText}"`);
                        }
                        break;
                    }
                }

                // If no pattern matched, use the line as-is
                if (!matched && line) {
                    parsedPrompts.push(line);
                }
            });

            return parsedPrompts;
        }

        // Batch Generation
        async function generateBatch() {
            const promptsText = document.getElementById('promptsInput').value.trim();
            if (!promptsText) {
                alert('Vui l√≤ng nh·∫≠p m√¥ t·∫£!');
                return;
            }

            // Auto-parse scene prompts (Scene 1:, C·∫£nh 2:, 3;, etc.)
            const prompts = parseScenePrompts(promptsText);
            if (prompts.length === 0) {
                alert('Kh√¥ng c√≥ m√¥ t·∫£ h·ª£p l·ªá!');
                return;
            }

            // Get settings
            const aspectRatio = document.getElementById('aspectRatio').value;
            const seedInput = document.getElementById('seedInput').value;
            const baseSeed = seedInput ? parseInt(seedInput) : null;
            const autoDownload = document.getElementById('autoDownload').checked;
            const style = document.getElementById('stylePreset').value;
            const styleText = style ? stylePresets[style] : '';
            const batchRefMode = document.getElementById('batchReferenceMode').value;

            document.getElementById('generateBtn').disabled = true;
            document.getElementById('progressBar').style.display = 'block';

            // ========== OPTIMIZATION: Detect if we can generate in parallel ==========
            // Check if any prompt has "(continue)"
            const hasContinue = prompts.some(p => {
                const lower = p.toLowerCase();
                return lower.startsWith('(continue)') || lower.includes('(continue)');
            });

            // Check if reference mode is enabled
            const hasReferenceMode = batchRefMode !== 'none';

            // Can generate in parallel if: no reference mode AND no continue
            const canGenerateParallel = !hasReferenceMode && !hasContinue;

            if (canGenerateParallel) {
                console.log('üöÄ Parallel generation enabled: generating 3 images at a time');
                await generateBatchParallel(prompts, aspectRatio, baseSeed, styleText, autoDownload);
            } else {
                console.log('üîó Sequential generation: reference mode or (continue) detected');
                await generateBatchSequential(prompts, aspectRatio, baseSeed, styleText, autoDownload, batchRefMode);
            }

            document.getElementById('progressBar').style.display = 'none';
            document.getElementById('generateBtn').disabled = false;
            updateImageCount();
        }

        // Generate images in parallel (batch of 3)
        async function generateBatchParallel(prompts, aspectRatio, baseSeed, styleText, autoDownload) {
            const batchQuantityElement = document.getElementById('imageBatchQuantity');
            const BATCH_SIZE = batchQuantityElement ? parseInt(batchQuantityElement.value) : 3; // Use dropdown value or default to 3

            for (let batchStart = 0; batchStart < prompts.length; batchStart += BATCH_SIZE) {
                const batchEnd = Math.min(batchStart + BATCH_SIZE, prompts.length);
                const batchPrompts = prompts.slice(batchStart, batchEnd);

                console.log(`üì¶ Generating batch ${Math.floor(batchStart / BATCH_SIZE) + 1}: images ${batchStart + 1}-${batchEnd}`);

                // Create promises for parallel generation
                const generatePromises = batchPrompts.map(async (originalPrompt, localIdx) => {
                    const i = batchStart + localIdx;
                    let prompt = originalPrompt.trim();

                    // Parse @mentions and resolve references
                    const parsed = parsePromptWithReferences(prompt);
                    if (parsed.references.length > 0) {
                        console.log(`Resolved ${parsed.references.length} references in prompt ${i + 1}`);
                        prompt = parsed.prompt;
                    }

                    // Add style to prompt
                    if (styleText) {
                        prompt = `${prompt}, ${styleText}`;
                    }

                    const loadingId = `loading-${Date.now()}-${i}`;
                    addLoadingCard(loadingId, originalPrompt);

                    try {
                        const seed = baseSeed ? baseSeed + i : null;

                        // Use first @mention reference if found (only for first image)
                        const currentReference = (i === 0 && parsed.references.length > 0) ? parsed.references[0] : null;

                        // Generate with retry
                        const result = await generateSingleWithRetry(prompt, aspectRatio, seed, currentReference);

                        removeLoadingCard(loadingId);

                        const batchIndex = maxBatchIndex + 1 + i;

                        if (result.success) {
                            const imageId = addImageToGallery(result.imageUrl, originalPrompt, result.seed, result.generationId, batchIndex);
                            maxBatchIndex = Math.max(maxBatchIndex, batchIndex);

                            if (autoDownload && downloadFolderHandle) {
                                await autoDownloadImage(result.imageUrl, originalPrompt, result.seed);
                            }

                            return { success: true, index: i };
                        } else {
                            console.error(`‚ùå Failed to generate image ${i + 1} after retries: ${result.error}`);
                            const imageId = addPlaceholderImage(originalPrompt, aspectRatio, seed, batchIndex, result.error);
                            maxBatchIndex = Math.max(maxBatchIndex, batchIndex);
                            return { success: false, index: i, error: result.error };
                        }
                    } catch (err) {
                        removeLoadingCard(loadingId);
                        console.error(`‚ùå Generation error for image ${i + 1}:`, err);
                        const batchIndex = maxBatchIndex + 1 + i;
                        addPlaceholderImage(originalPrompt, aspectRatio, baseSeed ? baseSeed + i : null, batchIndex, err.message || 'Unknown error');
                        maxBatchIndex = Math.max(maxBatchIndex, batchIndex);
                        return { success: false, index: i, error: err.message };
                    }
                });

                // Wait for all images in this batch to complete
                const results = await Promise.all(generatePromises);

                // Update progress
                const progress = (batchEnd / prompts.length) * 100;
                document.getElementById('progressFill').style.width = progress + '%';

                console.log(`‚úÖ Batch ${Math.floor(batchStart / BATCH_SIZE) + 1} complete: ${results.filter(r => r.success).length}/${results.length} successful`);

                // Small delay between batches
                if (batchEnd < prompts.length) {
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
            }
        }

        // Generate images sequentially (original logic for reference/continue mode)
        async function generateBatchSequential(prompts, aspectRatio, baseSeed, styleText, autoDownload, batchRefMode) {
            // Store first/previous image for batch reference
            let batchReferenceImage = null;
            let firstImageResult = null;

            for (let i = 0; i < prompts.length; i++) {
                let prompt = prompts[i].trim();

                // Parse @mentions and resolve references
                const parsed = parsePromptWithReferences(prompt);
                if (parsed.references.length > 0) {
                    console.log(`Resolved ${parsed.references.length} references in prompt`);
                    prompt = parsed.prompt; // Use parsed prompt with descriptions
                }

                // Add style to prompt
                if (styleText) {
                    prompt = `${prompt}, ${styleText}`;
                }

                const progress = ((i + 1) / prompts.length) * 100;
                document.getElementById('progressFill').style.width = progress + '%';

                const loadingId = `loading-${Date.now()}`;
                addLoadingCard(loadingId, prompts[i]);

                try {
                    const seed = baseSeed ? baseSeed + i : null;

                    // Determine reference for this image based on mode
                    let currentReference = null;

                    if (i === 0) {
                        // First image: use first @mention reference if found, otherwise batch mode
                        currentReference = parsed.references.length > 0 ? parsed.references[0] : null;
                    } else {
                        // Subsequent images: apply batch reference mode
                        if (batchRefMode === 'auto') {
                            // Auto mode: detect (Continue) in prompt
                            const originalPrompt = prompts[i].trim();
                            const hasContinue = originalPrompt.toLowerCase().startsWith('(continue)') ||
                                              originalPrompt.toLowerCase().includes('(continue)');

                            if (hasContinue && batchReferenceImage) {
                                // Use previous image as reference
                                currentReference = batchReferenceImage;
                                console.log(`üîó Auto-detected (Continue) in prompt ${i + 1} ‚Üí using previous image as reference`);
                            }
                            // else: no (Continue) -> no automatic reference
                        } else if (batchRefMode === 'first' && firstImageResult) {
                            // Use first image as reference for all
                            currentReference = {
                                imageUrl: firstImageResult.imageUrl,
                                generationId: firstImageResult.generationId
                            };
                        } else if (batchRefMode === 'chain' && batchReferenceImage) {
                            // Use previous image as reference (chain)
                            currentReference = batchReferenceImage;
                        }
                        // else: batchRefMode === 'none' -> no reference
                    }

                    // Use retry logic (3 attempts)
                    const result = await generateSingleWithRetry(prompt, aspectRatio, seed, currentReference);

                    removeLoadingCard(loadingId);

                    const batchIndex = maxBatchIndex + 1 + i;

                    if (result.success) {
                        // Add successful image with batch metadata
                        const imageId = addImageToGallery(result.imageUrl, prompts[i], result.seed, result.generationId, batchIndex);

                        // Update max batch index
                        maxBatchIndex = Math.max(maxBatchIndex, batchIndex);

                        // Track reference chain for this batch
                        if (currentReference) {
                            // Find the referenced image
                            const refImage = images.find(img =>
                                img.versions[img.currentVersion].imageUrl === currentReference.imageUrl
                            );
                            if (refImage) {
                                batchReferenceChain[imageId] = {
                                    referenceId: refImage.id,
                                    generationId: currentReference.generationId
                                };
                            }
                        }

                        // Store for batch reference
                        if (i === 0) {
                            firstImageResult = result;
                        }
                        batchReferenceImage = {
                            imageUrl: result.imageUrl,
                            generationId: result.generationId
                        };

                        if (autoDownload && downloadFolderHandle) {
                            await autoDownloadImage(result.imageUrl, prompts[i], result.seed);
                        }
                    } else {
                        // All retries failed - add placeholder image
                        console.error(`‚ùå Failed to generate image ${i + 1} after 3 retries: ${result.error}`);

                        // Add placeholder with batch metadata
                        const imageId = addPlaceholderImage(prompts[i], aspectRatio, seed, batchIndex, result.error);

                        // Update max batch index
                        maxBatchIndex = Math.max(maxBatchIndex, batchIndex);

                        // Don't update batch reference - skip this failed image
                    }
                } catch (err) {
                    removeLoadingCard(loadingId);
                    console.error(`‚ùå Generation error for image ${i + 1}:`, err);

                    // Add placeholder for unexpected errors too
                    const batchIndex = maxBatchIndex + 1 + i;
                    addPlaceholderImage(prompts[i], aspectRatio, seed, batchIndex, err.message || 'Unknown error');
                    maxBatchIndex = Math.max(maxBatchIndex, batchIndex);
                }

                if (i < prompts.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
            }
        }

        // Generate single image with optional reference override and retry
        async function generateSingleWithRetry(prompt, aspectRatio, seed, refImage, maxRetries = 3) {
            let lastError = null;

            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    console.log(`üîÑ Attempt ${attempt}/${maxRetries} for prompt: "${prompt.substring(0, 50)}..."`);

                    const result = await generateSingleWithReference(prompt, aspectRatio, seed, refImage);

                    if (result.success) {
                        if (attempt > 1) {
                            console.log(`‚úÖ Success on retry ${attempt}/${maxRetries}`);
                        }
                        return result;
                    } else {
                        lastError = result.error;
                        console.warn(`‚ö†Ô∏è Attempt ${attempt} failed: ${result.error}`);

                        // If not last attempt, wait before retry
                        if (attempt < maxRetries) {
                            const delay = attempt * 1000; // Increasing delay: 1s, 2s, 3s
                            console.log(`‚è≥ Waiting ${delay}ms before retry...`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                        }
                    }
                } catch (err) {
                    lastError = err.message || 'Unknown error';
                    console.error(`‚ùå Attempt ${attempt} error:`, err);

                    // If not last attempt, wait before retry
                    if (attempt < maxRetries) {
                        const delay = attempt * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
            }

            // All retries failed
            console.error(`‚ùå All ${maxRetries} attempts failed. Last error: ${lastError}`);
            return {
                success: false,
                error: lastError || 'Failed after 3 retries',
                placeholder: true // Mark as placeholder
            };
        }

        // Generate single image with optional reference override
        async function generateSingleWithReference(prompt, aspectRatio, seed, refImage) {
            const payload = { prompt, aspectRatio };
            if (seed) payload.seed = seed;

            // Use provided reference (no default anymore with named system)
            const useReference = refImage;

            if (useReference) {
                const editPayload = {
                    prompt: prompt,
                    referenceImage: useReference.imageUrl,
                    aspectRatio: aspectRatio
                };

                // Pass generationId if available for better reference accuracy
                if (useReference.generationId) {
                    editPayload.generationId = useReference.generationId;
                    console.log(`Using generationId for reference: ${useReference.generationId.substring(0, 20)}...`);
                }

                // Pass seed if provided for reproducible edits
                if (seed) {
                    editPayload.seed = seed;
                }

                const res = await fetch('/api/edit', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(editPayload)
                });
                return await res.json();
            } else {
                const res = await fetch('/api/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                return await res.json();
            }
        }

        async function generateSingle(prompt, aspectRatio, seed) {
            const payload = { prompt, aspectRatio };
            if (seed) payload.seed = seed;

            // If we have reference images, use edit endpoint instead (use first one)
            if (referenceImages.length > 0) {
                const primaryRef = referenceImages[0];
                const res = await fetch('/api/edit', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: prompt,
                        referenceImage: primaryRef.imageUrl,
                        aspectRatio: aspectRatio
                    })
                });
                return await res.json();
            } else {
                const res = await fetch('/api/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                return await res.json();
            }
        }

        function showCardLoading(imageId) {
            const card = document.getElementById(`card-${imageId}`);
            if (!card) return;

            // Add loading overlay to the card
            const overlay = document.createElement('div');
            overlay.id = `loading-overlay-${imageId}`;
            overlay.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                z-index: 10;
                border-radius: 12px;
            `;
            overlay.innerHTML = `
                <div class="spinner"></div>
                <div style="color: white; margin-top: 12px; font-size: 11px;">ƒêang t·∫°o...</div>
            `;
            card.style.position = 'relative';
            card.appendChild(overlay);
        }

        function hideCardLoading(imageId) {
            const overlay = document.getElementById(`loading-overlay-${imageId}`);
            if (overlay) overlay.remove();
        }

        async function regenerateImageInPlace(imageId) {
            const image = images.find(img => img.id === imageId);
            if (!image) return;

            showCardLoading(imageId);

            try {
                const aspectRatio = document.getElementById('aspectRatio').value;
                const currentVer = image.versions[image.currentVersion];

                // Determine reference: check if this image has a reference in batch chain
                let referenceToUse = null;
                const chainInfo = batchReferenceChain[imageId];

                if (chainInfo) {
                    // This image was part of a batch and has a reference
                    const refImage = images.find(img => img.id === chainInfo.referenceId);
                    if (refImage) {
                        const refVer = refImage.versions[refImage.currentVersion];
                        referenceToUse = {
                            imageUrl: refVer.imageUrl,
                            generationId: refVer.generationId
                        };
                        console.log(`Regenerating with reference to image #${refImage.batchIndex + 1}`);
                    }
                }

                const result = await generateSingleWithReference(
                    image.prompt,
                    aspectRatio,
                    null, // Let API generate new seed
                    referenceToUse
                );

                hideCardLoading(imageId);

                if (result.success) {
                    // Add new version to this image (prepend to versions array)
                    image.versions.unshift({
                        imageUrl: result.imageUrl,
                        generationId: result.generationId,
                        seed: result.seed,
                        timestamp: Date.now()
                    });

                    // Set current version to newest (index 0)
                    image.currentVersion = 0;

                    // Re-render the card
                    renderImageCard(image);

                    console.log(`Added new version. Total versions: ${image.versions.length}`);
                } else {
                    alert(`L·ªói: ${result.error}`);
                }
            } catch (err) {
                hideCardLoading(imageId);
                console.error('Regeneration error:', err);
            }
        }

        function navigateVersion(imageId, direction) {
            const image = images.find(img => img.id === imageId);
            if (!image) return;

            if (direction === 'prev' && image.currentVersion < image.versions.length - 1) {
                // Go to older version
                image.currentVersion++;
                renderImageCard(image);
                console.log(`Navigate to older version: ${image.versions.length - image.currentVersion}/${image.versions.length}`);
            } else if (direction === 'next' && image.currentVersion > 0) {
                // Go to newer version
                image.currentVersion--;
                renderImageCard(image);
                console.log(`Navigate to newer version: ${image.versions.length - image.currentVersion}/${image.versions.length}`);
            }
        }

        // Legacy function for backward compatibility
        function undoVersion(imageId) {
            navigateVersion(imageId, 'prev');
        }

        function editPrompt(imageId) {
            const image = images.find(img => img.id === imageId);
            if (!image) return;

            const promptDiv = document.querySelector(`#card-${imageId} .image-prompt`);
            if (!promptDiv) return;

            // Create editable textarea
            const currentPrompt = image.prompt;
            promptDiv.innerHTML = `
                <textarea id="edit-prompt-${imageId}" style="width: 100%; min-height: 50px; padding: 4px; font-size: 11px; border: 1px solid var(--primary-color); border-radius: 4px; background: var(--bg-main); color: var(--text-primary); resize: vertical;">${currentPrompt}</textarea>
                <div style="display: flex; gap: 4px; margin-top: 4px;">
                    <button class="btn-icon" onclick="savePrompt(${imageId})" style="flex: 1; background: var(--primary-color); color: white;">‚úì Save</button>
                    <button class="btn-icon" onclick="renderImageCard(images.find(img => img.id === ${imageId}))" style="flex: 1;">‚úó Cancel</button>
                </div>
            `;
            document.getElementById(`edit-prompt-${imageId}`).focus();
        }

        function savePrompt(imageId) {
            const image = images.find(img => img.id === imageId);
            if (!image) return;

            const textarea = document.getElementById(`edit-prompt-${imageId}`);
            if (!textarea) return;

            const newPrompt = textarea.value.trim();
            if (!newPrompt) {
                alert('Prompt kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng!');
                return;
            }

            // Update prompt and re-render
            image.prompt = newPrompt;
            renderImageCard(image);
        }

        // Legacy regenerateImage for backward compatibility
        async function regenerateImage(prompt, aspectRatio, seed) {
            const loadingId = `loading-regen-${Date.now()}`;
            addLoadingCard(loadingId, prompt);

            try {
                const result = await generateSingleWithReference(prompt, aspectRatio, seed, null);
                removeLoadingCard(loadingId);

                if (result.success) {
                    addImageToGallery(result.imageUrl, prompt, result.seed, result.generationId);
                } else {
                    alert(`L·ªói: ${result.error}`);
                }
            } catch (err) {
                removeLoadingCard(loadingId);
                console.error('Regeneration error:', err);
            }

            updateImageCount();
        }

        function addLoadingCard(id, prompt) {
            const gallery = document.getElementById('gallery');
            const emptyState = gallery.querySelector('.empty-state');
            if (emptyState) emptyState.remove();

            const card = document.createElement('div');
            card.className = 'loading-card';
            card.id = id;
            card.innerHTML = `
                <div class="spinner"></div>
                <div class="loading-text">${prompt.substring(0, 50)}${prompt.length > 50 ? '...' : ''}</div>
            `;
            gallery.insertBefore(card, gallery.firstChild);
        }

        function removeLoadingCard(id) {
            const card = document.getElementById(id);
            if (card) card.remove();
        }

        function addImageToGallery(imageUrl, prompt, seed, generationId, batchIndex = null) {
            const imageId = Date.now();

            // Create image object with version history
            const image = {
                id: imageId,
                prompt: prompt,
                batchIndex: batchIndex,
                currentVersion: 0,
                versions: [
                    {
                        imageUrl: imageUrl,
                        generationId: generationId,
                        seed: seed,
                        timestamp: Date.now()
                    }
                ]
            };

            images.push(image);  // Changed from unshift to push to maintain chronological order (12345)
            renderImageCard(image);
            return imageId;
        }

        function addPlaceholderImage(prompt, aspectRatio, seed, batchIndex, error) {
            const imageId = Date.now();

            // Create placeholder image object
            const image = {
                id: imageId,
                prompt: prompt,
                batchIndex: batchIndex,
                currentVersion: 0,
                isPlaceholder: true,
                aspectRatio: aspectRatio,
                seed: seed,
                error: error,
                versions: [
                    {
                        imageUrl: null,  // No image URL for placeholder
                        generationId: null,
                        seed: seed,
                        timestamp: Date.now(),
                        isPlaceholder: true,
                        error: error
                    }
                ]
            };

            images.push(image);
            renderImageCard(image);
            console.log(`üì¶ Added placeholder for batch #${batchIndex + 1}: "${prompt}"`);
            return imageId;
        }

        function renderImageCard(image) {
            const gallery = document.getElementById('gallery');
            const emptyState = gallery.querySelector('.empty-state');
            if (emptyState) emptyState.remove();

            // Remove existing card if any
            const existingCard = document.getElementById(`card-${image.id}`);
            if (existingCard) existingCard.remove();

            const currentVer = image.versions[image.currentVersion];
            const hasHistory = image.versions.length > 1;
            const canGoPrev = image.currentVersion < image.versions.length - 1;
            const canGoNext = image.currentVersion > 0;
            const currentVersionNum = image.versions.length - image.currentVersion;

            const card = document.createElement('div');
            card.className = 'image-card';
            card.id = `card-${image.id}`;
            card.draggable = true;
            card.dataset.imageId = image.id;

            // Drag & Drop handlers
            card.addEventListener('dragstart', handleDragStart);
            card.addEventListener('dragover', handleDragOver);
            card.addEventListener('drop', handleDrop);
            card.addEventListener('dragend', handleDragEnd);

            // Check if placeholder
            if (image.isPlaceholder || currentVer.isPlaceholder) {
                // Render placeholder card
                card.innerHTML = `
                    <div style="position: relative; aspect-ratio: 16/9; background: linear-gradient(135deg, #f5f5f5 0%, #e0e0e0 100%); border: 2px dashed var(--border-color); border-radius: 8px; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px;">
                        <div style="font-size: 48px; opacity: 0.3; margin-bottom: 8px;">‚ùå</div>
                        <div style="font-size: 12px; color: var(--danger-color); font-weight: 600; margin-bottom: 4px;">Failed after 3 retries</div>
                        <div style="font-size: 10px; color: var(--text-secondary); text-align: center; max-width: 200px; margin-bottom: 12px;">${image.error || 'Unknown error'}</div>
                        <button class="btn btn-primary" onclick="retryPlaceholder(${image.id})" style="padding: 6px 16px; font-size: 11px;">
                            üîÑ Retry Now
                        </button>
                    </div>
                    <div class="image-info">
                        <div style="display: flex; align-items: flex-start; gap: 4px;">
                            <div class="image-prompt" style="flex: 1;">${image.prompt}</div>
                        </div>
                        <div class="image-seed" style="color: var(--danger-color);">‚ö†Ô∏è Placeholder${image.batchIndex !== null ? ` | Batch #${image.batchIndex + 1}` : ''}</div>
                        <div class="image-actions">
                            <button class="btn-icon" onclick="retryPlaceholder(${image.id})" title="Th·ª≠ t·∫°o l·∫°i">
                                üîÑ Retry
                            </button>
                            <button class="btn-icon" onclick="deleteImage(${image.id})" title="X√≥a">
                                üóëÔ∏è
                            </button>
                        </div>
                    </div>
                `;
            } else {
                // Normal image card
                const versionBadge = hasHistory ?
                    `<div style="position: absolute; top: 8px; right: 8px; background: rgba(26,115,232,0.9); color: white; padding: 4px 8px; border-radius: 12px; font-size: 11px; font-weight: 600;">
                        v${image.versions.length - image.currentVersion}/${image.versions.length}
                    </div>` : '';

                card.innerHTML = `
                    ${versionBadge}
                    <img src="${currentVer.imageUrl}" alt="${image.prompt}" onclick="openModal({id: ${image.id}})">
                    <div class="image-info">
                        <div style="display: flex; align-items: flex-start; gap: 4px;">
                            <div class="image-prompt" style="flex: 1;">${image.prompt}</div>
                            <button class="btn-icon" onclick="editPrompt(${image.id})" title="Ch·ªânh s·ª≠a prompt" style="padding: 2px 6px; font-size: 10px;">‚úèÔ∏è</button>
                        </div>
                        <div class="image-seed">Seed: ${currentVer.seed || 'auto'}${image.batchIndex !== null ? ` | Batch #${image.batchIndex + 1}` : ''}</div>
                        <div class="image-actions">
                            <button class="btn-icon" onclick="setReferenceImage('${currentVer.imageUrl}', '${image.prompt.replace(/'/g, "\\'")}', ${currentVer.seed}, '${currentVer.generationId || ''}')" title="D√πng l√†m tham chi·∫øu">
                                üñºÔ∏è Ref
                            </button>
                            <button class="btn-icon" onclick="regenerateImageInPlace(${image.id})" title="T·∫°o l·∫°i (thay th·∫ø)">
                                üîÑ Regen
                            </button>
                            ${hasHistory ? `<div style="display: flex; gap: 2px; align-items: center;">
                                <button class="btn-icon" onclick="navigateVersion(${image.id}, 'prev')" ${!canGoPrev ? 'disabled style="opacity: 0.3; cursor: not-allowed;"' : ''} title="Version c≈© h∆°n">
                                    ‚Üê
                                </button>
                                <span style="font-size: 9px; color: var(--text-secondary); padding: 0 4px; white-space: nowrap;">[${currentVersionNum}/${image.versions.length}]</span>
                                <button class="btn-icon" onclick="navigateVersion(${image.id}, 'next')" ${!canGoNext ? 'disabled style="opacity: 0.3; cursor: not-allowed;"' : ''} title="Version m·ªõi h∆°n">
                                    ‚Üí
                                </button>
                            </div>` : ''}
                            <button class="btn-icon" onclick="downloadImage('${currentVer.imageUrl}', '${image.prompt.replace(/'/g, "\\'")}', ${currentVer.seed})" title="T·∫£i v·ªÅ">
                                üì•
                            </button>
                            <button class="btn-icon" onclick="deleteImage(${image.id})" title="X√≥a">
                                üóëÔ∏è
                            </button>
                            ${image.batchIndex !== null ? `<button class="btn-icon" onclick="insertImageAfter(${image.id})" title="Ch√®n ·∫£nh sau batch n√†y" style="background: var(--primary-color); color: white;">
                                +
                            </button>` : ''}
                        </div>
                    </div>
                `;
            }

            // Insert at correct position based on batchIndex
            if (image.batchIndex !== null) {
                // Find correct position in gallery
                const cards = Array.from(gallery.querySelectorAll('.image-card'));
                let inserted = false;

                for (let i = 0; i < cards.length; i++) {
                    const cardId = parseInt(cards[i].id.replace('card-', ''));
                    const existingImg = images.find(img => img.id === cardId);

                    if (existingImg && existingImg.batchIndex !== null && existingImg.batchIndex > image.batchIndex) {
                        gallery.insertBefore(card, cards[i]);
                        inserted = true;
                        break;
                    }
                }

                if (!inserted) {
                    gallery.appendChild(card);
                }
            } else {
                gallery.appendChild(card);  // Changed from insertBefore to appendChild to maintain chronological order
            }
        }

        async function retryPlaceholder(imageId) {
            const image = images.find(img => img.id === imageId);
            if (!image || !image.isPlaceholder) return;

            console.log(`üîÑ Retrying placeholder: "${image.prompt}"`);

            // Show loading on card
            showCardLoading(imageId);

            try {
                // Get settings
                const aspectRatio = image.aspectRatio || document.getElementById('aspectRatio').value;
                const seed = image.seed;

                // Determine reference (if this was part of a batch)
                let refImage = null;
                if (image.batchIndex !== null && image.batchIndex > 0) {
                    // Try to find previous image in batch
                    const prevImage = images.find(img =>
                        img.batchIndex === image.batchIndex - 1 && !img.isPlaceholder
                    );
                    if (prevImage) {
                        const prevVer = prevImage.versions[prevImage.currentVersion];
                        refImage = {
                            imageUrl: prevVer.imageUrl,
                            generationId: prevVer.generationId
                        };
                    }
                }

                // Retry with 3 attempts
                const result = await generateSingleWithRetry(image.prompt, aspectRatio, seed, refImage);

                hideCardLoading(imageId);

                if (result.success) {
                    // Replace placeholder with real image
                    image.isPlaceholder = false;
                    image.error = null;
                    image.versions = [
                        {
                            imageUrl: result.imageUrl,
                            generationId: result.generationId,
                            seed: result.seed,
                            timestamp: Date.now(),
                            isPlaceholder: false
                        }
                    ];
                    image.currentVersion = 0;

                    renderImageCard(image);
                    console.log(`‚úÖ Placeholder retry successful!`);
                } else {
                    // Still failed
                    alert(`‚ùå Retry failed: ${result.error}\n\nB·∫°n c√≥ th·ªÉ th·ª≠ l·∫°i ho·∫∑c x√≥a placeholder n√†y.`);
                }
            } catch (err) {
                hideCardLoading(imageId);
                console.error('Retry error:', err);
                alert(`‚ùå L·ªói khi retry: ${err.message}`);
            }
        }

        function deleteImage(id) {
            if (!confirm('X√≥a ·∫£nh n√†y?')) return;

            const index = images.findIndex(img => img.id === id);
            if (index > -1) {
                images.splice(index, 1);
                renderGallery();
                updateImageCount();
            }
        }

        function insertImageAfter(imageId) {
            const image = images.find(img => img.id === imageId);
            if (!image || image.batchIndex === null) return;

            // Open modal
            pendingInsertAfterImageId = imageId;
            document.getElementById('insertPrompt').value = '';
            document.getElementById('insertModal').classList.add('active');
            document.getElementById('insertPrompt').focus();
        }

        function closeInsertModal(event) {
            if (!event || event.target.id === 'insertModal') {
                document.getElementById('insertModal').classList.remove('active');
                pendingInsertAfterImageId = null;
            }
        }

        async function confirmInsert() {
            if (!pendingInsertAfterImageId) return;

            let prompt = document.getElementById('insertPrompt').value.trim();
            if (!prompt) {
                alert('Vui l√≤ng nh·∫≠p prompt!');
                return;
            }

            const imageId = pendingInsertAfterImageId;
            const image = images.find(img => img.id === imageId);
            if (!image) return;

            closeInsertModal();

            // Parse @mentions
            const parsed = parsePromptWithReferences(prompt);
            const originalPrompt = prompt; // Keep for display
            if (parsed.references.length > 0) {
                prompt = parsed.prompt; // Use parsed prompt
                console.log(`Insert: Resolved ${parsed.references.length} references`);
            }

            const targetBatchIndex = image.batchIndex + 0.5; // Insert between current and next

            const loadingId = `loading-insert-${Date.now()}`;
            addLoadingCard(loadingId, originalPrompt);

            try {
                const aspectRatio = document.getElementById('aspectRatio').value;

                // Determine reference based on batch mode
                const batchRefMode = document.getElementById('batchReferenceMode').value;
                let currentReference = null;

                // Use @mention reference first, then batch mode
                if (parsed.references.length > 0) {
                    currentReference = parsed.references[0];
                } else if (batchRefMode === 'chain') {
                    // Use current image as reference
                    const currentVer = image.versions[image.currentVersion];
                    currentReference = {
                        imageUrl: currentVer.imageUrl,
                        generationId: currentVer.generationId
                    };
                }

                const result = await generateSingleWithReference(prompt, aspectRatio, null, currentReference);

                removeLoadingCard(loadingId);

                if (result.success) {
                    // Shift all batch indices after this
                    images.forEach(img => {
                        if (img.batchIndex !== null && img.batchIndex > image.batchIndex) {
                            img.batchIndex++;
                        }
                    });

                    // Add new image (use originalPrompt to keep @mentions!)
                    const newImageId = addImageToGallery(
                        result.imageUrl,
                        originalPrompt,
                        result.seed,
                        result.generationId,
                        image.batchIndex + 1
                    );

                    // Track reference if used
                    if (currentReference) {
                        batchReferenceChain[newImageId] = {
                            referenceId: imageId,
                            generationId: currentReference.generationId
                        };
                    }

                    // Update maxBatchIndex
                    maxBatchIndex = Math.max(maxBatchIndex, image.batchIndex + 1);

                    renderGallery();
                } else {
                    alert(`L·ªói: ${result.error}`);
                }
            } catch (err) {
                removeLoadingCard(loadingId);
                console.error('Insert error:', err);
                alert('L·ªói khi ch√®n ·∫£nh!');
            }
        }

        function renderGallery() {
            const gallery = document.getElementById('gallery');
            gallery.innerHTML = '';

            if (images.length === 0) {
                gallery.innerHTML = `
                    <div class="empty-state">
                        <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
                        </svg>
                        <h3>Ch∆∞a c√≥ ·∫£nh n√†o</h3>
                        <p>Nh·∫≠p m√¥ t·∫£ ·ªü sidebar v√† nh·∫•n "T·∫°o ·∫¢nh" ƒë·ªÉ b·∫Øt ƒë·∫ßu</p>
                    </div>
                `;
                updateVideoButton();
                return;
            }

            images.forEach(img => renderImageCard(img));
            updateVideoButton();
        }

        // Drag & Drop handlers
        let draggedImageId = null;

        function handleDragStart(e) {
            draggedImageId = parseInt(e.currentTarget.dataset.imageId);
            e.currentTarget.style.opacity = '0.5';
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            e.currentTarget.style.borderColor = 'var(--primary-color)';
            return false;
        }

        function handleDrop(e) {
            e.stopPropagation();
            e.preventDefault();

            const targetImageId = parseInt(e.currentTarget.dataset.imageId);
            if (draggedImageId === targetImageId) return;

            const draggedImage = images.find(img => img.id === draggedImageId);
            const targetImage = images.find(img => img.id === targetImageId);

            if (!draggedImage || !targetImage) return;

            // INSERT mode (not swap)
            if (draggedImage.batchIndex !== null && targetImage.batchIndex !== null) {
                const draggedIdx = draggedImage.batchIndex;
                const targetIdx = targetImage.batchIndex;

                if (draggedIdx < targetIdx) {
                    // Moving down: shift images between dragged+1 and target down by 1
                    images.forEach(img => {
                        if (img.batchIndex !== null && img.batchIndex > draggedIdx && img.batchIndex <= targetIdx && img.id !== draggedImageId) {
                            img.batchIndex--;
                        }
                    });
                } else {
                    // Moving up: shift images between target and dragged-1 up by 1
                    images.forEach(img => {
                        if (img.batchIndex !== null && img.batchIndex >= targetIdx && img.batchIndex < draggedIdx && img.id !== draggedImageId) {
                            img.batchIndex++;
                        }
                    });
                }

                // Set dragged to target position
                draggedImage.batchIndex = targetIdx;

                renderGallery();
                updateImageCount();
            } else {
                // For non-batch images, insert into array
                const draggedIdx = images.findIndex(img => img.id === draggedImageId);
                const targetIdx = images.findIndex(img => img.id === targetImageId);

                if (draggedIdx > -1 && targetIdx > -1) {
                    const [removed] = images.splice(draggedIdx, 1);
                    images.splice(targetIdx, 0, removed);
                    renderGallery();
                }
            }

            e.currentTarget.style.borderColor = '';
            return false;
        }

        function handleDragEnd(e) {
            e.currentTarget.style.opacity = '1';
            draggedImageId = null;

            // Remove border colors from all cards
            document.querySelectorAll('.image-card').forEach(card => {
                card.style.borderColor = '';
            });
        }

        function updateImageCount() {
            document.getElementById('imageCount').textContent = images.length;

            // Enable download all button if folder selected and images exist
            const downloadAllBtn = document.getElementById('downloadAllBtn');
            if (downloadAllBtn) {
                downloadAllBtn.disabled = !downloadFolderHandle || images.length === 0;
            }
        }

        // Clear all images
        function clearAllImages() {
            if (images.length === 0) {
                alert('‚ö†Ô∏è Kh√¥ng c√≥ ·∫£nh n√†o ƒë·ªÉ x√≥a!');
                return;
            }

            const confirmed = confirm(`üóëÔ∏è X√≥a t·∫•t c·∫£ ${images.length} ·∫£nh?\n\n‚ö†Ô∏è L∆∞u √Ω: Ch·ªâ x√≥a trong gallery, file tr√™n m√°y v·∫´n c√≤n.\n\n‚úÖ Nh·∫•n OK ƒë·ªÉ x√≥a\n‚ùå Nh·∫•n Cancel ƒë·ªÉ h·ªßy`);

            if (!confirmed) {
                console.log('‚ùå User cancelled clear all');
                return;
            }

            console.log(`üóëÔ∏è Clearing ${images.length} images from gallery...`);

            // Clear images array
            const clearedCount = images.length;
            images = [];

            // Clear gallery UI
            const gallery = document.getElementById('gallery');
            gallery.innerHTML = `
                <div class="empty-state">
                    <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
                    </svg>
                    <h3>Ch∆∞a c√≥ ·∫£nh n√†o</h3>
                    <p>Nh·∫≠p m√¥ t·∫£ ·ªü sidebar v√† nh·∫•n "T·∫°o ·∫¢nh" ƒë·ªÉ b·∫Øt ƒë·∫ßu</p>
                </div>
            `;

            // Update image count
            updateImageCount();

            console.log(`‚úÖ Cleared ${clearedCount} images successfully!`);
            alert(`‚úÖ ƒê√£ x√≥a ${clearedCount} ·∫£nh kh·ªèi gallery!\n\nüí° B·∫°n c√≥ th·ªÉ b·∫Øt ƒë·∫ßu batch m·ªõi.`);
        }

        // Modal
        function openModal(data) {
            const image = images.find(img => img.id === data.id);
            if (!image) return;

            currentModalImage = image;
            window.currentViewingReference = null;

            // Show normal regen button
            document.getElementById('regenNormalBtn').style.display = 'inline-block';
            document.getElementById('regenRefBtn').style.display = 'none';

            updateModalDisplay();
            document.getElementById('imageModal').classList.add('active');
        }

        function updateModalDisplay() {
            if (!currentModalImage) return;

            const image = currentModalImage;
            const currentVer = image.versions[image.currentVersion];
            const hasHistory = image.versions.length > 1;
            const currentVersionNum = image.versions.length - image.currentVersion;

            // Update image
            document.getElementById('modalImage').src = currentVer.imageUrl;

            // Update prompt
            document.getElementById('modalPrompt').textContent = `"${image.prompt}"`;

            // Update seed info
            const batchInfo = image.batchIndex !== null ? ` | Batch #${image.batchIndex + 1}` : '';
            document.getElementById('modalSeed').textContent = `Seed: ${currentVer.seed || 'auto'}${batchInfo}`;

            // Version navigation
            const versionNav = document.getElementById('modalVersionNav');
            if (hasHistory) {
                versionNav.style.display = 'block';
                document.getElementById('modalVersionInfo').textContent = `[${currentVersionNum}/${image.versions.length}]`;
                document.getElementById('modalVerPrev').disabled = image.currentVersion >= image.versions.length - 1;
                document.getElementById('modalVerNext').disabled = image.currentVersion <= 0;
            } else {
                versionNav.style.display = 'none';
            }

            // Batch navigation
            const hasBatch = image.batchIndex !== null;
            if (hasBatch) {
                // Get all images with batchIndex, sorted by batchIndex
                const batchImages = images
                    .filter(img => img.batchIndex !== null)
                    .sort((a, b) => a.batchIndex - b.batchIndex);

                // Find current image position in sorted batch
                const currentIdx = batchImages.findIndex(img => img.id === image.id);

                const hasPrev = currentIdx > 0;
                const hasNext = currentIdx < batchImages.length - 1;

                document.getElementById('modalPrevBatch').disabled = !hasPrev;
                document.getElementById('modalNextBatch').disabled = !hasNext;
                document.getElementById('modalPrevBatch').style.display = 'flex';
                document.getElementById('modalNextBatch').style.display = 'flex';

                console.log(`üìä Batch navigation: ${currentIdx + 1}/${batchImages.length}, hasPrev: ${hasPrev}, hasNext: ${hasNext}`);
            } else {
                document.getElementById('modalPrevBatch').style.display = 'none';
                document.getElementById('modalNextBatch').style.display = 'none';
            }
        }

        function navigateBatch(direction) {
            if (!currentModalImage || currentModalImage.batchIndex === null) return;

            // Get all images with batchIndex, sorted by batchIndex
            const batchImages = images
                .filter(img => img.batchIndex !== null)
                .sort((a, b) => a.batchIndex - b.batchIndex);

            // Find current image position
            const currentIdx = batchImages.findIndex(img => img.id === currentModalImage.id);

            if (currentIdx === -1) return;

            const targetIdx = currentIdx + direction;

            if (targetIdx >= 0 && targetIdx < batchImages.length) {
                currentModalImage = batchImages[targetIdx];
                updateModalDisplay();
                console.log(`‚û°Ô∏è Navigated to batch image ${targetIdx + 1}/${batchImages.length}`);
            }
        }

        function navigateModalVersion(direction) {
            // Check if viewing reference or regular image
            if (window.currentViewingReference) {
                navigateReferenceVersion(direction);
                return;
            }

            if (!currentModalImage) return;

            if (direction === 'prev' && currentModalImage.currentVersion < currentModalImage.versions.length - 1) {
                currentModalImage.currentVersion++;
                updateModalDisplay();
            } else if (direction === 'next' && currentModalImage.currentVersion > 0) {
                currentModalImage.currentVersion--;
                updateModalDisplay();
            }
        }

        function editModalPrompt() {
            if (!currentModalImage) return;

            const promptDiv = document.getElementById('modalPrompt');
            const currentPrompt = currentModalImage.prompt;

            promptDiv.innerHTML = `
                <textarea id="edit-modal-prompt" style="width: 100%; min-height: 80px; padding: 8px; font-size: 14px; border: 1px solid var(--primary-color); border-radius: 4px; background: var(--bg-main); color: var(--text-primary); resize: vertical;">${currentPrompt}</textarea>
                <div style="display: flex; gap: 8px; margin-top: 8px;">
                    <button class="btn btn-primary" onclick="saveModalPrompt()" style="flex: 1;">‚úì Save</button>
                    <button class="btn btn-secondary" onclick="updateModalDisplay()" style="flex: 1;">‚úó Cancel</button>
                </div>
            `;
            document.getElementById('edit-modal-prompt').focus();
        }

        function saveModalPrompt() {
            if (!currentModalImage) return;

            const textarea = document.getElementById('edit-modal-prompt');
            if (!textarea) return;

            const newPrompt = textarea.value.trim();
            if (!newPrompt) {
                alert('Prompt kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng!');
                return;
            }

            currentModalImage.prompt = newPrompt;
            renderImageCard(currentModalImage); // Update card in gallery
            updateModalDisplay(); // Update modal
        }

        async function regenerateModalImage() {
            if (!currentModalImage) return;

            // Close modal and regenerate in gallery
            const imageId = currentModalImage.id;
            closeModal();
            await regenerateImageInPlace(imageId);
        }

        function closeModal(event) {
            if (!event || event.target.id === 'imageModal') {
                document.getElementById('imageModal').classList.remove('active');
                currentModalImage = null;
            }
        }

        function downloadCurrentImage() {
            if (currentModalImage) {
                const currentVer = currentModalImage.versions[currentModalImage.currentVersion];
                downloadImage(currentVer.imageUrl, currentModalImage.prompt, currentVer.seed);
            }
        }

        // Download
        async function downloadImage(imageUrl, prompt, seed) {
            const filename = `whisk_${seed || 'auto'}_${Date.now()}.jpg`;

            if (downloadFolderHandle) {
                try {
                    await saveToFolder(imageUrl, filename);
                    return;
                } catch (err) {
                    console.error('Auto download failed:', err);
                }
            }

            // Fallback
            const a = document.createElement('a');
            a.href = imageUrl;
            a.download = filename;
            a.click();
        }

        async function autoDownloadImage(imageUrl, prompt, seed) {
            if (!downloadFolderHandle) return;

            const filename = `whisk_${seed || 'auto'}_${Date.now()}.jpg`;
            try {
                await saveToFolder(imageUrl, filename);
            } catch (err) {
                console.error('Auto download error:', err);
            }
        }

        async function saveToFolder(imageUrl, filename) {
            try {
                console.log(`[saveToFolder] START - URL: ${imageUrl}, filename: ${filename}`);

                // Fetch the image from server
                const response = await fetch(imageUrl);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const blob = await response.blob();
                console.log(`[saveToFolder] Blob size: ${blob.size} bytes, type: ${blob.type}`);

                if (blob.size === 0) {
                    throw new Error('Downloaded blob is empty (0 bytes)');
                }

                // Save to selected folder using File System Access API
                const fileHandle = await downloadFolderHandle.getFileHandle(filename, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(blob);
                await writable.close();

                console.log(`[saveToFolder] ‚úÖ SUCCESS - Saved ${filename} (${blob.size} bytes) to folder`);
            } catch (error) {
                console.error(`[saveToFolder] ‚ùå ERROR - Failed to save ${filename}:`, error);
                throw error; // Re-throw to be caught by downloadAllImages
            }
        }

        // Auto-download reference to project folder with proper naming
        async function autoDownloadReference(refName, imageUrl, isRegen = false) {
            try {
                const projectName = document.getElementById('projectName').value.trim();
                const refFolderPath = document.getElementById('refFolderPath').value.trim();

                if (!projectName) {
                    console.log('‚ö†Ô∏è No project name specified, skipping auto-download');
                    return;
                }

                if (!refFolderPath) {
                    console.log('‚ö†Ô∏è No ref folder path specified, skipping auto-download');
                    return;
                }

                console.log(`üì• Saving reference to: ${refFolderPath}\\${projectName}\\${refName}.jpg`);

                // Call server API to save reference
                const response = await fetch('/api/save-reference', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        imageUrl: imageUrl,
                        refFolderPath: refFolderPath,
                        projectName: projectName,
                        refName: refName,
                        isRegen: isRegen
                    })
                });

                const result = await response.json();

                if (result.success) {
                    console.log(`‚úÖ Reference saved: ${result.path}`);
                } else {
                    console.error(`‚ùå Failed to save reference: ${result.error}`);
                }
            } catch (err) {
                console.error('‚ùå Auto-download reference failed:', err);
            }
        }

        async function downloadAllImages() {
            if (!downloadFolderHandle) {
                alert('Vui l√≤ng ch·ªçn th∆∞ m·ª•c tr∆∞·ªõc!');
                return;
            }

            if (images.length === 0) {
                alert('Kh√¥ng c√≥ ·∫£nh n√†o ƒë·ªÉ t·∫£i!');
                return;
            }

            const confirmDownload = confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën t·∫£i ${images.length} ·∫£nh v·ªÅ th∆∞ m·ª•c "${downloadFolderHandle.name}"?`);
            if (!confirmDownload) return;

            const downloadBtn = document.getElementById('downloadAllBtn');
            const originalText = downloadBtn.innerHTML;
            downloadBtn.disabled = true;

            let successCount = 0;
            let errorCount = 0;
            const errors = [];

            console.log(`\n${'='.repeat(60)}`);
            console.log(`[downloadAllImages] START - Downloading ${images.length} images to folder: ${downloadFolderHandle.name}`);
            console.log('='.repeat(60));

            for (let i = 0; i < images.length; i++) {
                const image = images[i];
                const currentVer = image.versions[image.currentVersion];
                const filename = `${i + 1}.jpg`;  // Changed from image_1.jpg to 1.jpg

                downloadBtn.innerHTML = `‚è≥ ƒêang t·∫£i ${i + 1}/${images.length}...`;

                // Skip placeholder images or images without valid URL
                if (image.placeholder || !currentVer.imageUrl || currentVer.imageUrl === 'placeholder') {
                    console.log(`‚è≠Ô∏è [${i + 1}/${images.length}] ${filename} - SKIPPED (placeholder or no URL)`);
                    errorCount++;
                    errors.push(`Image ${i + 1}: Placeholder ho·∫∑c kh√¥ng c√≥ URL`);
                    continue;
                }

                try {
                    await saveToFolder(currentVer.imageUrl, filename);
                    successCount++;
                    console.log(`‚úÖ [${i + 1}/${images.length}] ${filename} - OK`);
                } catch (err) {
                    console.error(`‚ùå [${i + 1}/${images.length}] ${filename} - FAILED:`, err.message);
                    errorCount++;
                    errors.push(`Image ${i + 1}: ${err.message}`);
                }
            }

            downloadBtn.innerHTML = originalText;
            downloadBtn.disabled = false;

            console.log(`\n${'='.repeat(60)}`);
            console.log(`[downloadAllImages] DONE - Success: ${successCount}, Errors: ${errorCount}`);
            console.log('='.repeat(60));

            if (errorCount > 0) {
                const errorMsg = `‚úÖ T·∫£i xong!\n\nTh√†nh c√¥ng: ${successCount}\nL·ªói: ${errorCount}\n\n‚ö†Ô∏è L·ªói:\n${errors.slice(0, 5).join('\n')}${errorCount > 5 ? `\n... v√† ${errorCount - 5} l·ªói kh√°c (xem console)` : ''}`;
                alert(errorMsg);
            } else {
                alert(`‚úÖ T·∫£i xong!\n\nTh√†nh c√¥ng: ${successCount}\nT·∫•t c·∫£ ·∫£nh ƒë√£ ƒë∆∞·ª£c l∆∞u v√†o th∆∞ m·ª•c "${downloadFolderHandle.name}"`);
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') closeModal();

            // Add batch navigation with arrow keys in modal
            const modal = document.getElementById('imageModal');
            if (modal && modal.style.display === 'flex') {
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    navigateBatch(-1);
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    navigateBatch(1);
                }
            }
        });

        // Make images globally accessible for video module
        window.images = images;

        // ==================== VEO3 PROJECT SETUP ====================
        function handleSetProject() {
            const url = document.getElementById('projectUrl').value.trim();

            if (!url) {
                alert('‚ö†Ô∏è Vui l√≤ng paste URL!\n\nVD: labs.google/fx/tools/flow/project/xxx/scenes/xxx');
                return;
            }

            try {
                // Parse URL using VideoVeo3 module
                const { projectId, sceneId } = VideoVeo3.setProjectFromUrl(url);

                // Display parsed IDs
                document.getElementById('displayProjectId').textContent = projectId;
                document.getElementById('displaySceneId').textContent = sceneId;
                document.getElementById('parsedIds').style.display = 'block';
                document.getElementById('projectUrl').style.borderColor = 'var(--success-color)';

                alert(`‚úÖ ƒê√£ set th√†nh c√¥ng!\n\nProject ID: ${projectId}\nScene ID: ${sceneId}\n\nB√¢y gi·ªù c√≥ th·ªÉ gen videos!`);
            } catch (err) {
                alert(`‚ùå ${err.message}`);
                document.getElementById('projectUrl').style.borderColor = 'var(--danger-color)';
            }
        }
		// ==========================================
        // VIDEO GENERATION SYSTEM
        // ==========================================
        
        let videoScenes = [];
        let currentProjectId = '';
        let currentSceneId = '';
        // Download progress helpers
        function showDownloadProgress() {
            document.getElementById('downloadProgress').style.display = 'block';
            document.getElementById('downloadProgressText').textContent = '0/0';
            document.getElementById('downloadProgressPercent').textContent = '0%';
            document.getElementById('downloadProgressBar').style.width = '0%';
            document.getElementById('downloadFileList').innerHTML = '';
            document.getElementById('downloadCloseBtn').style.display = 'none';
        }

        function updateDownloadProgress(current, total, fileName, status) {
            const percent = Math.round((current / total) * 100);
            document.getElementById('downloadProgressText').textContent = `${current}/${total}`;
            document.getElementById('downloadProgressPercent').textContent = `${percent}%`;
            document.getElementById('downloadProgressBar').style.width = `${percent}%`;

            // Also update header progress bar
            const headerProgress = document.getElementById('videoDownloadProgress');
            const headerText = document.getElementById('videoDownloadProgressText');
            if (headerProgress && headerText) {
                headerProgress.style.display = 'inline-block';
                headerText.textContent = `üì• ƒêang t·∫£i: ${current}/${total} (${percent}%)`;

                // Hide when complete
                if (current === total) {
                    setTimeout(() => {
                        headerProgress.style.display = 'none';
                    }, 3000); // Hide after 3 seconds
                }
            }

            // Update or add file to list (single line per file)
            if (fileName) {
                const fileList = document.getElementById('downloadFileList');
                const fileId = `dl-file-${fileName.replace(/[^a-z0-9]/gi, '_')}`;
                let fileItem = document.getElementById(fileId);

                if (!fileItem) {
                    // Create new file item
                    fileItem = document.createElement('div');
                    fileItem.id = fileId;
                    fileItem.style.cssText = 'padding: 6px 8px; margin-bottom: 4px; background: var(--bg-main); border-radius: 4px; font-size: 11px; display: flex; justify-content: space-between; align-items: center;';
                    fileList.appendChild(fileItem);
                }

                // Update status
                const statusIcon = status === 'done' ? '‚úì' : status === 'error' ? 'üîÑ' : '‚è≥';
                const statusColor = status === 'done' ? 'var(--success-color)' : status === 'error' ? 'var(--warning-color)' : 'var(--text-secondary)';

                if (status === 'error') {
                    // Show retry button for errors
                    fileItem.innerHTML = `
                        <span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${fileName}</span>
                        <button onclick="retryDownload('${fileName}')" style="background: var(--warning-color); color: white; border: none; border-radius: 3px; padding: 2px 8px; font-size: 10px; cursor: pointer;">üîÑ Retry</button>
                    `;
                } else {
                    // Show status icon
                    fileItem.innerHTML = `
                        <span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${fileName}</span>
                        <span style="color: ${statusColor}; font-weight: bold; margin-left: 8px;">${statusIcon}</span>
                    `;
                }
            }

            // Show close button when done
            if (current === total) {
                document.getElementById('downloadCloseBtn').style.display = 'block';
            }
        }

        function hideDownloadProgress() {
            document.getElementById('downloadProgress').style.display = 'none';
        }

        function closeDownloadProgress() {
            document.getElementById('downloadProgress').style.display = 'none';
        }

        // ===== OUTPUT FOLDER SELECTION FUNCTIONS =====

        // Load saved folder on page load
        function loadOutputFolder() {
            const saved = localStorage.getItem('veo3_output_folder');
            if (saved) {
                document.getElementById('outputFolderPath').value = saved;
            }
        }

        // Save folder when changed
        function saveOutputFolder() {
            const folder = document.getElementById('outputFolderPath').value.trim();
            if (folder) {
                localStorage.setItem('veo3_output_folder', folder);
                console.log('‚úÖ ƒê√£ l∆∞u th∆∞ m·ª•c video:', folder);
            } else {
                localStorage.removeItem('veo3_output_folder');
                console.log('‚úÖ ƒê√£ x√≥a th∆∞ m·ª•c t√πy ch·ªânh (d√πng m·∫∑c ƒë·ªãnh)');
            }
        }

        // Open output folder in file explorer
        async function openOutputFolder() {
            let folderPath = document.getElementById('outputFolderPath').value.trim();

            // If empty, use default folder (./videos from server root)
            if (!folderPath) {
                folderPath = './videos';
            }

            try {
                const response = await fetch('/api/open-folder', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ folderPath })
                });

                const result = await response.json();

                if (result.success) {
                    console.log('‚úÖ ƒê√£ m·ªü th∆∞ m·ª•c:', folderPath);
                } else {
                    alert('‚ùå Kh√¥ng th·ªÉ m·ªü th∆∞ m·ª•c: ' + result.error);
                }
            } catch (err) {
                alert('‚ùå L·ªói khi m·ªü th∆∞ m·ª•c: ' + err.message);
            }
        }

        // Reset to default
        function resetOutputFolder() {
            localStorage.removeItem('veo3_output_folder');
            document.getElementById('outputFolderPath').value = '';
            alert('‚úÖ ƒê√£ reset v·ªÅ th∆∞ m·ª•c m·∫∑c ƒë·ªãnh (./videos)');
        }

        // Get current output folder (use in download calls)
        function getOutputFolder() {
            const folder = document.getElementById('outputFolderPath').value.trim();
            return folder || null; // null = use server default
        }

        // ===== END OUTPUT FOLDER FUNCTIONS =====

        // ===== IMAGE FOLDER SELECTION FUNCTIONS =====

        // Load saved image folder on page load
        function loadImageFolder() {
            const saved = localStorage.getItem('image_folder_path');
            if (saved) {
                document.getElementById('imageFolderPath').value = saved;
                console.log('‚úÖ ƒê√£ load th∆∞ m·ª•c ·∫£nh:', saved);
            } else {
                // Set default if not saved
                document.getElementById('imageFolderPath').value = 'D:\\D·ª± √°n\\·∫¢nh';
            }
        }

        // Save image folder when changed
        function saveImageFolder() {
            const folder = document.getElementById('imageFolderPath').value.trim();
            if (folder) {
                localStorage.setItem('image_folder_path', folder);
                console.log('‚úÖ ƒê√£ l∆∞u th∆∞ m·ª•c ·∫£nh:', folder);
            }
        }

        // Select image folder using File System Access API
        async function selectImageFolder() {
            try {
                if ('showDirectoryPicker' in window) {
                    downloadFolderHandle = await window.showDirectoryPicker({ mode: 'readwrite' });

                    // Update input with folder name
                    const folderPath = downloadFolderHandle.name;
                    document.getElementById('imageFolderPath').value = folderPath;

                    // Save to localStorage
                    saveImageFolder();

                    console.log(`‚úÖ ƒê√£ ch·ªçn th∆∞ m·ª•c: ${folderPath}`);
                    alert(`‚úÖ ƒê√£ ch·ªçn th∆∞ m·ª•c: ${folderPath}\n\n·∫¢nh s·∫Ω t·ª± ƒë·ªông l∆∞u v√†o ƒë√¢y khi generate.`);

                    // Update button states
                    updateImageCount();
                } else {
                    alert('Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ File System Access API');
                }
            } catch (err) {
                if (err.name !== 'AbortError') {
                    console.error('Folder selection error:', err);
                }
            }
        }

        // Get current image folder path
        function getImageFolder() {
            const folder = document.getElementById('imageFolderPath').value.trim();
            return folder || 'D:\\D·ª± √°n\\·∫¢nh'; // default
        }

        // ===== END IMAGE FOLDER FUNCTIONS =====

        // Save images and switch to video tab
        function saveAndSwitchToVideo() {
            if (images.length < 2) {
                alert('‚ö†Ô∏è C·∫ßn √≠t nh·∫•t 2 ·∫£nh ƒë·ªÉ t·∫°o video scenes!');
                return;
            }

            // Create scenes from image pairs: 1-2, 2-3, 3-4...
            // Handle placeholders: if image is placeholder, scene becomes [prev]-[null] or [null]-[next]
            videoScenes = [];
            for (let i = 0; i < images.length - 1; i++) {
                const image1 = images[i];
                const image2 = images[i + 1];

                // Check if either image is placeholder
                const isPlaceholder1 = image1.isPlaceholder || image1.versions[image1.currentVersion]?.isPlaceholder;
                const isPlaceholder2 = image2.isPlaceholder || image2.versions[image2.currentVersion]?.isPlaceholder;

                // Get image URLs (null for placeholders)
                const img1 = isPlaceholder1 ? null : image1.versions[image1.currentVersion].imageUrl;
                const img2 = isPlaceholder2 ? null : image2.versions[image2.currentVersion].imageUrl;

                // Create scene (will have null start or end if placeholder)
                videoScenes.push({
                    id: Date.now() + i,
                    index: i,
                    startImage: img1,  // Null if placeholder
                    startImageName: isPlaceholder1 ? `[Empty ${i + 1}]` : `Image ${i + 1}`,
                    endImage: img2,  // Null if placeholder
                    endImageName: isPlaceholder2 ? `[Empty ${i + 2}]` : `Image ${i + 2}`,
                    prompt: '',
                    type: 'normal',
                    status: 'idle',
                    videos: [],
                    selectedVideoId: null,
                    error: null,
                    hasPlaceholder: isPlaceholder1 || isPlaceholder2 // Flag for UI
                });
            }

            renderVideoScenes();
            VideoModule.switchTab('video');

            const placeholderCount = videoScenes.filter(s => s.hasPlaceholder).length;
            const message = placeholderCount > 0
                ? `‚úÖ Created ${videoScenes.length} scenes!\n‚ö†Ô∏è ${placeholderCount} scenes have empty placeholders\n\nüìå B·∫°n c√≥ th·ªÉ upload ·∫£nh v√†o placeholder ho·∫∑c gen video v·ªõi 1 ·∫£nh`
                : `‚úÖ Created ${videoScenes.length} video scenes!\n\nüìå Next: Setup Project ‚Üí Enter prompts ‚Üí Generate`;

            alert(message);
        }

        // Save and switch to video with SINGLE image per scene (1 ·∫£nh 1 scene)
        function saveAndSwitchToVideo_Single() {
            if (images.length < 1) {
                alert('‚ö†Ô∏è C·∫ßn √≠t nh·∫•t 1 ·∫£nh ƒë·ªÉ t·∫°o video scenes!');
                return;
            }

            // Create scenes from individual images: [1]-[null], [2]-[null], [3]-[null]...
            // Each image becomes a startImage (no endImage)
            videoScenes = [];
            for (let i = 0; i < images.length; i++) {
                const image = images[i];

                // Check if image is placeholder
                const isPlaceholder = image.isPlaceholder || image.versions[image.currentVersion]?.isPlaceholder;

                // Get image URL (null for placeholders)
                const imgUrl = isPlaceholder ? null : image.versions[image.currentVersion].imageUrl;

                // Create scene with only startImage (endImage = null)
                videoScenes.push({
                    id: Date.now() + i,
                    index: i,
                    startImage: imgUrl,  // Null if placeholder
                    startImageName: isPlaceholder ? `[Empty ${i + 1}]` : `Image ${i + 1}`,
                    endImage: null,  // Always null for single-image mode
                    endImageName: null,
                    prompt: '',
                    type: 'normal',
                    status: 'idle',
                    videos: [],
                    selectedVideoId: null,
                    error: null,
                    hasPlaceholder: isPlaceholder // Flag for UI
                });
            }

            renderVideoScenes();
            VideoModule.switchTab('video');

            const placeholderCount = videoScenes.filter(s => s.hasPlaceholder).length;
            const message = placeholderCount > 0
                ? `‚úÖ Created ${videoScenes.length} scenes (1 ·∫£nh/scene)!\n‚ö†Ô∏è ${placeholderCount} scenes have empty placeholders\n\nüìå Upload ·∫£nh v√†o placeholder ho·∫∑c nh·∫≠p prompt ƒë·ªÉ gen video`
                : `‚úÖ Created ${videoScenes.length} video scenes (1 ·∫£nh/scene)!\n\nüìå Next: Setup Project ‚Üí Enter prompts ‚Üí Generate`;

            alert(message);
        }

        // Bulk image upload
        async function handleBulkImageUpload(event) {
            const files = event.target.files;
            if (!files || files.length < 2) {
                alert('‚ö†Ô∏è Please select at least 2 images!');
                return;
            }

            const imagePromises = Array.from(files).map((file, idx) =>
                fileToBase64(file).then(b64 => ({ b64, name: file.name }))
            );
            const base64Images = await Promise.all(imagePromises);

            // Create scenes
            videoScenes = [];
            for (let i = 0; i < base64Images.length - 1; i++) {
                videoScenes.push({
                    id: Date.now() + i,
                    index: i,
                    startImage: base64Images[i].b64,  // Just the data URL string
                    startImageName: base64Images[i].name,
                    endImage: base64Images[i + 1].b64,  // Just the data URL string
                    endImageName: base64Images[i + 1].name,
                    prompt: '',
                    type: 'normal',
                    status: 'idle',
                    videos: [],
                    selectedVideoId: null,
                    error: null
                });
            }

            renderVideoScenes();
            event.target.value = ''; // Reset input

            alert(`‚úÖ Created ${videoScenes.length} scenes from uploaded images!`);
        }

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // Helper: Convert data URL to Blob (avoid fetch stack overflow)
        function dataUrlToBlob(dataUrl) {
            try {
                console.log(`üîß [dataUrlToBlob] B·∫ÆT ƒê·∫¶U - Converting ${dataUrl.length} chars...`);

                // Extract base64 data
                console.log(`üîß [dataUrlToBlob] B∆∞·ªõc 1: Split data URL...`);
                const parts = dataUrl.split(',');
                const mimeMatch = parts[0].match(/:(.*?);/);
                const mime = mimeMatch ? mimeMatch[1] : 'image/jpeg';
                const base64 = parts[1];
                console.log(`üîß [dataUrlToBlob] B∆∞·ªõc 2: MIME type: ${mime}, base64 length: ${base64.length}`);

                // Decode base64
                console.log(`üîß [dataUrlToBlob] B∆∞·ªõc 3: Decode base64...`);
                const binaryString = atob(base64);
                console.log(`üîß [dataUrlToBlob] B∆∞·ªõc 4: Binary string length: ${binaryString.length}`);

                console.log(`üîß [dataUrlToBlob] B∆∞·ªõc 5: T·∫°o Uint8Array...`);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                console.log(`üîß [dataUrlToBlob] B∆∞·ªõc 6: ƒê√£ t·∫°o Uint8Array v·ªõi ${bytes.length} bytes`);

                console.log(`üîß [dataUrlToBlob] B∆∞·ªõc 7: T·∫°o Blob...`);
                const blob = new Blob([bytes], { type: mime });
                console.log(`‚úÖ [dataUrlToBlob] B∆∞·ªõc 8: HO√ÄN TH√ÄNH - Created blob: ${blob.size} bytes`);
                console.log(`‚úÖ [dataUrlToBlob] B∆∞·ªõc 9: ƒêANG RETURN BLOB...`);
                return blob;
            } catch (error) {
                console.error(`‚ùå [dataUrlToBlob] L·ªñI:`, error);
                console.error(`‚ùå [dataUrlToBlob] Error message:`, error.message);
                console.error(`‚ùå [dataUrlToBlob] Error stack:`, error.stack);
                throw error;
            }
        }

        // Setup drag & drop for bulk image upload
        window.addEventListener('DOMContentLoaded', () => {
            const dropZone = document.getElementById('dropZone');
            if (!dropZone) return;

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => {
                    dropZone.style.borderColor = 'var(--primary-color)';
                    dropZone.style.background = 'rgba(26, 115, 232, 0.1)';
                }, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => {
                    dropZone.style.borderColor = 'var(--border-color)';
                    dropZone.style.background = 'var(--bg-main)';
                }, false);
            });

            dropZone.addEventListener('drop', (e) => {
                const dt = e.dataTransfer;
                const files = dt.files;

                if (files.length > 0) {
                    handleBulkImageUpload({ target: { files } });
                }
            }, false);
        });

        // Transfer bulk prompts to scenes
        function transferPromptsToScenes() {
            const bulkText = document.getElementById('bulkPrompts').value.trim();
            if (!bulkText) {
                alert('‚ö†Ô∏è Please enter prompts!');
                return;
            }

            const lines = bulkText.split('\n').filter(line => line.trim() !== '');

            if (lines.length === 0) {
                alert('‚ö†Ô∏è No valid prompts found!');
                return;
            }

            // If no scenes exist, create empty scenes for each prompt
            if (videoScenes.length === 0) {
                lines.forEach((line, i) => {
                    const isExtension = line.toLowerCase().startsWith('(continue)');
                    const prompt = isExtension ? line.substring(10).trim() : line;

                    videoScenes.push({
                        id: Date.now() + i,
                        index: i,
                        startImage: null,
                        startImageName: null,
                        endImage: null,
                        endImageName: null,
                        prompt: prompt,
                        type: isExtension ? 'extension' : 'normal',
                        status: 'idle',
                        videos: [],
                        selectedVideoId: null,
                        error: null
                    });
                });

                // Auto-detect mentions in all new scenes
                videoScenes.forEach((scene, i) => {
                    autoConvertToReferenceMode(i);
                });

                renderVideoScenes();
                alert(`‚úÖ Created ${lines.length} empty scenes from prompts!\n\nüìå Upload ·∫£nh v√†o m·ªói scene ho·∫∑c d√πng text-to-video (kh√¥ng c·∫ßn ·∫£nh).`);
                return;
            }

            // Apply prompts to existing scenes
            lines.forEach((line, i) => {
                if (i < videoScenes.length) {
                    const isExtension = line.toLowerCase().startsWith('(continue)');
                    videoScenes[i].prompt = isExtension ? line.substring(10).trim() : line;
                    videoScenes[i].type = isExtension ? 'extension' : 'normal';

                    // Auto-detect mentions after updating prompt
                    autoConvertToReferenceMode(i);
                }
            });

            renderVideoScenes();
            alert(`‚úÖ Applied ${Math.min(lines.length, videoScenes.length)} prompts to scenes!`);
        }

        // Auto-extract project/scene from URL (silent, no alert)
        function autoExtractProjectScene() {
            const url = document.getElementById('projectUrl').value.trim();
            if (!url) return;

            const projectMatch = url.match(/project\/([^\/]+)/);
            const sceneMatch = url.match(/scenes\/([^\/\?]+)/);

            if (projectMatch) {
                currentProjectId = projectMatch[1];
                localStorage.setItem('veo3_projectId', currentProjectId);
                const projectIdInput = document.getElementById('projectId');
                if (projectIdInput) projectIdInput.value = currentProjectId;
            }

            if (sceneMatch) {
                currentSceneId = sceneMatch[1];
                localStorage.setItem('veo3_sceneId', currentSceneId);
                const sceneIdInput = document.getElementById('sceneId');
                if (sceneIdInput) sceneIdInput.value = currentSceneId;
            }
        }

        // Manual extract with alert
        function extractProjectScene() {
            const url = document.getElementById('projectUrl').value.trim();

            if (!url) {
                alert('‚ö†Ô∏è Please paste URL!');
                return;
            }

            autoExtractProjectScene();

            if (currentProjectId || currentSceneId) {
                alert(`‚úÖ Extracted!\nProject: ${currentProjectId}\nScene: ${currentSceneId}`);
            } else {
                alert('‚ùå Could not extract IDs from URL');
            }
        }

        // Load saved projectId/sceneId on startup
        function loadSavedProjectIds() {
            const savedProjectId = localStorage.getItem('veo3_projectId');
            const savedSceneId = localStorage.getItem('veo3_sceneId');

            if (savedProjectId) {
                currentProjectId = savedProjectId;
                const projectIdInput = document.getElementById('projectId');
                if (projectIdInput) projectIdInput.value = savedProjectId;
            }

            if (savedSceneId) {
                currentSceneId = savedSceneId;
                const sceneIdInput = document.getElementById('sceneId');
                if (sceneIdInput) sceneIdInput.value = savedSceneId;
            }

            if (savedProjectId || savedSceneId) {
                console.log(`Auto-loaded: Project=${savedProjectId}, Scene=${savedSceneId}`);
            }
        }

        // Render video scenes
        function renderVideoScenes() {
            const container = document.getElementById('videoScenes');
            const emptyMessage = document.getElementById('emptyScenesMessage');
            const countSpan = document.getElementById('scenesCount');
            const downloadBtn = document.getElementById('downloadAllVideosBtn');

            if (!container || !countSpan || !downloadBtn) return;

            countSpan.textContent = `(${videoScenes.length})`;

            if (videoScenes.length === 0) {
                if (emptyMessage) {
                    emptyMessage.style.display = 'block';
                }
                container.innerHTML = '';
                if (emptyMessage) {
                    container.appendChild(emptyMessage);
                }
                downloadBtn.disabled = true;
                return;
            }

            if (emptyMessage) {
                emptyMessage.style.display = 'none';
            }

            const hasCompletedVideos = videoScenes.some(s => s.videos.length > 0);
            downloadBtn.disabled = !hasCompletedVideos;

            // ***** NEW LAYOUT STRUCTURE (3-COLUMN) *****
            container.innerHTML = videoScenes.map((scene, idx) => {

                // --- Helper: Render Variant (Video or Placeholder) ---
                const renderVariant = (vIdx) => {
                    const video = scene.videos[vIdx];
                    const variantLetter = String.fromCharCode(97 + vIdx); // a, b

                    if (video) {
                        const videoUrl = video.localUrl || video.url;
                        return `
                        <div style="position: relative; width: 200px; height: 150px; background: #000; border: ${scene.selectedVideoId === video.id ? '2px solid var(--success-color)' : '1px solid var(--border-color)'}; border-radius: 4px; overflow: hidden; display: flex; align-items: center; justify-content: center;">
                            <video src="${videoUrl}"
                                   preload="metadata"
                                   muted
                                   loop
                                   onmouseenter="this.play()"
                                   onmouseleave="this.pause()"
                                   onclick="openVideoPreview('${videoUrl}')"
                                   style="width: 100%; height: 100%; object-fit: contain; cursor: pointer;"></video>
                            <div style="position: absolute; top: 4px; left: 4px; background: rgba(0,0,0,0.8); color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: 600; pointer-events: none;">
                                ${idx + 1}${variantLetter}
                            </div>
                            <button onclick="selectVideoVariant(${idx}, ${video.id})" style="position: absolute; top: 4px; right: 4px; background: ${scene.selectedVideoId === video.id ? 'var(--success-color)' : 'rgba(0,0,0,0.6)'}; color: white; padding: 2px 6px; border: none; border-radius: 4px; font-size: 10px; cursor: pointer;">
                                ${scene.selectedVideoId === video.id ? '‚úì' : '‚óã'}
                            </button>
                        </div>
                        `;
                    } else {
                        // Placeholder
                        return `
                        <div style="width: 200px; height: 150px; background: var(--bg-card); border: 2px dashed var(--border-color); border-radius: 4px; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 12px; color: var(--text-secondary);">
                            <div style="font-size: 24px;">${idx + 1}${variantLetter}</div>
                            <div>(Variant)</div>
                        </div>
                        `;
                    }
                };

                // --- Main Scene Card HTML ---
                return `
                <div class="scene-card" style="background: var(--bg-main); border: 1px solid var(--border-color); border-radius: 8px; padding: 16px; margin-bottom: 16px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <span style="font-size: 16px; font-weight: 700; color: var(--primary-color);">Scene ${idx + 1}</span>
                            ${scene.status === 'generating' ? '<span class="status-badge" style="background: rgba(249,171,0,0.2); color: var(--warning-color); padding: 4px 10px; border-radius: 12px; font-size: 11px;">‚è≥ Generating...</span>' : ''}
                            ${scene.status === 'done' ? '<span class="status-badge" style="background: rgba(52,168,83,0.2); color: var(--success-color); padding: 4px 10px; border-radius: 12px; font-size: 11px;">‚úÖ Done</span>' : ''}
                            ${scene.status === 'error' ? '<span class="status-badge" style="background: rgba(234,67,53,0.2); color: var(--danger-color); padding: 4px 10px; border-radius: 12px; font-size: 11px;">‚ùå Error</span>' : ''}
                        </div>
                        <button class="btn btn-secondary" onclick="deleteScene(${idx})" style="padding: 4px 10px; font-size: 11px;">Delete</button>
                    </div>

                    <div style="display: flex; gap: 12px; margin-bottom: 10px; min-height: 150px;">

                        ${scene.referenceMode ? `
                        <!-- Reference to Video Mode: 3 image slots (100x150px) -->
                        <div style="display: flex; gap: 8px; flex-shrink: 0;">
                            ${[0, 1, 2].map(slot => {
                                const refImage = scene.referenceImages && scene.referenceImages[slot];
                                const refName = scene.referenceImageNames && scene.referenceImageNames[slot];
                                return refImage ? `
                                <div style="position: relative; width: 100px; height: 150px; background: #000; border: 2px solid #8b5cf6; border-radius: 4px; overflow: hidden; cursor: pointer; display: flex; align-items: center; justify-content: center;" onclick="openImagePreview('${refImage}')">
                                    <img src="${refImage}" style="width: 100%; height: 100%; object-fit: contain;">
                                    <div style="position: absolute; bottom: 4px; left: 4px; background: rgba(139,92,246,0.9); color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: 600;">Ref ${slot + 1}</div>
                                    <button onclick="event.stopPropagation(); removeReferenceImage(${idx}, ${slot})" style="position: absolute; top: 4px; right: 4px; background: rgba(234,67,53,0.9); color: white; border: none; border-radius: 50%; width: 20px; height: 20px; cursor: pointer; font-size: 12px;">√ó</button>
                                </div>
                                ` : `
                                <div style="width: 100px; height: 150px; background: rgba(139,92,246,0.05); border: 2px dashed #8b5cf6; border-radius: 4px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; font-size: 11px; color: #8b5cf6;" onclick="uploadReferenceImageToScene(${idx}, ${slot})">
                                    <div style="font-size: 20px;">üé®</div>
                                    <div>Ref ${slot + 1}</div>
                                </div>
                                `;
                            }).join('')}
                        </div>
                        ` : `
                        <!-- Normal Mode: Start & End images -->
                        <div style="display: flex; gap: 8px; flex-shrink: 0;">
                            ${scene.startImage ? `
                            <div style="position: relative; width: 200px; height: 150px; background: #000; border: 1px solid var(--border-color); border-radius: 4px; overflow: hidden; cursor: pointer; display: flex; align-items: center; justify-content: center;" onclick="openImagePreview('${scene.startImage}')">
                                <img src="${scene.startImage}" style="width: 100%; height: 100%; object-fit: contain;">
                                <div style="position: absolute; bottom: 4px; left: 4px; background: rgba(0,0,0,0.7); color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px;">Start</div>
                                <button onclick="event.stopPropagation(); removeSceneImage(${idx}, 'start')" style="position: absolute; top: 4px; right: 4px; background: rgba(234,67,53,0.9); color: white; border: none; border-radius: 50%; width: 24px; height: 24px; cursor: pointer; font-size: 14px;">√ó</button>
                            </div>
                            ` : `
                            <div style="width: 200px; height: 150px; background: var(--bg-card); border: 2px dashed var(--border-color); border-radius: 4px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; font-size: 12px; color: var(--text-secondary);" onclick="uploadSceneImage(${idx}, 'start')">
                                <div style="font-size: 24px;">üì∑</div>
                                <div>Start (4:3)</div>
                            </div>
                            `}

                            ${scene.endImage ? `
                            <div style="position: relative; width: 200px; height: 150px; background: #000; border: 1px solid var(--border-color); border-radius: 4px; overflow: hidden; cursor: pointer; display: flex; align-items: center; justify-content: center;" onclick="openImagePreview('${scene.endImage}')">
                                <img src="${scene.endImage}" style="width: 100%; height: 100%; object-fit: contain;">
                                <div style="position: absolute; bottom: 4px; left: 4px; background: rgba(0,0,0,0.7); color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px;">End</div>
                                <button onclick="event.stopPropagation(); removeSceneImage(${idx}, 'end')" style="position: absolute; top: 4px; right: 4px; background: rgba(234,67,53,0.9); color: white; border: none; border-radius: 50%; width: 24px; height: 24px; cursor: pointer; font-size: 14px;">√ó</button>
                            </div>
                            ` : `
                            <div style="width: 200px; height: 150px; background: var(--bg-card); border: 2px dashed var(--border-color); border-radius: 4px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; font-size: 12px; color: var(--text-secondary);" onclick="uploadSceneImage(${idx}, 'end')">
                                <div style="font-size: 24px;">üì∑</div>
                                <div>End (4:3)</div>
                            </div>
                            `}
                        </div>
                        `}

                        <div style="flex: 1; min-width: 200px; height: 150px;">
                            <textarea id="scenePrompt${idx}" placeholder="Prompt (d√πng @name ƒë·ªÉ reference)..."
                                style="width: 100%; height: 100%; padding: 8px; background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 13px; resize: none;"
                                onchange="updateScenePrompt(${idx})"
                                ${scene.status === 'generating' ? 'disabled' : ''}>${scene.prompt}</textarea>
                        </div>

                        <div style="display: flex; gap: 8px; flex-shrink: 0;">
                            ${renderVariant(0)}
                            ${renderVariant(1)}
                        </div>
                    </div>

                    ${scene.error ? `<div style="padding: 8px; background: rgba(234,67,53,0.1); border: 1px solid var(--danger-color); border-radius: 4px; font-size: 12px; color: var(--danger-color); margin-bottom: 12px;">‚ùå ${scene.error}</div>` : ''}

                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <button class="btn ${scene.status === 'generating' ? 'btn-secondary' : 'btn-success'}"
                            onclick="generateVideoForScene(${idx})"
                            ${scene.status === 'generating' ? 'disabled' : ''}
                            style="flex-grow: 1; min-width: 120px; padding: 8px; font-size: 13px;">
                            ${scene.status === 'generating' ? '‚è≥ Generating...' : 'üé¨ Generate'}
                        </button>
                        ${scene.videos.length > 0 ? `
                        <button class="btn btn-primary" onclick="regenerateScene(${idx})" style="flex-grow: 1; min-width: 100px; padding: 8px; font-size: 13px;">üîÑ Regen</button>
                        ` : ''}
                        <button class="btn btn-secondary" onclick="toggleReferenceMode(${idx})" style="flex-grow: 1; min-width: 100px; padding: 8px; font-size: 13px;" title="Use 3 reference images">
                            üé® D√πng Ref
                        </button>
                        ${scene.startImage && scene.endImage ? `
                        <button class="btn btn-secondary" onclick="swapSceneImages(${idx})" title="Swap Start ‚Üî End" style="min-width: 50px; padding: 8px; font-size: 13px;">‚áÑ</button>
                        ` : ''}
                        <button class="btn btn-secondary" onclick="insertSceneAfter(${idx}, 'normal')" style="flex-grow: 1; min-width: 100px; padding: 8px; font-size: 13px;">‚ûï Normal</button>
                        <button class="btn btn-secondary" onclick="insertSceneAfter(${idx}, 'extension')" style="flex-grow: 1; min-width: 100px; padding: 8px; font-size: 13px;">‚ûï Extend</button>
                    </div>
                </div>

                ${idx < videoScenes.length - 1 ? `
                    <div style="text-align: center; margin: -8px 0 8px 0; color: var(--text-secondary); font-size: 11px;">
                        ‚¨á Insert new scene above ‚¨á
                    </div>
                ` : ''}
            `;
            }).join('');
        }

        function deleteScene(idx) {
            if (videoScenes.length === 1) {
                if (!confirm('‚ö†Ô∏è This is the last scene. Delete it anyway?')) {
                    return;
                }
            } else if (!confirm('Delete this scene?')) {
                return;
            }
            videoScenes.splice(idx, 1);
            renderVideoScenes();
        }

        function selectVideoVariant(sceneIdx, videoId) {
            videoScenes[sceneIdx].selectedVideoId = videoId;
            renderVideoScenes();
        }

        function clearAllScenes() {
            if (videoScenes.length === 0) {
                alert('‚ö†Ô∏è No scenes to clear!');
                return;
            }
            if (confirm('üóëÔ∏è Clear all scenes? This cannot be undone.')) {
                videoScenes = [];
                renderVideoScenes();
            }
        }

        // Check for error scenes (scenes without "Done" status)
        function checkErrorScenes(mode) {
            console.log(`üîç [checkErrorScenes] Mode: ${mode}`);

            if (videoScenes.length === 0) {
                alert('‚ö†Ô∏è Kh√¥ng c√≥ scenes n√†o ƒë·ªÉ ki·ªÉm tra!');
                return;
            }

            // Find scenes that are not done
            const errorScenes = [];
            videoScenes.forEach((scene, idx) => {
                if (scene.status !== 'done') {
                    errorScenes.push({ scene, index: idx });
                }
            });

            if (errorScenes.length === 0) {
                alert('‚úÖ T·∫•t c·∫£ scenes ƒë√£ ho√†n th√†nh! Kh√¥ng c√≥ l·ªói.');
                return;
            }

            // Display info about mode
            const modeText = mode === 'single' ? '1 ·∫£nh 1 scene' : '2 ·∫£nh 1 scene';
            console.log(`üîç [checkErrorScenes] T√¨m th·∫•y ${errorScenes.length} scenes ch∆∞a ho√†n th√†nh (mode: ${modeText})`);

            // Show alert with error count and jump to first error
            alert(`üîç T√¨m th·∫•y ${errorScenes.length} scene(s) ch∆∞a ho√†n th√†nh!\n\nMode: ${modeText}\n\nS·∫Ω nh·∫£y ƒë·∫øn scene l·ªói ƒë·∫ßu ti√™n...`);

            // Scroll to first error scene
            const firstErrorIndex = errorScenes[0].index;
            const sceneCards = document.querySelectorAll('.scene-card');
            if (sceneCards[firstErrorIndex]) {
                sceneCards[firstErrorIndex].scrollIntoView({
                    behavior: 'smooth',
                    block: 'center'
                });

                // Highlight the scene temporarily
                sceneCards[firstErrorIndex].style.border = '3px solid #f59e0b';
                setTimeout(() => {
                    sceneCards[firstErrorIndex].style.border = '1px solid var(--border-color)';
                }, 2000);
            }
        }

        // Toggle Auto Prompt Detection
        function toggleAutoPromptDetection() {
            const checkbox = document.getElementById('autoPromptDetection');
            console.log(`‚ú® Auto prompt detection: ${checkbox.checked ? 'enabled' : 'disabled'}`);
        }

        // Detect mentions in prompt and return info
        function detectMentionsInPrompt(prompt) {
            const mentionMatches = prompt.match(/@(\w+)/g);
            if (!mentionMatches) return { hasMentions: false, mentions: [], uniqueCount: 0 };

            const uniqueMentions = [...new Set(mentionMatches)];
            return {
                hasMentions: true,
                mentions: mentionMatches,
                uniqueMentions: uniqueMentions,
                uniqueCount: uniqueMentions.length
            };
        }

        // Auto convert scene to Reference to Video mode based on mentions
        function autoConvertToReferenceMode(sceneIdx) {
            const scene = videoScenes[sceneIdx];
            if (!scene) return;

            const autoPromptEnabled = document.getElementById('autoPromptDetection')?.checked ?? true;
            if (!autoPromptEnabled) {
                console.log('‚ö†Ô∏è Auto prompt detection is disabled');
                return;
            }

            const mentionInfo = detectMentionsInPrompt(scene.prompt);

            // If has mentions, validate and convert to reference mode
            if (mentionInfo.hasMentions) {
                console.log(`üîç Detected @mentions in scene ${sceneIdx + 1}:`, mentionInfo.uniqueMentions);

                // Validate: max 3 unique mentions
                if (mentionInfo.uniqueCount > 3) {
                    alert(`‚ö†Ô∏è L·ªói: Prompt c√≥ nhi·ªÅu h∆°n 3 @mentions kh√°c nhau (${mentionInfo.uniqueCount} mentions)!\n\nReference to Video ch·ªâ h·ªó tr·ª£ t·ªëi ƒëa 3 reference images.\n\nC√°c mentions t√¨m th·∫•y: ${mentionInfo.uniqueMentions.join(', ')}`);
                    return false;
                }

                // Auto enable reference mode
                const wasReferenceModeEnabled = scene.referenceMode;
                if (!scene.referenceMode) {
                    console.log(`‚ú® Enabling Reference to Video mode for scene ${sceneIdx + 1}`);
                    scene.referenceMode = true;
                    if (!scene.referenceImages) {
                        scene.referenceImages = [null, null, null];
                        scene.referenceImageNames = [null, null, null];
                        scene.referenceMediaIds = [null, null, null];
                    }
                }

                // Auto-populate reference images from namedReferences
                let populatedCount = 0;
                let notFoundMentions = [];

                mentionInfo.uniqueMentions.forEach((mention, idx) => {
                    const name = mention.substring(1).toLowerCase(); // remove @
                    const ref = namedReferences.characters[name] || namedReferences.scenes[name];
                    if (ref && idx < 3) {
                        scene.referenceImages[idx] = ref.imageUrl;
                        scene.referenceImageNames[idx] = `${name}.jpg`;
                        // Clear mediaId to force re-upload with new reference
                        scene.referenceMediaIds[idx] = null;
                        populatedCount++;
                        console.log(`  ‚úÖ Populated reference ${idx + 1} from @${name}`);
                    } else if (!ref) {
                        notFoundMentions.push(mention);
                        console.log(`  ‚ö†Ô∏è Reference not found for ${mention}`);
                    }
                });

                // Show notification about what was auto-detected
                if (!wasReferenceModeEnabled) {
                    let message = `‚ú® Auto-detected ${mentionInfo.uniqueCount} @mentions\n\n`;
                    if (populatedCount > 0) {
                        message += `‚úÖ Loaded ${populatedCount} reference image(s)\n`;
                    }
                    if (notFoundMentions.length > 0) {
                        message += `‚ö†Ô∏è Not found: ${notFoundMentions.join(', ')}\n‚Üí Please create these references in Images tab first or upload manually`;
                    }
                    console.log(message);
                }

                // Always render when reference mode is enabled
                renderVideoScenes();

                return true;
            } else {
                // No mentions, disable reference mode if it was auto-enabled
                if (scene.referenceMode && !scene.referenceImages?.some(img => img !== null)) {
                    console.log(`‚ÑπÔ∏è No @mentions found, keeping reference mode as-is`);
                }
            }

            return false;
        }

        // Update scene prompt and auto-detect mentions
        function updateScenePrompt(sceneIdx) {
            const promptInput = document.getElementById(`scenePrompt${sceneIdx}`);
            if (!promptInput) return;

            const scene = videoScenes[sceneIdx];
            if (!scene) return;

            // Update prompt
            scene.prompt = promptInput.value.trim();

            // Auto-detect mentions
            autoConvertToReferenceMode(sceneIdx);
        }

        // ===================================================================
        // AUTOCOMPLETE @ MENTIONS
        // ===================================================================

        let autocompleteState = {
            active: false,
            textarea: null,
            selectedIndex: 0,
            matches: [],
            mentionStart: 0
        };

        // Initialize autocomplete on textareas
        function initAutocomplete() {
            // Listen on document for input events on scene prompts
            document.addEventListener('input', (e) => {
                if (e.target.id && e.target.id.startsWith('scenePrompt')) {
                    handleAutocompleteInput(e.target, e);
                }
            });

            // Listen for keydown events (arrow keys, enter, escape)
            document.addEventListener('keydown', (e) => {
                if (autocompleteState.active) {
                    handleAutocompleteKeydown(e);
                }
            });

            // Close autocomplete when clicking outside
            document.addEventListener('click', (e) => {
                const dropdown = document.getElementById('mentionAutocomplete');
                if (autocompleteState.active && !dropdown.contains(e.target)) {
                    closeAutocomplete();
                }
            });
        }

        function handleAutocompleteInput(textarea, event) {
            const text = textarea.value;
            const cursorPos = textarea.selectionStart;

            // Find @ before cursor
            const textBeforeCursor = text.substring(0, cursorPos);
            const lastAtIndex = textBeforeCursor.lastIndexOf('@');

            if (lastAtIndex === -1) {
                closeAutocomplete();
                return;
            }

            // Get text after @
            const searchText = textBeforeCursor.substring(lastAtIndex + 1);

            // Check if there's a space after @  (means user finished typing)
            if (searchText.includes(' ')) {
                closeAutocomplete();
                return;
            }

            // Search for matches
            const matches = searchReferences(searchText);

            autocompleteState.active = true;
            autocompleteState.textarea = textarea;
            autocompleteState.matches = matches;
            autocompleteState.mentionStart = lastAtIndex;
            autocompleteState.selectedIndex = 0;

            showAutocomplete(textarea, matches);
        }

        function searchReferences(query) {
            const results = [];
            const lowerQuery = query.toLowerCase();

            // Search characters
            Object.keys(namedReferences.characters).forEach(name => {
                if (name.toLowerCase().includes(lowerQuery)) {
                    results.push({
                        name: name,
                        type: 'character',
                        ref: namedReferences.characters[name]
                    });
                }
            });

            // Search scenes
            Object.keys(namedReferences.scenes).forEach(name => {
                if (name.toLowerCase().includes(lowerQuery)) {
                    results.push({
                        name: name,
                        type: 'scene',
                        ref: namedReferences.scenes[name]
                    });
                }
            });

            return results;
        }

        function showAutocomplete(textarea, matches) {
            const dropdown = document.getElementById('mentionAutocomplete');

            if (matches.length === 0) {
                dropdown.innerHTML = '<div class="mention-empty">Kh√¥ng c√≥ reference n√†o</div>';
            } else {
                dropdown.innerHTML = matches.map((match, idx) => {
                    const typeIcon = match.type === 'character' ? 'üë§' : 'üèûÔ∏è';
                    const typeName = match.type === 'character' ? 'Character' : 'Scene';
                    return `
                        <div class="mention-item ${idx === autocompleteState.selectedIndex ? 'selected' : ''}"
                             data-index="${idx}"
                             onclick="selectMention(${idx})">
                            <img src="${match.ref.imageUrl}" alt="@${match.name}">
                            <div class="mention-item-info">
                                <div class="mention-item-name">@${match.name}</div>
                                <div class="mention-item-type">${typeIcon} ${typeName}</div>
                            </div>
                        </div>
                    `;
                }).join('');
            }

            // Position dropdown below textarea
            const rect = textarea.getBoundingClientRect();
            dropdown.style.top = (rect.bottom + window.scrollY + 4) + 'px';
            dropdown.style.left = rect.left + 'px';
            dropdown.classList.add('active');
        }

        function handleAutocompleteKeydown(e) {
            const matches = autocompleteState.matches;

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                autocompleteState.selectedIndex = (autocompleteState.selectedIndex + 1) % matches.length;
                updateAutocompleteSelection();
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                autocompleteState.selectedIndex = (autocompleteState.selectedIndex - 1 + matches.length) % matches.length;
                updateAutocompleteSelection();
            } else if (e.key === 'Enter' || e.key === 'Tab') {
                if (matches.length > 0) {
                    e.preventDefault();
                    selectMention(autocompleteState.selectedIndex);
                }
            } else if (e.key === 'Escape') {
                closeAutocomplete();
            }
        }

        function updateAutocompleteSelection() {
            const dropdown = document.getElementById('mentionAutocomplete');
            const items = dropdown.querySelectorAll('.mention-item');

            items.forEach((item, idx) => {
                if (idx === autocompleteState.selectedIndex) {
                    item.classList.add('selected');
                    item.scrollIntoView({ block: 'nearest' });
                } else {
                    item.classList.remove('selected');
                }
            });
        }

        function selectMention(index) {
            const match = autocompleteState.matches[index];
            if (!match) return;

            const textarea = autocompleteState.textarea;
            const text = textarea.value;
            const mentionStart = autocompleteState.mentionStart;

            // Find end of current @mention
            let mentionEnd = textarea.selectionStart;
            while (mentionEnd < text.length && text[mentionEnd] !== ' ' && text[mentionEnd] !== '\n') {
                mentionEnd++;
            }

            // Replace with selected mention
            const newText = text.substring(0, mentionStart) + '@' + match.name + text.substring(mentionEnd);
            textarea.value = newText;

            // Set cursor position after mention
            const newCursorPos = mentionStart + match.name.length + 1;
            textarea.setSelectionRange(newCursorPos, newCursorPos);

            // Close autocomplete
            closeAutocomplete();

            // Trigger change event to update scene
            const event = new Event('change', { bubbles: true });
            textarea.dispatchEvent(event);
        }

        function closeAutocomplete() {
            autocompleteState.active = false;
            autocompleteState.matches = [];

            const dropdown = document.getElementById('mentionAutocomplete');
            dropdown.classList.remove('active');
            dropdown.innerHTML = '';
        }

        // Initialize autocomplete when page loads
        window.addEventListener('DOMContentLoaded', () => {
            initAutocomplete();
        });

        // ===================================================================

        function addEmptyScene() {
            // Create a new empty scene
            const newScene = {
                id: Date.now(),
                index: videoScenes.length,
                startImage: null,
                startImageName: null,
                endImage: null,
                endImageName: null,
                prompt: '',
                type: 'normal',
                status: 'idle',
                videos: [],
                selectedVideoId: null,
                error: null,
                // Reference to Video mode
                referenceMode: false,
                referenceImages: [null, null, null],  // 3 image slots for ingredient-to-video
                referenceImageNames: [null, null, null],
                referenceMediaIds: [null, null, null]  // MediaGenerationId from uploadUserImage API
            };
            videoScenes.push(newScene);
            renderVideoScenes();
            console.log('‚úÖ Added empty scene');
        }

        function removeSceneImage(sceneIdx, position) {
            const scene = videoScenes[sceneIdx];
            if (position === 'start') {
                scene.startImage = null;
            } else if (position === 'end') {
                scene.endImage = null;
            }
            renderVideoScenes();
        }

        function swapSceneImages(sceneIdx) {
            const scene = videoScenes[sceneIdx];
            if (!scene.startImage || !scene.endImage) return;

            const temp = scene.startImage;
            scene.startImage = scene.endImage;
            scene.endImage = temp;

            renderVideoScenes();
        }

        // Toggle Reference to Video mode for a scene
        function toggleReferenceMode(sceneIdx) {
            const scene = videoScenes[sceneIdx];

            // Initialize reference properties if not exists
            if (!scene.hasOwnProperty('referenceMode')) {
                scene.referenceMode = false;
                scene.referenceImages = [null, null, null];
                scene.referenceImageNames = [null, null, null];
                scene.referenceMediaIds = [null, null, null];
            }

            // Toggle mode
            scene.referenceMode = !scene.referenceMode;

            console.log(`üé® Scene ${sceneIdx + 1}: Reference mode ${scene.referenceMode ? 'ON' : 'OFF'}`);
            renderVideoScenes();
        }

        // Upload reference image to specific slot (0, 1, or 2)
        function uploadReferenceImageToScene(sceneIdx, slot) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                try {
                    const base64 = await fileToBase64(file);
                    const scene = videoScenes[sceneIdx];

                    // Initialize reference arrays if not exists
                    if (!scene.referenceImages) {
                        scene.referenceImages = [null, null, null];
                        scene.referenceImageNames = [null, null, null];
                        scene.referenceMediaIds = [null, null, null];
                    }

                    scene.referenceImages[slot] = base64;
                    scene.referenceImageNames[slot] = file.name;

                    console.log(`‚úÖ Uploaded reference image ${slot + 1} for scene ${sceneIdx + 1}: ${file.name}`);
                    renderVideoScenes();
                } catch (error) {
                    console.error('‚ùå Error uploading reference image:', error);
                    alert('Error uploading image: ' + error.message);
                }
            };
            input.click();
        }

        // Remove reference image from specific slot
        function removeReferenceImage(sceneIdx, slot) {
            const scene = videoScenes[sceneIdx];
            if (scene.referenceImages && scene.referenceImages[slot]) {
                scene.referenceImages[slot] = null;
                scene.referenceImageNames[slot] = null;
                scene.referenceMediaIds[slot] = null;
                console.log(`üóëÔ∏è Removed reference image ${slot + 1} from scene ${sceneIdx + 1}`);
                renderVideoScenes();
            }
        }

        // Upload image for specific scene position
        function uploadSceneImage(sceneIdx, position) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                try {
                    const base64 = await fileToBase64(file);
                    const scene = videoScenes[sceneIdx];

                    if (position === 'start') {
                        scene.startImage = base64;
                        scene.startImageName = file.name;
                    } else if (position === 'end') {
                        scene.endImage = base64;
                        scene.endImageName = file.name;
                    }

                    renderVideoScenes();
                } catch (error) {
                    console.error('Error uploading image:', error);
                    alert('‚ùå L·ªói khi upload ·∫£nh!');
                }
            };
            input.click();
        }

        // Video preview modal
        function openVideoPreview(videoUrl) {
            const modal = document.getElementById('videoPreviewModal');
            const video = document.getElementById('videoPreviewPlayer');
            if (modal && video) {
                video.src = videoUrl;
                modal.style.display = 'flex';
                video.play();
            }
        }

        function closeVideoPreview() {
            const modal = document.getElementById('videoPreviewModal');
            const video = document.getElementById('videoPreviewPlayer');
            if (modal && video) {
                modal.style.display = 'none';
                video.pause();
                video.src = '';
            }
        }

        // Image preview modal
        function openImagePreview(imageUrl) {
            const modal = document.getElementById('imagePreviewModal');
            const img = document.getElementById('imagePreviewImg');
            if (modal && img) {
                img.src = imageUrl;
                modal.style.display = 'flex';
            }
        }

        function closeImagePreview() {
            const modal = document.getElementById('imagePreviewModal');
            const img = document.getElementById('imagePreviewImg');
            if (modal && img) {
                modal.style.display = 'none';
                img.src = '';
            }
        }

        // Regenerate scene with same settings
        async function regenerateScene(sceneIdx) {
            const scene = videoScenes[sceneIdx];

            if (!confirm(`üîÑ Regenerate Scene ${sceneIdx + 1}?\n\nThis will create new video variants.`)) {
                return;
            }

            // Reset scene status and videos
            scene.videos = [];
            scene.selectedVideoId = null;
            scene.error = null;

            // Trigger generation
            await generateVideoForScene(sceneIdx);
        }

        // Insert new scene after index
        function insertSceneAfter(afterIdx, sceneType) {
            const prevScene = videoScenes[afterIdx];

            // For extension: Get mediaId from previous scene's selected video
            let previousVideoMediaId = null;
            if (sceneType === 'extension' && prevScene.selectedVideoId) {
                const selectedVideo = prevScene.videos.find(v => v.id === prevScene.selectedVideoId);
                if (selectedVideo && selectedVideo.mediaId) {
                    previousVideoMediaId = selectedVideo.mediaId;
                    console.log(`‚úÖ [Extend] Using mediaId from previous scene: ${previousVideoMediaId}`);
                } else {
                    alert('‚ö†Ô∏è Please select a video variant from the previous scene first!');
                    return;
                }
            } else if (sceneType === 'extension') {
                alert('‚ö†Ô∏è Previous scene has no video! Generate video for the previous scene first.');
                return;
            }

            const newScene = {
                id: Date.now(),
                index: afterIdx + 1,
                startImage: null,
                endImage: null,
                prompt: sceneType === 'extension' ? '(continue) ' : '',
                type: sceneType,
                status: 'idle',
                videos: [],
                selectedVideoId: null,
                error: null,
                previousVideoMediaId: previousVideoMediaId  // Store mediaId for extend
            };

            videoScenes.splice(afterIdx + 1, 0, newScene);
            renderVideoScenes();

            // Scroll to new scene
            setTimeout(() => {
                const sceneCards = document.querySelectorAll('.scene-card');
                if (sceneCards[afterIdx + 1]) {
                    sceneCards[afterIdx + 1].scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }, 100);
        }

        // Generate video for single scene
        async function generateVideoForScene(sceneIdx, retryCount = 0) {
            const maxRetries = 2; // Total 2 retry attempts
            console.log(`üé¨ [generateVideoForScene] START Scene ${sceneIdx} (retry ${retryCount}/${maxRetries})`);

            const scene = videoScenes[sceneIdx];
            const promptInput = document.getElementById(`scenePrompt${sceneIdx}`);
            const prompt = promptInput ? promptInput.value.trim() : scene.prompt;

            console.log(`üìù [Scene ${sceneIdx}] Prompt:`, prompt);
            console.log(`üìÅ [Scene ${sceneIdx}] Project ID:`, currentProjectId);
            console.log(`üìÅ [Scene ${sceneIdx}] Scene ID:`, currentSceneId);

            if (!prompt) {
                console.warn(`‚ùå [Scene ${sceneIdx}] No prompt provided`);
                alert('‚ö†Ô∏è Please enter a prompt for this scene!');
                return;
            }

            if (!currentProjectId || !currentSceneId) {
                console.warn(`‚ùå [Scene ${sceneIdx}] Missing project/scene ID`);
                alert('‚ö†Ô∏è Please setup Project ID and Scene ID first!');
                return;
            }

            // Update scene
            scene.prompt = prompt;
            scene.status = 'generating';
            scene.error = null;
            renderVideoScenes();

            try {
                const aspectRatio = document.getElementById('videoAspectRatio').value;
                const versions = parseInt(document.getElementById('videoVersions').value) || 2;

                const hasStartImage = scene.startImage && scene.startImage !== null;
                const hasEndImage = scene.endImage && scene.endImage !== null;

                console.log(`‚öôÔ∏è [Scene ${sceneIdx}] Config:`, { aspectRatio, versions, hasStartImage, hasEndImage });

                // Generate multiple versions with different seeds
                const seeds = Array.from({ length: versions }, (_, i) => Math.floor(Math.random() * 100000));
                const operations = [];

                console.log(`üé≤ [Scene ${sceneIdx}] Seeds:`, seeds);

                // Case -1: Reference to Video mode (ingredient-to-video with 3 reference images)
                if (scene.referenceMode && scene.referenceImages && scene.referenceImages.some(img => img !== null)) {
                    console.log(`üé® [Scene ${sceneIdx}] Mode: REFERENCE-TO-VIDEO (ingredient-to-video)`);

                    // Validate that we have at least one reference image
                    const refImages = scene.referenceImages.filter(img => img !== null);
                    if (refImages.length === 0) {
                        throw new Error('‚ö†Ô∏è Reference mode enabled nh∆∞ng ch∆∞a c√≥ ·∫£nh reference n√†o!\n\nVui l√≤ng upload √≠t nh·∫•t 1 ·∫£nh reference ho·∫∑c t·∫Øt Reference mode.');
                    }

                    console.log(`üñºÔ∏è [Scene ${sceneIdx}] Found ${refImages.length} reference images`);

                    // Upload all reference images to get mediaIds
                    const referenceMediaIds = [];
                    for (let slot = 0; slot < 3; slot++) {
                        const refImage = scene.referenceImages[slot];
                        if (!refImage) {
                            console.log(`‚è≠Ô∏è [Scene ${sceneIdx}] Skipping empty slot ${slot + 1}`);
                            continue;
                        }

                        // Check if we already have a cached mediaId for this slot
                        if (scene.referenceMediaIds && scene.referenceMediaIds[slot]) {
                            console.log(`‚ôªÔ∏è [Scene ${sceneIdx}] Reference ${slot + 1} - Using existing mediaId: ${scene.referenceMediaIds[slot].substring(0, 40)}...`);
                            referenceMediaIds.push(scene.referenceMediaIds[slot]);
                            continue;
                        }

                        console.log(`‚¨ÜÔ∏è [Scene ${sceneIdx}] Reference ${slot + 1} - Preparing to upload...`);

                        try {
                            // Convert base64 to blob/file
                            let refFile;
                            if (refImage.startsWith('data:')) {
                                const refBlob = await dataUrlToBlob(refImage);
                                const refName = scene.referenceImageNames[slot] || `ref${slot + 1}.jpg`;
                                refFile = new File([refBlob], refName, { type: 'image/jpeg' });
                            } else {
                                const refBlob = await fetch(refImage).then(r => r.blob());
                                const refName = scene.referenceImageNames[slot] || `ref${slot + 1}.jpg`;
                                refFile = new File([refBlob], refName, { type: 'image/jpeg' });
                            }

                            // Upload to Veo3 and get mediaId (or get from cache)
                            const refMedia = await window.VideoVeo3.fileToMediaId(refFile, aspectRatio);
                            referenceMediaIds.push(refMedia.mediaId);
                            scene.referenceMediaIds[slot] = refMedia.mediaId;

                            console.log(`üíæ [Scene ${sceneIdx}] Reference ${slot + 1} - Saved mediaId to scene: ${refMedia.mediaId.substring(0, 40)}...`);
                        } catch (error) {
                            console.error(`‚ùå [Scene ${sceneIdx}] Failed to upload reference ${slot + 1}:`, error);
                            throw new Error(`Failed to upload reference image ${slot + 1}: ${error.message}`);
                        }
                    }

                    console.log(`‚úÖ [Scene ${sceneIdx}] All references uploaded: ${referenceMediaIds.length} mediaIds`);

                    // Call Reference-to-Video API
                    console.log(`üîÑ [Scene ${sceneIdx}] Generating video with ${referenceMediaIds.length} reference images...`);

                    const refVideoResponse = await fetch('/api/veo3/generate-reference-video', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            clientContext: {
                                sessionId: `;${Date.now()}`,
                                projectId: currentProjectId,
                                tool: 'PINHOLE',
                                userPaygateTier: 'PAYGATE_TIER_TWO'
                            },
                            requests: seeds.map(seed => ({
                                textInput: { prompt },
                                referenceImages: referenceMediaIds.map(mediaId => ({
                                    imageUsageType: "IMAGE_USAGE_TYPE_ASSET",
                                    mediaId
                                })),
                                aspectRatio,
                                seed,
                                videoModelKey: 'veo_3_0_r2v_fast_ultra',
                                metadata: { sceneId: currentSceneId }
                            }))
                        })
                    });

                    const refVideoResult = await refVideoResponse.json();
                    console.log(`‚úÖ [Scene ${sceneIdx}] Reference video generation result:`, refVideoResult);

                    if (refVideoResult?.operations) {
                        operations.push(...refVideoResult.operations);
                        console.log(`‚úÖ [Scene ${sceneIdx}] Added ${refVideoResult.operations.length} reference video operations`);
                    } else {
                        throw new Error('No operations returned from reference video generation');
                    }
                }
                // Case 0: Extend video (if previousVideoMediaId exists)
                else if (scene.previousVideoMediaId) {
                    console.log(`‚è© [Scene ${sceneIdx}] Mode: EXTEND VIDEO`);
                    console.log(`üìπ [Scene ${sceneIdx}] Source mediaId: ${scene.previousVideoMediaId}`);

                    const extendResponse = await fetch('/api/veo3/extend-video', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            clientContext: {
                                sessionId: `;${Date.now()}`,
                                projectId: currentProjectId,
                                tool: 'PINHOLE',
                                userPaygateTier: 'PAYGATE_TIER_TWO'
                            },
                            requests: seeds.map(seed => ({
                                textInput: { prompt },
                                videoInput: {
                                    mediaId: scene.previousVideoMediaId,
                                    startFrameIndex: 168,
                                    endFrameIndex: 191
                                },
                                videoModelKey: 'veo_3_1_extend_fast_landscape_ultra',
                                aspectRatio,
                                seed,
                                metadata: { sceneId: currentSceneId }
                            }))
                        })
                    });

                    const extendResult = await extendResponse.json();
                    console.log(`‚úÖ [Scene ${sceneIdx}] extendVideo result:`, extendResult);

                    if (extendResult?.operations) {
                        operations.push(...extendResult.operations);
                        console.log(`‚úÖ [Scene ${sceneIdx}] Added ${extendResult.operations.length} extend operations`);
                    }
                }
                // Case 1: Text-to-video (no images - text-only mode)
                else if (!hasStartImage && !hasEndImage) {
                    console.log(`üì∫ [Scene ${sceneIdx}] Mode: TEXT-TO-VIDEO (no images)`);
                    console.log(`üîÑ [Scene ${sceneIdx}] Calling VideoVeo3.textToVideoFlow...`);

                    const result = await window.VideoVeo3.textToVideoFlow({
                        projectId: currentProjectId,
                        prompt,
                        aspectRatio,
                        seeds: seeds,
                        sceneIds: seeds.map(() => currentSceneId)
                    });

                    console.log(`‚úÖ [Scene ${sceneIdx}] textToVideoFlow result:`, result);

                    if (result?.operations) {
                        operations.push(...result.operations);
                        console.log(`‚úÖ [Scene ${sceneIdx}] Added ${result.operations.length} operations`);
                    } else {
                        console.warn(`‚ö†Ô∏è [Scene ${sceneIdx}] No operations returned from textToVideoFlow`);
                    }
                }
                // Case 2: End image only (NOT SUPPORTED)
                else if (!hasStartImage && hasEndImage) {
                    throw new Error('‚ö†Ô∏è End-image-only kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£!\n\nVui l√≤ng upload ·∫£nh v√†o START image ho·∫∑c d√πng text-to-video.');
                }
                // Case 3: Start image + text (image-to-video with start only)
                else if (hasStartImage && !hasEndImage) {
                    console.log(`üñºÔ∏è [Scene ${sceneIdx}] Mode: START-IMAGE-TO-VIDEO`);

                    // Upload start image
                    console.log(`‚¨ÜÔ∏è [Scene ${sceneIdx}] Uploading start image...`);
                    const startUrl = scene.startImage.url || scene.startImage;

                    let startFile;
                    if (startUrl.startsWith('data:')) {
                        const startImageBlob = await dataUrlToBlob(startUrl);
                        startFile = new File([startImageBlob], scene.startImageName || 'start.jpg', { type: 'image/jpeg' });
                    } else {
                        const startImageBlob = await fetch(startUrl).then(r => r.blob());
                        startFile = new File([startImageBlob], scene.startImageName || 'start.jpg', { type: 'image/jpeg' });
                    }

                    const startMedia = await window.VideoVeo3.fileToMediaId(startFile, aspectRatio);
                    console.log(`‚úÖ [Scene ${sceneIdx}] Start image uploaded:`, startMedia.mediaId);

                    // Use universal model key that works for all aspect ratios
                    const videoModelKey = 'veo_3_1_i2v_s_fast_ultra';

                    console.log(`üîÑ [Scene ${sceneIdx}] Generating ${versions} versions with start image (batch API)...`);

                    // Use BATCH API for start image + text
                    const startImageResponse = await fetch('/api/veo3/generate-start-image', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            clientContext: {
                                sessionId: `;${Date.now()}`,
                                projectId: currentProjectId,
                                tool: 'PINHOLE',
                                userPaygateTier: 'PAYGATE_TIER_TWO'
                            },
                            requests: seeds.map(seed => ({
                                aspectRatio,
                                seed,
                                textInput: { prompt },
                                videoModelKey,
                                startImage: { mediaId: startMedia.mediaId },
                                metadata: { sceneId: currentSceneId }
                            }))
                        })
                    });

                    const startImageResult = await startImageResponse.json();
                    console.log(`‚úÖ [Scene ${sceneIdx}] start-image generation result:`, startImageResult);

                    if (startImageResult?.operations) {
                        operations.push(...startImageResult.operations);
                        console.log(`‚úÖ [Scene ${sceneIdx}] Added ${startImageResult.operations.length} operations`);
                    }
                }
                // Case 4: Start + End images (dual image mode)
                else {
                    console.log(`üñºÔ∏è [Scene ${sceneIdx}] Mode: START-END-IMAGE-TO-VIDEO`);

                    let startMedia = null;
                    let endMedia = null;

                    // Upload start image
                    console.log(`‚¨ÜÔ∏è [Scene ${sceneIdx}] Uploading start image...`);
                    const startUrl = scene.startImage.url || scene.startImage;

                    let startFile;
                    if (startUrl.startsWith('data:')) {
                        const startImageBlob = await dataUrlToBlob(startUrl);
                        startFile = new File([startImageBlob], scene.startImageName || 'start.jpg', { type: 'image/jpeg' });
                    } else {
                        const startImageBlob = await fetch(startUrl).then(r => r.blob());
                        startFile = new File([startImageBlob], scene.startImageName || 'start.jpg', { type: 'image/jpeg' });
                    }

                    startMedia = await window.VideoVeo3.fileToMediaId(startFile, aspectRatio);
                    console.log(`‚úÖ [Scene ${sceneIdx}] Start image uploaded:`, startMedia.mediaId);

                    // Upload end image
                    console.log(`‚¨ÜÔ∏è [Scene ${sceneIdx}] Uploading end image...`);
                    const endUrl = scene.endImage.url || scene.endImage;

                    let endFile;
                    if (endUrl.startsWith('data:')) {
                        const endImageBlob = await dataUrlToBlob(endUrl);
                        endFile = new File([endImageBlob], scene.endImageName || 'end.jpg', { type: 'image/jpeg' });
                    } else {
                        const endImageBlob = await fetch(endUrl).then(r => r.blob());
                        endFile = new File([endImageBlob], scene.endImageName || 'end.jpg', { type: 'image/jpeg' });
                    }

                    endMedia = await window.VideoVeo3.fileToMediaId(endFile, aspectRatio);
                    console.log(`‚úÖ [Scene ${sceneIdx}] End image uploaded:`, endMedia.mediaId);

                    // Generate with both images
                    console.log(`üîÑ [Scene ${sceneIdx}] Generating ${versions} versions with start+end images...`);
                    for (let i = 0; i < versions; i++) {
                        console.log(`üîÑ [Scene ${sceneIdx}] Calling startEndFlow for version ${i + 1}/${versions}...`);
                        const result = await window.VideoVeo3.startEndFlow({
                            prompt,
                            startImageMediaId: startMedia?.mediaId,
                            endImageMediaId: endMedia?.mediaId,
                            aspectRatio,
                            durationSec: 8,
                            seed: seeds[i],
                            projectId: currentProjectId,
                            sceneId: currentSceneId
                        });

                        console.log(`‚úÖ [Scene ${sceneIdx}] startEndFlow v${i + 1} result:`, result);

                        if (result?.operations?.[0]) {
                            operations.push(result.operations[0]);
                        }
                    }
                }

                console.log(`üìä [Scene ${sceneIdx}] Total operations to poll: ${operations.length}`);

                // Poll for all results
                const results = [];
                for (let opIdx = 0; opIdx < operations.length; opIdx++) {
                    const op = operations[opIdx];
                    console.log(`‚è≥ [Scene ${sceneIdx}] Polling operation ${opIdx + 1}/${operations.length}: ${op.operation.name}`);
                    try {
                        const opResult = await window.VideoVeo3.pollOperation(op.operation.name, { intervalMs: 3000, maxTries: 100 });
                        console.log(`‚úÖ [Scene ${sceneIdx}] Poll result for op ${opIdx + 1}:`, opResult);
                        console.log(`üîç [Scene ${sceneIdx}] opResult structure check - has video?`, !!opResult?.video);
                        console.log(`üîç [Scene ${sceneIdx}] opResult.video:`, opResult?.video);

                        if (opResult?.video?.url) {
                            results.push({
                                id: Date.now() + results.length,
                                url: opResult.video.url,
                                mediaId: opResult.video.mediaId
                            });
                            console.log(`‚úÖ [Scene ${sceneIdx}] Added video result ${results.length}`);
                        } else {
                            console.warn(`‚ö†Ô∏è [Scene ${sceneIdx}] opResult for op ${opIdx + 1} has no video.url!`);
                            console.warn(`‚ö†Ô∏è [Scene ${sceneIdx}] Full opResult:`, JSON.stringify(opResult, null, 2));
                        }
                    } catch (err) {
                        console.error(`‚ùå [Scene ${sceneIdx}] Failed to poll operation ${opIdx + 1}:`, err);
                        console.error(`‚ùå [Scene ${sceneIdx}] Error details:`, err.message, err.stack);
                    }
                }

                console.log(`üìä [Scene ${sceneIdx}] Polling complete. Results count: ${results.length}/${operations.length}`);

                if (results.length === 0) {
                    console.error(`‚ùå [Scene ${sceneIdx}] ZERO videos generated! Operations count was: ${operations.length}`);
                    console.error(`‚ùå [Scene ${sceneIdx}] All operations:`, JSON.stringify(operations, null, 2));
                    throw new Error('No videos were generated successfully');
                }

                // Save results
                scene.videos = results;
                scene.selectedVideoId = scene.videos[0]?.id;
                scene.status = 'done';

                // AUTO-DOWNLOAD videos to SERVER (not browser - to avoid CORS and losing current tab)
                console.log(`üì• [Scene ${sceneIdx}] Auto-downloading ${results.length} videos to server...`);

                // Download to server in background with proper naming
                for (let variantIdx = 0; variantIdx < results.length; variantIdx++) {
                    const video = results[variantIdx];
                    const mediaId = video.mediaId || `scene${sceneIdx}_v${variantIdx}`;

                    fetch('/api/veo3/download-video', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            fifeUrl: video.url,
                            mediaId: mediaId,
                            sceneIndex: sceneIdx,
                            variantIndex: variantIdx,
                            outputDir: getOutputFolder() // Use custom folder from UI or default
                        })
                    }).then(res => res.json()).then(data => {
                        if (data.success) {
                            const variantLetter = String.fromCharCode(97 + variantIdx);
                            const fileName = `${sceneIdx + 1}${variantLetter}.mp4`;
                            // Map variantIdx to folder: 0 -> main, 1 -> B, 2 -> C, 3 -> D
                            let location;
                            if (variantIdx === 0) {
                                location = 'videos/';
                            } else {
                                const folderLetter = String.fromCharCode(66 + variantIdx - 1); // 66 is 'B'
                                location = `videos/Tuy chon ${folderLetter}/`;
                            }
                            console.log(`   ‚úÖ [Scene ${sceneIdx}] Downloaded ${fileName} to ${location}`);
                            // Update video with localUrl for later use
                            video.localUrl = data.localUrl;
                        } else {
                            console.error(`   ‚ùå [Scene ${sceneIdx}] Download failed: ${data.error}`);
                        }
                    }).catch(err => {
                        console.error(`   ‚ùå [Scene ${sceneIdx}] Download error: ${err.message}`);
                    });
                }

            } catch (err) {
                console.error(`‚ùå [Scene ${sceneIdx}] ERROR (retry ${retryCount}/${maxRetries}):`, err);
                console.error(`‚ùå [Scene ${sceneIdx}] Error message:`, err.message);

                // Retry logic
                if (retryCount < maxRetries) {
                    const delay = (retryCount + 1) * 2000; // 2s, 4s
                    console.log(`‚è≥ [Scene ${sceneIdx}] Waiting ${delay}ms before retry ${retryCount + 1}...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return await generateVideoForScene(sceneIdx, retryCount + 1);
                } else {
                    // All retries failed - mark as failed
                    console.error(`‚ùå‚ùå‚ùå [Scene ${sceneIdx}] All ${maxRetries} retries FAILED`);
                    scene.status = 'failed';
                    scene.error = err.message || 'Failed after 2 retries';
                    scene.retryable = true; // Mark for manual retry
                }
            }

            renderVideoScenes();
        }

        // Test generate video from MediaID
        async function testGenerateFromMediaId() {
            console.log('üß™ [testGenerateFromMediaId] Starting test...');

            const startMediaId = document.getElementById('testStartMediaId').value.trim();
            const endMediaId = document.getElementById('testEndMediaId').value.trim();
            const prompt = document.getElementById('testPrompt').value.trim();
            const testResult = document.getElementById('testResult');

            if (!startMediaId || !endMediaId) {
                alert('‚ö†Ô∏è Please provide both Start and End MediaID!');
                return;
            }

            if (!prompt) {
                alert('‚ö†Ô∏è Please provide a prompt!');
                return;
            }

            if (!currentProjectId || !currentSceneId) {
                alert('‚ö†Ô∏è Please setup Project ID and Scene ID first!');
                return;
            }

            testResult.style.display = 'block';
            testResult.innerHTML = '‚è≥ Testing video generation...';

            try {
                const aspectRatio = document.getElementById('videoAspectRatio').value || 'VIDEO_ASPECT_RATIO_LANDSCAPE';
                const seeds = [Math.floor(Math.random() * 65536), Math.floor(Math.random() * 65536)];

                console.log('üöÄ Sending request to /api/veo3/generate-start-end');
                console.log('   startMediaId:', startMediaId);
                console.log('   endMediaId:', endMediaId);
                console.log('   prompt:', prompt);
                console.log('   projectId:', currentProjectId);
                console.log('   sceneId:', currentSceneId);
                console.log('   aspectRatio:', aspectRatio);

                const response = await fetch('/api/veo3/generate-start-end', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        projectId: currentProjectId,
                        sceneId: currentSceneId,
                        startImageMediaId: startMediaId,
                        endImageMediaId: endMediaId,
                        prompt: prompt,
                        aspectRatio: aspectRatio,
                        seeds: seeds
                    })
                });

                const result = await response.json();
                console.log('üì• Response:', result);

                if (result.success) {
                    testResult.style.background = 'rgba(52, 168, 83, 0.1)';
                    testResult.style.borderColor = 'var(--success-color)';
                    testResult.innerHTML = `
                        ‚úÖ <strong>Success!</strong><br>
                        Generated ${result.operations?.length || 0} video variant(s)<br>
                        <pre style="margin-top: 6px; font-size: 10px; background: var(--bg-card); padding: 6px; border-radius: 4px; overflow-x: auto; max-height: 200px;">${JSON.stringify(result, null, 2)}</pre>
                    `;
                } else {
                    testResult.style.background = 'rgba(234, 67, 53, 0.1)';
                    testResult.style.borderColor = 'var(--danger-color)';
                    testResult.innerHTML = `
                        ‚ùå <strong>Failed!</strong><br>
                        Error: ${result.error || 'Unknown error'}<br>
                        <pre style="margin-top: 6px; font-size: 10px; background: var(--bg-card); padding: 6px; border-radius: 4px; overflow-x: auto;">${JSON.stringify(result, null, 2)}</pre>
                    `;
                }
            } catch (error) {
                console.error('‚ùå Test error:', error);
                testResult.style.background = 'rgba(234, 67, 53, 0.1)';
                testResult.style.borderColor = 'var(--danger-color)';
                testResult.innerHTML = `‚ùå <strong>Error:</strong> ${error.message}`;
            }
        }

        // Generate all videos
        async function generateAllVideos() {
            console.log('üé¨ [generateAllVideos] Starting...');

            if (videoScenes.length === 0) {
                alert('‚ö†Ô∏è No scenes to generate!');
                return;
            }

            if (!currentProjectId || !currentSceneId) {
                alert('‚ö†Ô∏è Please setup Project ID and Scene ID first!');
                return;
            }

            // Update prompts from textarea inputs first
            videoScenes.forEach((scene, idx) => {
                const promptInput = document.getElementById(`scenePrompt${idx}`);
                if (promptInput) {
                    scene.prompt = promptInput.value.trim();
                }
            });

            // Auto-detect mentions and convert to Reference to Video mode
            let hasInvalidMentions = false;
            videoScenes.forEach((scene, idx) => {
                if (scene.prompt && scene.prompt.trim() !== '') {
                    const result = autoConvertToReferenceMode(idx);
                    if (result === false) {
                        // Validation failed (too many mentions)
                        hasInvalidMentions = true;
                    }
                }
            });

            // Stop if any scene has invalid mentions
            if (hasInvalidMentions) {
                return;
            }

            // Check if at least one scene has a prompt
            const hasPrompts = videoScenes.some(s => s.prompt && s.prompt.trim() !== '');
            if (!hasPrompts) {
                alert('‚ö†Ô∏è Please add prompts to scenes first!');
                return;
            }

            const btn = document.getElementById('genAllVideosBtn');
            if (!btn) return;

            const originalText = btn.textContent;
            btn.disabled = true;

            // Show progress bar
            const progressDiv = document.getElementById('generateProgress');
            const progressText = document.getElementById('generateProgressText');
            const progressPercent = document.getElementById('generateProgressPercent');
            const progressBar = document.getElementById('generateProgressBar');
            const progressDetail = document.getElementById('generateProgressDetail');

            if (progressDiv) {
                progressDiv.style.display = 'block';
            }

            let successCount = 0;
            let errorCount = 0;
            let skippedCount = 0;

            // Separate scenes into extend and non-extend
            const extendScenes = [];
            const normalScenes = [];

            videoScenes.forEach((scene, idx) => {
                // Skip scenes without prompt
                if (!scene.prompt || scene.prompt.trim() === '') {
                    console.log(`Skipping scene ${idx + 1}: no prompt`);
                    skippedCount++;
                    return;
                }

                // Skip scenes already generating
                if (scene.status === 'generating') {
                    console.log(`Skipping scene ${idx + 1}: already generating`);
                    skippedCount++;
                    return;
                }

                // Skip scenes that already have videos (status=done and has videos)
                if (scene.status === 'done' && scene.videos && scene.videos.length > 0) {
                    console.log(`‚úì Skipping scene ${idx + 1}: already has ${scene.videos.length} video(s)`);
                    skippedCount++;
                    return;
                }

                if (scene.previousVideoMediaId) {
                    extendScenes.push(idx);
                } else {
                    normalScenes.push(idx);
                }
            });

            const totalScenes = extendScenes.length + normalScenes.length;
            let completedScenes = 0;

            // Helper to update button text and progress bar
            const updateProgress = (detail = '') => {
                btn.textContent = `‚è≥ Generating ${completedScenes}/${totalScenes}...`;

                // Update progress bar
                if (progressText) progressText.textContent = `‚è≥ ƒêang generate: ${completedScenes}/${totalScenes}`;
                if (progressPercent) {
                    const percent = totalScenes > 0 ? Math.round((completedScenes / totalScenes) * 100) : 0;
                    progressPercent.textContent = `${percent}%`;
                }
                if (progressBar) {
                    const percent = totalScenes > 0 ? (completedScenes / totalScenes) * 100 : 0;
                    progressBar.style.width = `${percent}%`;
                }
                if (progressDetail && detail) {
                    progressDetail.textContent = detail;
                }
            };

            // Timeout monitoring for stuck scenes (5 minutes)
            const TIMEOUT_MS = 5 * 60 * 1000; // 5 minutes
            const timeoutMonitor = setInterval(() => {
                videoScenes.forEach((scene, idx) => {
                    if (scene.status === 'generating' && scene.generationStartTime) {
                        const elapsed = Date.now() - scene.generationStartTime;
                        if (elapsed > TIMEOUT_MS) {
                            const elapsedMin = Math.floor(elapsed / 1000 / 60);
                            console.warn(`‚è∞ [Scene ${idx + 1}] TIMEOUT detected (${elapsedMin}min) - retrying...`);

                            // Reset timer and retry
                            scene.generationStartTime = Date.now();
                            generateVideoForScene(idx).catch(err => {
                                console.error(`‚ùå [Scene ${idx + 1}] Timeout retry failed:`, err);
                            });
                        }
                    }
                });
            }, 30000); // Check every 30 seconds

            // Process normal scenes with concurrent threads (staggered starts)
            if (normalScenes.length > 0) {
                const batchQuantityElement = document.getElementById('videoBatchQuantity');
                const maxParallel = batchQuantityElement ? parseInt(batchQuantityElement.value) : 10;
                console.log(`üé¨ Processing ${normalScenes.length} normal scenes with ${maxParallel} parallel threads (staggered 2s apart)`);
                updateProgress();

                const processScene = async (sceneIdx, delay = 0) => {
                    // Add staggered delay before starting
                    if (delay > 0) {
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }

                    try {
                        // Track start time when generation begins
                        videoScenes[sceneIdx].generationStartTime = Date.now();

                        await generateVideoForScene(sceneIdx);

                        // Clear start time when done
                        delete videoScenes[sceneIdx].generationStartTime;

                        if (videoScenes[sceneIdx].status === 'done') {
                            successCount++;
                        } else if (videoScenes[sceneIdx].status === 'error') {
                            errorCount++;
                        }
                    } catch (err) {
                        console.error(`Error generating scene ${sceneIdx + 1}:`, err);
                        videoScenes[sceneIdx].status = 'error';
                        videoScenes[sceneIdx].error = err.message || 'Unknown error';
                        delete videoScenes[sceneIdx].generationStartTime;
                        errorCount++;
                    } finally {
                        completedScenes++;
                        updateProgress();
                    }
                };

                // Process in batches with 2-second stagger between each scene start
                const BATCH_SIZE = batchQuantityElement ? parseInt(batchQuantityElement.value) : 10; // Use dropdown value or default to 10
                const STAGGER_DELAY = 2000; // 2 seconds between each scene start

                for (let i = 0; i < normalScenes.length; i += BATCH_SIZE) {
                    const batch = normalScenes.slice(i, i + BATCH_SIZE);

                    console.log(`üì¶ Starting batch ${Math.floor(i / BATCH_SIZE) + 1}: ${batch.length} scenes (staggered 2s apart)`);

                    // Start each scene in the batch with a staggered delay
                    const batchPromises = batch.map((sceneIdx, batchIndex) => {
                        const delay = batchIndex * STAGGER_DELAY;
                        return processScene(sceneIdx, delay);
                    });

                    // Wait for all scenes in this batch to complete
                    await Promise.all(batchPromises);

                    console.log(`‚úÖ Batch ${Math.floor(i / BATCH_SIZE) + 1} completed`);
                }
            }

            // Stop timeout monitor
            clearInterval(timeoutMonitor);

            // Process extend scenes sequentially (they depend on previous videos)
            if (extendScenes.length > 0) {
                console.log(`‚è© Processing ${extendScenes.length} extend scenes sequentially`);

                for (const sceneIdx of extendScenes) {
                    updateProgress();

                    try {
                        await generateVideoForScene(sceneIdx);
                        if (videoScenes[sceneIdx].status === 'done') {
                            successCount++;
                        } else if (videoScenes[sceneIdx].status === 'error') {
                            errorCount++;
                        }
                    } catch (err) {
                        console.error(`Error generating scene ${sceneIdx + 1}:`, err);
                        videoScenes[sceneIdx].status = 'error';
                        videoScenes[sceneIdx].error = err.message || 'Unknown error';
                        errorCount++;
                    } finally {
                        completedScenes++;
                        updateProgress();
                    }

                    // Delay between extend scenes (increased to avoid rate limit)
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }
            }

            btn.disabled = false;
            btn.textContent = originalText;

            // Hide progress bar
            if (progressDiv) {
                progressDiv.style.display = 'none';
            }

            let message = `‚úÖ Generation complete!\n\n`;
            if (successCount > 0) message += `‚úì Success: ${successCount}\n`;
            if (errorCount > 0) message += `‚úó Error: ${errorCount}\n`;
            if (skippedCount > 0) message += `‚äò Skipped: ${skippedCount}`;

            alert(message);
            renderVideoScenes();

            // Show "Check Error" buttons after generation completes
            const checkErrorButtons = document.getElementById('checkErrorButtons');
            if (checkErrorButtons) {
                checkErrorButtons.style.display = 'flex';
                console.log('‚úÖ Check Error buttons now visible');
            }
        }

        // Sync videos from Google project
        async function syncVideosFromGoogle() {
            if (!currentProjectId) {
                alert('‚ö†Ô∏è Please setup Project ID first!');
                return;
            }

            const btn = document.getElementById('syncVideosBtn');
            if (!btn) return;

            const originalText = btn.textContent;
            btn.disabled = true;
            btn.textContent = '‚è≥ Syncing...';

            try {
                console.log('üîÑ Syncing videos from Google project:', currentProjectId);

                // Get project data from Google
                const response = await fetch('/api/veo3/get-project', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ projectId: currentProjectId })
                });

                const result = await response.json();

                if (!result.success) {
                    if (result.tokenExpired) {
                        alert('‚ö†Ô∏è TOKEN ƒê√É H·∫æT H·∫†N!\n\nVui l√≤ng:\n1. Click n√∫t "B·∫Øt Token" ·ªü tab Settings\n2. Sau ƒë√≥ th·ª≠ l·∫°i');
                    } else {
                        throw new Error(result.error || 'Failed to get project data');
                    }
                    return;
                }

                const projectData = result.project;
                console.log('‚úÖ Project data:', projectData);

                // Parse scenes and clips
                if (!projectData.scenes || projectData.scenes.length === 0) {
                    alert('‚ÑπÔ∏è Project kh√¥ng c√≥ scene n√†o. H√£y t·∫°o video tr∆∞·ªõc.');
                    return;
                }

                let syncedCount = 0;
                let newVideoCount = 0;

                // Process each scene
                projectData.scenes.forEach((googleScene, sceneIdx) => {
                    if (!googleScene.clips || googleScene.clips.length === 0) {
                        return; // Skip empty scenes
                    }

                    // Find matching scene in videoScenes (by index or sceneId)
                    let localScene = videoScenes[sceneIdx];

                    if (!localScene) {
                        console.log(`‚ö†Ô∏è Scene ${sceneIdx} not found in local data, skipping`);
                        return;
                    }

                    // Extract videos from clips
                    const videos = [];
                    googleScene.clips.forEach(clip => {
                        if (clip.video && clip.video.fifeUrl) {
                            videos.push({
                                url: clip.video.fifeUrl,
                                mediaId: clip.video.mediaGenerationId,
                                seed: clip.video.seed
                            });
                            newVideoCount++;
                        }
                    });

                    if (videos.length > 0) {
                        localScene.videos = videos;
                        localScene.status = 'done';
                        localScene.error = null;
                        syncedCount++;
                        console.log(`‚úÖ Scene ${sceneIdx + 1}: Synced ${videos.length} videos`);
                    }
                });

                renderVideoScenes();

                alert(`‚úÖ Sync th√†nh c√¥ng!\n\nüìä T·ªïng k·∫øt:\n- ${syncedCount} scenes c√≥ video\n- ${newVideoCount} videos ƒë∆∞·ª£c sync`);

            } catch (err) {
                console.error('‚ùå Sync failed:', err);
                alert('‚ùå L·ªói khi sync: ' + err.message);
            } finally {
                btn.disabled = false;
                btn.textContent = originalText;
            }
        }

        // Download ALL videos (not just selected)
        async function downloadAllVideos() {
            // Collect ALL videos from all scenes
            const allVideos = [];

            videoScenes.forEach((scene, sceneIdx) => {
                if (scene.videos && scene.videos.length > 0) {
                    scene.videos.forEach((video, variantIdx) => {
                        const variantLetter = String.fromCharCode(97 + variantIdx); // a, b, c, d...
                        const isVariantA = variantIdx === 0; // First variant = 'a'

                        allVideos.push({
                            url: video.url,
                            sceneIndex: sceneIdx + 1, // 1-based index
                            variantLetter: variantLetter,
                            isVariantA: isVariantA,
                            // Simple naming: 1a.mp4, 1b.mp4, 2a.mp4, 2b.mp4, etc.
                            fileName: `${sceneIdx + 1}${variantLetter}.mp4`,
                            displayName: `${sceneIdx + 1}${variantLetter}.mp4`
                        });
                    });
                }
            });

            if (allVideos.length === 0) {
                alert('‚ö†Ô∏è No videos to download! Generate some videos first.');
                return;
            }

            // Log download info
            const variantACount = allVideos.filter(v => v.isVariantA).length;
            const variantOtherCount = allVideos.length - variantACount;

            console.log(`üì• Downloading ALL ${allVideos.length} videos: ${variantACount} variant 'a' + ${variantOtherCount} other variants`);

            // Show progress UI
            showDownloadProgress();

            // Download ALL videos
            let completed = 0;
            const total = allVideos.length;

            for (const video of allVideos) {
                try {
                    // Update progress
                    updateDownloadProgress(completed, total, video.displayName, 'pending');

                    // Direct download
                    triggerBrowserDownload(video);
                    completed++;
                    updateDownloadProgress(completed, total, video.displayName, 'done');

                    // Delay between downloads
                    await new Promise(resolve => setTimeout(resolve, 800));

                } catch (err) {
                    console.error(`‚ùå Error downloading ${video.fileName}:`, err);
                    completed++;
                    updateDownloadProgress(completed, total, video.displayName, 'error');
                }
            }

            console.log(`‚úÖ Download complete! ${completed}/${total} videos downloaded successfully.`);
            // Keep progress window open for user to see results
        }

        // Helper: Trigger browser download (only from server - no GCS direct link)
        function triggerBrowserDownload(video) {
            // Only download if localUrl exists (downloaded to server)
            if (video.localUrl) {
                const link = document.createElement('a');
                link.href = video.localUrl;
                link.download = `video_${video.mediaId || Date.now()}.mp4`;
                link.style.display = 'none';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                console.log(`‚úÖ Downloading from server: ${video.localUrl}`);
            } else {
                console.warn(`‚ö†Ô∏è Video not downloaded to server yet. Auto-download in progress...`);
                // Silently ignore - auto-download will handle it
            }
        }

        // Upload image to Veo3
        async function uploadImageToVeo3(imageUrl, aspectRatio) {
            const response = await fetch(imageUrl);
            const blob = await response.blob();
            const base64 = await new Promise((resolve) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.readAsDataURL(blob);
            });

            const uploadRes = await fetch('/api/veo3/upload-cropped-image', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ imageBase64: base64, aspectRatio })
            });

            const uploadData = await uploadRes.json();
            if (!uploadData.success) throw new Error('Image upload failed');

            return uploadData.mediaId;
        }

        // Poll video generation status
        async function pollVideoStatus(operations, maxTries = 60, intervalMs = 5000) {
            for (let i = 0; i < maxTries; i++) {
                const response = await fetch('/api/veo3/check-status', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ operations })
                });

                const data = await response.json();
                const ops = data.operations;

                const allDone = ops.every(op =>
                    op.status === 'MEDIA_GENERATION_STATUS_SUCCESSFUL' ||
                    op.status === 'MEDIA_GENERATION_STATUS_FAILED'
                );

                if (allDone) {
                    // Download videos to server and open in new tabs
                    const successfulOps = ops.filter(op => op.status === 'MEDIA_GENERATION_STATUS_SUCCESSFUL');

                    console.log(`‚úÖ ${successfulOps.length} videos ready! Downloading to server...`);

                    // Download all videos to server first
                    const videos = await Promise.all(successfulOps.map(async (op, index) => {
                        const fifeUrl = op.video.url;
                        const mediaId = op.video.mediaId;

                        try {
                            console.log(`üì• [${index + 1}/${successfulOps.length}] Downloading: ${mediaId.substring(0, 20)}...`);

                            const res = await fetch('/api/veo3/download-video', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    fifeUrl,
                                    mediaId,
                                    outputDir: getOutputFolder() // Use custom folder from UI or default
                                })
                            });
                            const data = await res.json();

                            if (data.success) {
                                console.log(`   ‚úÖ Downloaded: ${data.localUrl} ${data.cached ? '(cached)' : '(' + (data.size / 1024 / 1024).toFixed(2) + ' MB)'}`);

                                return {
                                    url: fifeUrl,
                                    mediaId: mediaId,
                                    localUrl: data.localUrl,
                                    downloaded: true
                                };
                            } else {
                                console.error(`   ‚ùå Download failed: ${data.error}`);
                                return {
                                    url: fifeUrl,
                                    mediaId: mediaId,
                                    downloaded: false
                                };
                            }
                        } catch (err) {
                            console.error(`   ‚ùå Error: ${err.message}`);
                            return {
                                url: fifeUrl,
                                mediaId: mediaId,
                                downloaded: false
                            };
                        }
                    }));

                    const downloadedCount = videos.filter(v => v.downloaded).length;
                    console.log(`\nüéâ Downloaded ${downloadedCount}/${videos.length} videos to server!`);
                    console.log(`üìÅ Videos saved to /videos/ folder. Use "Download All" button to save to your computer.`);

                    return videos;
                }

                await new Promise(resolve => setTimeout(resolve, intervalMs));
            }

            throw new Error('Timeout waiting for video generation');
        }

        // Update generate button state when images change
        function updateVideoButton() {
            const btn = document.getElementById('saveVideoBtn');
            if (btn) {
                btn.disabled = images.length < 2;
            }
        }

        // Call this whenever images array changes
        // Add to existing image rendering functions
    </script>

    <!-- Video Modules -->
    <!-- Autocomplete Dropdown for @mentions -->
    <div id="mentionAutocomplete" class="mention-autocomplete">
        <!-- Will be populated by JavaScript -->
    </div>

    <script type="module">
        import { VideoVeo3 } from './video-veo3.js';
        import { VideoOrchestrator } from './video.js';

        // Expose to global scope for inline event handlers
        window.VideoVeo3 = VideoVeo3;
        window.VideoOrchestrator = VideoOrchestrator;
    </script>
</body>
</html>
