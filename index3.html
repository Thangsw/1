<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Whisk + Veo3 - Auto Workflow</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #333;
      min-height: 100vh;
      padding: 0;
      overflow-x: hidden;
    }

    .container {
      width: 100%;
      min-height: 100vh;
      background: white;
    }

    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px 30px;
      text-align: center;
    }

    .header h1 {
      font-size: 2em;
      margin-bottom: 5px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
    }

    .header p {
      font-size: 1em;
      opacity: 0.9;
    }

    .main-content {
      display: grid;
      grid-template-columns: 350px 1fr 300px;
      gap: 20px;
      padding: 20px;
      min-height: calc(100vh - 100px);
    }

    .sidebar {
      display: flex;
      flex-direction: column;
      gap: 15px;
      height: fit-content;
      position: sticky;
      top: 20px;
    }

    .error-sidebar {
      display: flex;
      flex-direction: column;
      gap: 15px;
      height: fit-content;
      position: sticky;
      top: 20px;
    }

    .section {
      background: #f8f9fa;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .section h2 {
      color: #667eea;
      margin-bottom: 15px;
      font-size: 1.2em;
      border-bottom: 2px solid #667eea;
      padding-bottom: 8px;
    }

    .input-group {
      margin-bottom: 12px;
    }

    .input-group label {
      display: block;
      font-weight: 600;
      margin-bottom: 6px;
      color: #555;
      font-size: 0.9em;
    }

    .input-group input,
    .input-group textarea,
    .input-group select {
      width: 100%;
      padding: 8px 10px;
      border: 2px solid #ddd;
      border-radius: 6px;
      font-size: 0.9em;
      transition: border-color 0.3s;
    }

    .input-group input:focus,
    .input-group textarea:focus,
    .input-group select:focus {
      outline: none;
      border-color: #667eea;
    }

    .input-group textarea {
      min-height: 100px;
      resize: vertical;
      font-family: 'Courier New', monospace;
      font-size: 0.85em;
    }

    .input-group input[type="checkbox"] {
      width: auto;
      margin-right: 8px;
    }

    .checkbox-label {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      padding: 8px;
      background: white;
      border-radius: 6px;
      transition: background 0.3s;
    }

    .checkbox-label:hover {
      background: #e9ecef;
    }

    .btn {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      font-size: 0.9em;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      width: 100%;
      margin-bottom: 8px;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    .btn:active {
      transform: translateY(0);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .btn-success {
      background: linear-gradient(135deg, #56ab2f 0%, #a8e063 100%);
      color: white;
    }

    .btn-danger {
      background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
      color: white;
    }

    .btn-warning {
      background: linear-gradient(135deg, #f2994a 0%, #f2c94c 100%);
      color: white;
    }

    .btn-info {
      background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
      color: white;
    }

    .btn-small {
      padding: 4px 8px;
      font-size: 0.75em;
      margin-bottom: 4px;
    }

    .status-bar {
      background: #e9ecef;
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 12px;
      display: flex;
      justify-content: space-around;
      align-items: center;
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 0.85em;
    }

    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #ccc;
      animation: pulse 2s infinite;
    }

    .status-dot.active {
      background: #56ab2f;
    }

    .status-dot.error {
      background: #eb3349;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .log-console-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .log-console {
      background: #1e1e1e;
      color: #d4d4d4;
      border-radius: 8px;
      padding: 12px;
      max-height: 400px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 0.8em;
    }

    .log-console-title {
      font-weight: 600;
      color: #667eea;
      margin-bottom: 8px;
      padding-bottom: 5px;
      border-bottom: 1px solid #333;
    }

    .log-entry {
      padding: 3px 0;
      border-bottom: 1px solid #333;
    }

    .log-entry:last-child {
      border-bottom: none;
    }

    .log-time {
      color: #858585;
      margin-right: 8px;
    }

    .log-info { color: #4ec9b0; }
    .log-success { color: #56ab2f; }
    .log-warning { color: #f2994a; }
    .log-error { color: #eb3349; }

    .gallery {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 12px;
      margin-top: 12px;
      max-height: 350px;
      overflow-y: auto;
    }

    .gallery-item {
      position: relative;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      transition: transform 0.3s;
      background: white;
    }

    .gallery-item:hover {
      transform: translateY(-3px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }

    .gallery-item img,
    .gallery-item video {
      width: 100%;
      height: 150px;
      object-fit: cover;
    }

    .gallery-item-info {
      padding: 8px;
      font-size: 0.75em;
      background: #f8f9fa;
    }

    .gallery-item-info .label {
      font-weight: 600;
      color: #667eea;
    }

    .progress-bar {
      width: 100%;
      height: 20px;
      background: #e9ecef;
      border-radius: 10px;
      overflow: hidden;
      margin: 10px 0;
      box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
      transition: width 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 600;
      font-size: 0.85em;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
      margin-bottom: 12px;
    }

    .stat-card {
      background: white;
      padding: 12px;
      border-radius: 8px;
      text-align: center;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .stat-card .number {
      font-size: 1.6em;
      font-weight: 700;
      color: #667eea;
      margin-bottom: 3px;
    }

    .stat-card .label {
      font-size: 0.75em;
      color: #777;
      text-transform: uppercase;
    }

    .info-box {
      background: #e3f2fd;
      border-left: 3px solid #2196f3;
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 12px;
      font-size: 0.85em;
    }

    .info-box strong {
      color: #1976d2;
    }

    .info-box code {
      background: rgba(0,0,0,0.1);
      padding: 2px 5px;
      border-radius: 3px;
      font-family: monospace;
    }

    .error-item {
      background: #fff5f5;
      border-left: 3px solid #eb3349;
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 8px;
      font-size: 0.85em;
    }

    .error-item .error-title {
      font-weight: 600;
      color: #eb3349;
      margin-bottom: 5px;
    }

    .error-item .error-msg {
      color: #666;
      margin-bottom: 8px;
      font-size: 0.9em;
    }

    .queue-item {
      background: #e3f2fd;
      border-left: 3px solid #2196f3;
      padding: 8px;
      border-radius: 4px;
      margin-bottom: 6px;
      font-size: 0.8em;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .queue-item .spinner {
      width: 16px;
      height: 16px;
      border: 2px solid #2196f3;
      border-top-color: transparent;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .prompt-textarea-container {
      position: relative;
    }

    .submit-btn-container {
      margin-top: 8px;
      display: flex;
      gap: 8px;
    }

    @media (max-width: 1400px) {
      .main-content {
        grid-template-columns: 300px 1fr;
      }

      .error-sidebar {
        grid-column: 1 / -1;
        position: relative;
        top: 0;
      }
    }

    @media (max-width: 1024px) {
      .main-content {
        grid-template-columns: 1fr;
      }

      .sidebar {
        position: relative;
        top: 0;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üé® Whisk + Veo3 - Auto Workflow v2</h1>
      <p>Parallel queues ‚Ä¢ Retry mechanism ‚Ä¢ Error tracking ‚Ä¢ Session save ‚Ä¢ Continuous workflow</p>
    </div>

    <div class="main-content">
      <!-- Left Sidebar - Settings -->
      <div class="sidebar">
        <!-- Quick Links -->
        <div class="section">
          <h2>üîó Quick Links</h2>

          <a href="lanes-manager.html" class="btn btn-primary" style="text-decoration: none; display: block; text-align: center;">‚öôÔ∏è Qu·∫£n l√Ω Lanes</a>
          <a href="index4.html" class="btn btn-info" style="text-decoration: none; display: block; text-align: center;">üß™ Test (Index4)</a>

          <div style="font-size: 0.75em; color: #777; margin-top: 8px;">
            üí° Qu·∫£n l√Ω lanes: Th√™m/s·ª≠a/x√≥a lanes v·ªõi authorization token<br>
            üí° Index4: Test ƒëa lu·ªìng (multi-lane)
          </div>
        </div>

        <!-- Chrome & Lanes -->
        <div class="section">
          <h2>üîß Chrome & Lanes</h2>

          <div class="input-group" style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
            <button class="btn btn-primary" onclick="launchChromeIndex3()">üöÄ M·ªü Chrome (Temp)</button>
            <button class="btn btn-warning" onclick="captureTokenIndex3()">üîë B·∫Øt Token</button>
          </div>
          <div style="font-size: 0.75em; color: #777; margin-top: 4px;">
            Chrome s·∫Ω m·ªü session t·∫°m th·ªùi (temp profile)
          </div>

          <div class="input-group">
            <label>Ch·ªçn Lane ƒë·ªÉ gen ·∫£nh</label>
            <select id="selectedLane" onchange="loadLaneIndex3()">
              <option value="">-- Session hi·ªán t·∫°i --</option>
            </select>
            <div style="font-size: 0.75em; color: #777; margin-top: 4px;">
              Ch·ªçn lane t·ª´ tokens.xlsx ho·∫∑c d√πng session hi·ªán t·∫°i
            </div>
          </div>

          <div id="laneStatus" style="font-size: 0.8em; margin-top: 8px; padding: 6px; border-radius: 4px; display: none;"></div>
        </div>

        <!-- Project Settings -->
        <div class="section">
          <h2>üìÅ Project Settings</h2>

          <div class="input-group">
            <label>Project Link (auto-parse c·∫£ Scene ID)</label>
            <input type="text" id="projectLink" placeholder="Paste link t·ª´ Veo3 Flow...">
            <button class="btn btn-success" onclick="parseProjectLink()" style="margin-top: 8px;">üîç Parse Link</button>
          </div>

          <div class="input-group">
            <label>Project ID</label>
            <input type="text" id="projectId" placeholder="Auto-filled t·ª´ link...">
          </div>

          <div class="input-group">
            <label>Scene ID (nh·∫≠p th·ªß c√¥ng n·∫øu c·∫ßn)</label>
            <input type="text" id="sceneId" placeholder="Auto-filled ho·∫∑c nh·∫≠p th·ªß c√¥ng...">
          </div>

          <div class="input-group">
            <label>Aspect Ratio</label>
            <select id="aspectRatio">
              <option value="IMAGE_ASPECT_RATIO_LANDSCAPE">Landscape (16:9)</option>
              <option value="IMAGE_ASPECT_RATIO_PORTRAIT">Portrait (9:16)</option>
              <option value="IMAGE_ASPECT_RATIO_SQUARE">Square (1:1)</option>
            </select>
          </div>

          <button class="btn btn-success" onclick="loadSession()">‚úÖ X√°c nh·∫≠n Project</button>
        </div>

        <!-- Save Paths -->
        <div class="section">
          <h2>üíæ Auto-Save Paths</h2>

          <div class="input-group">
            <label>Th∆∞ m·ª•c l∆∞u ·∫£nh</label>
            <input type="text" id="imageSavePath" placeholder="C:\K√™nh\Void Chaser\" value="C:\K√™nh\Void Chaser\">
          </div>

          <div class="input-group">
            <label>T√™n Project ·∫£nh (folder) - B·∫ÆT BU·ªòC</label>
            <input type="text" id="imageProjectName" placeholder="MyProject">
          </div>

          <div class="info-box">
            <strong>üí° ·∫¢nh:</strong> <code>[Path]\[Project]\1.jpg, 2.jpg...</code>
          </div>

          <div class="input-group">
            <label>Th∆∞ m·ª•c l∆∞u video</label>
            <input type="text" id="videoSavePath" placeholder="C:\K√™nh\Void Chaser\" value="C:\K√™nh\Void Chaser\">
          </div>

          <div class="input-group">
            <label>T√™n Project video (folder) - B·∫ÆT BU·ªòC</label>
            <input type="text" id="videoProjectName" placeholder="MyVideoProject">
          </div>

          <div class="info-box">
            <strong>üí° Video:</strong> <code>[Path]\[Project]\1a.mp4</code><br>
            <strong>üìÅ Ch·ªâ hi·ªán variant A</strong>
          </div>
        </div>

        <!-- Session Management -->
        <div class="section">
          <h2>üíæ Session</h2>
          <button class="btn btn-success" onclick="saveSession()">üíæ L∆∞u Session</button>
          <button class="btn btn-info" onclick="loadSavedSession()">üì• Load Session</button>
          <div style="font-size: 0.75em; color: #777; margin-top: 8px;">
            T·ª± ƒë·ªông l∆∞u state ƒë·ªÉ ph√≤ng m·∫•t ƒëi·ªán
          </div>
        </div>

        <!-- Statistics -->
        <div class="section">
          <h2>üìä Th·ªëng k√™</h2>

          <div class="stats-grid">
            <div class="stat-card">
              <div class="number" id="imageCount">0</div>
              <div class="label">·∫¢nh</div>
            </div>
            <div class="stat-card">
              <div class="number" id="videoCount">0</div>
              <div class="label">Video</div>
            </div>
            <div class="stat-card">
              <div class="number" id="imageQueueCount">0</div>
              <div class="label">Img Q</div>
            </div>
            <div class="stat-card">
              <div class="number" id="videoQueueCount">0</div>
              <div class="label">Vid Q</div>
            </div>
          </div>

          <div style="margin-bottom: 8px;">
            <div style="font-size: 0.75em; color: #667eea; margin-bottom: 4px; font-weight: 600;">üñºÔ∏è Image Progress</div>
            <div class="progress-bar">
              <div class="progress-fill" id="progressBar" style="width: 0%;">0%</div>
            </div>
          </div>

          <div>
            <div style="font-size: 0.75em; color: #667eea; margin-bottom: 4px; font-weight: 600;">üé¨ Video Progress</div>
            <div class="progress-bar">
              <div class="progress-fill" id="videoProgressBar" style="width: 0%;">0%</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Main Content -->
      <div style="display: flex; flex-direction: column; gap: 15px;">
        <!-- Workflow Control -->
        <div class="section">
          <h2>üéÆ Workflow Control</h2>

          <div class="info-box">
            <strong>üîÑ Parallel Workflow:</strong> Image queue li√™n t·ª•c gen ·∫£nh 1,2,3,4... || Video queue t·ª± ƒë·ªông gen khi c√≥ 2 ·∫£nh li√™n ti·∫øp (kh√¥ng ƒë·ª£i)
          </div>

          <div style="display: flex; gap: 8px; margin-bottom: 8px;">
            <button class="btn btn-success" onclick="startWorkflow()" id="startBtn" style="flex: 1;">‚ñ∂Ô∏è START</button>
            <button class="btn btn-danger" onclick="stopWorkflow()" id="stopBtn" disabled style="flex: 1;">‚èπÔ∏è STOP</button>
          </div>
          <div style="display: flex; gap: 8px;">
            <button class="btn btn-warning" onclick="pauseWorkflow()" id="pauseBtn" disabled style="flex: 1;">‚è∏Ô∏è PAUSE</button>
            <button class="btn btn-info" onclick="resumeWorkflow()" id="resumeBtn" disabled style="flex: 1;">‚ñ∂Ô∏è RESUME</button>
            <button class="btn btn-warning" onclick="clearAll()" style="flex: 1;">üóëÔ∏è Clear</button>
          </div>
        </div>

        <!-- Image Prompts -->
        <div class="section" style="background: linear-gradient(135deg, #e3f2fd 0%, #e1f5fe 100%); border: 2px solid #2196f3;">
          <h2>üñºÔ∏è Image Prompts</h2>
          <div style="font-size: 0.85em; color: #777; margin-bottom: 8px;">Auto-detect: 1., 2., #1:, Prompt 1:, etc.</div>

          <div class="input-group">
            <label>Prompts (m·ªói d√≤ng 1 prompt)</label>
            <div class="prompt-textarea-container">
              <textarea id="imagePrompts" placeholder="1. A beautiful sunset over mountains
2. The same scene at night with stars
3. A cat playing with yarn
4. The cat sleeping peacefully

Ho·∫∑c:
Prompt 1: A beautiful sunset
#2: Night scene"></textarea>
            </div>
            <div class="submit-btn-container">
              <button class="btn btn-success btn-small" onclick="submitImagePrompts()" style="flex: 1;">‚ûï Submit Image Prompts</button>
            </div>
          </div>

          <div class="input-group" style="margin-top: 12px;">
            <label>‚öôÔ∏è Tu·ª≥ ch·ªçn (√°p d·ª•ng cho T·∫§T C·∫¢ prompts ·∫£nh)</label>
            <textarea id="commonImagePrompt" placeholder="V√≠ d·ª•: T·∫°o ·∫£nh anime, ph·∫£i c√≥ chi·∫øc th·∫£m tr√≤n m√†u ƒë·ªè, m√†u s·∫Øc t∆∞∆°i s√°ng cho tr·∫ª em" rows="2" style="resize: vertical;"></textarea>
            <div style="font-size: 0.75em; color: #777; margin-top: 4px;">
              N·ªôi dung n√†y s·∫Ω ƒë∆∞·ª£c th√™m v√†o cu·ªëi m·ªói prompt ·∫£nh
            </div>
          </div>
        </div>

        <!-- Video Prompts -->
        <div class="section" style="background: linear-gradient(135deg, #f3e5f5 0%, #fce4ec 100%); border: 2px solid #9c27b0;">
          <h2>üé¨ Video Prompts</h2>
          <div style="font-size: 0.85em; color: #777; margin-bottom: 8px;">Th√™m (continue) ·ªü ƒë·∫ßu ƒë·ªÉ extend t·ª´ video tr∆∞·ªõc</div>

          <div class="info-box">
            <strong>üìå Logic:</strong> ·∫¢nh 1+2 ‚Üí Video 1, ·∫¢nh 2+3 ‚Üí Video 2<br>
            <strong>üîÑ Continue:</strong> <code>(continue)</code> ·ªü ƒë·∫ßu ‚Üí Extend t·ª´ video tr∆∞·ªõc
          </div>

          <div class="input-group">
            <label class="checkbox-label">
              <input type="checkbox" id="useFixedVideoPrompt">
              <span>D√πng 1 prompt c·ªë ƒë·ªãnh cho t·∫•t c·∫£ video</span>
            </label>
          </div>

          <div class="input-group">
            <label>Video Prompts (m·ªói d√≤ng 1 prompt)</label>
            <div class="prompt-textarea-container">
              <textarea id="videoPrompts" placeholder="Camera pans slowly from left to right
(continue) Zoom in on the mountains
Camera moves forward into the scene
(continue) Fade to black"></textarea>
            </div>
            <div class="submit-btn-container">
              <button class="btn btn-success btn-small" onclick="submitVideoPrompts()" style="flex: 1;">‚ûï Submit Video Prompts</button>
            </div>
          </div>

          <div class="input-group" style="margin-top: 12px;">
            <label>‚öôÔ∏è Tu·ª≥ ch·ªçn (√°p d·ª•ng cho T·∫§T C·∫¢ prompts video)</label>
            <textarea id="commonVideoPrompt" placeholder="V√≠ d·ª•: Camera chuy·ªÉn ƒë·ªông m∆∞·ª£t m√†, m√†u s·∫Øc t∆∞∆°i s√°ng, phong c√°ch anime" rows="2" style="resize: vertical;"></textarea>
            <div style="font-size: 0.75em; color: #777; margin-top: 4px;">
              N·ªôi dung n√†y s·∫Ω ƒë∆∞·ª£c th√™m v√†o cu·ªëi m·ªói prompt video
            </div>
          </div>
        </div>

        <!-- Image Gallery -->
        <div class="section">
          <h2>üñºÔ∏è ·∫¢nh ƒë√£ t·∫°o</h2>
          <div class="gallery" id="imageGallery"></div>
        </div>

        <!-- MediaID Input Mode -->
        <div class="section">
          <h2>üîë MediaID Input (T√πy ch·ªçn)</h2>
          <div class="input-group">
            <label>
              <input type="checkbox" id="useMediaIdMode" onchange="toggleMediaIdMode()">
              ‚úÖ D√πng MediaID ƒë·ªÉ t·∫°o video (b·ªè qua gen ·∫£nh)
            </label>
          </div>
          <div id="mediaIdInputContainer" style="display: none;">
            <div class="input-group">
              <label>MediaID List (m·ªói d√≤ng 1 mediaID)</label>
              <textarea id="mediaIdList" rows="8" placeholder="CAMaJDAwNjNhNTEzLTQw...&#10;CAMaJDAwNjNhNTEzLTQw...&#10;CAMaJDAwNjNhNTEzLTQw..."></textarea>
            </div>
            <div style="font-size: 0.85em; color: #666; margin-top: -8px; margin-bottom: 12px;">
              üí° Paste mediaID t·ª´ file mediaIDs.txt ho·∫∑c gen ·∫£nh ·ªü tr√™n
            </div>
          </div>
        </div>

        <!-- Video Gallery -->
        <div class="section">
          <h2>üé¨ Video Preview</h2>
          <div class="gallery" id="videoGallery"></div>
        </div>

        <!-- Log Console -->
        <div class="section">
          <h2>üìä Log Console</h2>
          <div class="log-console-container">
            <div>
              <div class="log-console-title">üñºÔ∏è Image Log</div>
              <div class="log-console" id="imageLogConsole"></div>
            </div>
            <div>
              <div class="log-console-title">üé¨ Video Log</div>
              <div class="log-console" id="videoLogConsole"></div>
            </div>
          </div>
        </div>

        <!-- MediaID Test Section -->
        <div class="section">
          <h2>üß™ Test Gen Video t·ª´ MediaID</h2>
          <div class="input-group">
            <label>MediaID 1 (Start Image)</label>
            <input type="text" id="testMediaId1" value="CAMaJDAyMTY1NzAxLTBkMmQtNDQzMy1iNTRkLWRmZjQ0YTE0OTNkZSIEQ0lvQiokNjYxZGZkNDYtMzQ2Yi00MWJlLTg1OTctMGRkOGJmZjQ0ZTMx" style="font-family: monospace; font-size: 0.75em;">
          </div>
          <div class="input-group">
            <label>MediaID 2 (End Image)</label>
            <input type="text" id="testMediaId2" value="CAMaJDAyMTY1NzAxLTBkMmQtNDQzMy1iNTRkLWRmZjQ0YTE0OTNkZSIEQ0lzQiokYzJmOTcwYTctMmIwNS00Yjc2LWI3NzgtMWE5YWFlYTBlNTBm" style="font-family: monospace; font-size: 0.75em;">
          </div>
          <div class="input-group">
            <label>Prompt</label>
            <textarea id="testVideoPrompt" rows="2" placeholder="camera xoay v√≤ng tr√≤n">camera xoay v√≤ng tr√≤n</textarea>
          </div>
          <div class="input-group">
            <button class="btn btn-primary" onclick="testGenerateVideoFromMediaId()">
              üé¨ Gen Video
            </button>
          </div>
          <div class="input-group">
            <label>Video Preview</label>
            <div id="testVideoPreview" style="margin-top: 8px; min-height: 50px; background: #f5f5f5; border-radius: 4px; padding: 8px; font-size: 0.9em; color: #666;">
              Ch∆∞a c√≥ video
            </div>
          </div>
        </div>
      </div>

      <!-- Right Sidebar - Errors & Queues -->
      <div class="error-sidebar">
        <!-- Active Queues -->
        <div class="section">
          <h2>‚ö° Active Queues</h2>
          <div id="activeQueues" style="max-height: 200px; overflow-y: auto;">
            <div style="font-size: 0.85em; color: #777;">Kh√¥ng c√≥ task ƒëang ch·∫°y</div>
          </div>
        </div>

        <!-- Video Queue -->
        <div class="section">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <h2 style="margin: 0;">üé¨ H√†ng Ch·ªù Video</h2>
            <div style="font-size: 0.75em; color: #667eea;" id="videoQueueCountDisplay">0 videos</div>
          </div>
          <div id="videoQueueDisplay" style="max-height: 300px; overflow-y: auto;">
            <div style="font-size: 0.85em; color: #777;">Queue tr·ªëng</div>
          </div>
        </div>

        <!-- Failed Images -->
        <div class="section">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <h2 style="margin: 0;">‚ùå ·∫¢nh Failed</h2>
            <div style="display: flex; gap: 4px;">
              <button class="btn btn-info btn-small" onclick="sortFailedImages()" style="padding: 4px 8px; font-size: 0.75em;">
                üî¢ Sort
              </button>
              <button class="btn btn-warning btn-small" onclick="regenAllFailedImages()" style="padding: 4px 8px; font-size: 0.75em;">
                üîÑ Regen All
              </button>
            </div>
          </div>
          <div id="failedImagesList" style="max-height: 200px; overflow-y: auto;">
            <div style="font-size: 0.85em; color: #777;">Ch∆∞a c√≥ l·ªói</div>
          </div>
        </div>

        <!-- Failed Videos -->
        <div class="section">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <h2 style="margin: 0;">‚ùå Video Failed</h2>
            <div style="display: flex; gap: 4px;">
              <button class="btn btn-info btn-small" onclick="sortFailedVideos()" style="padding: 4px 8px; font-size: 0.75em;">
                üî¢ Sort
              </button>
              <button class="btn btn-warning btn-small" onclick="regenAllFailedVideos()" style="padding: 4px 8px; font-size: 0.75em;">
                üîÑ Regen All
              </button>
            </div>
          </div>
          <div id="failedVideosList" style="max-height: 200px; overflow-y: auto;">
            <div style="font-size: 0.85em; color: #777;">Ch∆∞a c√≥ l·ªói</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ============================================
    // GLOBAL STATE
    // ============================================
    let state = {
      isRunning: false,
      paused: false,        // NEW: For pause/resume control
      images: [],           // {url, prompt, seed, generationId, index, savedPath}
      videos: [],           // {url, prompt, sceneIndex, variantIndex, filename}
      projectId: null,
      sceneId: null,
      aspectRatio: 'IMAGE_ASPECT_RATIO_LANDSCAPE',
      imageCount: 0,
      videoCount: 0,
      lastVideoMediaId: null,  // For continue/extend

      // Queue system
      imageQueue: [],       // Prompts to generate
      videoQueue: [],       // {img1, img2, prompt, sceneIndex, attempts: 0}
      imageQueueProcessing: false,
      videoQueueProcessing: false,

      // Prompt cursors (s·ªë d√≤ng prompt ƒë√£ submit tr∆∞·ªõc ƒë√≥)
      imagePromptCursor: 0,
      videoPromptCursor: 0,

      // Error tracking
      failedImages: [],     // {prompt, index, error, attempts}
      failedVideos: [],     // {img1, img2, prompt, sceneIndex, error, reason, attempts}

      // Active tasks
      activeImageTasks: [], // Currently generating images
      activeVideoTasks: [],  // Currently generating videos

      // NEW: Video generation flow control
      videoGenerationBlocked: false,  // Block on 429
      lastVideoCompletedAt: null,     // Timestamp of last completion
      pendingVideoCompletion: 0       // Count videos waiting to complete
    };

    const MAX_RETRIES = 3;
    const MAX_PARALLEL_VIDEOS = 2;  // Keep at 2 to avoid rate limiting

    // ============================================
    // UTILITY FUNCTIONS
    // ============================================
    function log(message, type = 'info', logTarget = 'auto') {
      const timestamp = new Date().toLocaleTimeString();

      // Auto-detect log target based on message content if not specified
      if (logTarget === 'auto') {
        const lowerMsg = message.toLowerCase();

        // CRITICAL: Check for specific prefixes first (highest priority)
        if (lowerMsg.includes('[video') || lowerMsg.includes('üé¨ [') || lowerMsg.includes('üé• [')) {
          logTarget = 'video';
        }
        else if (lowerMsg.includes('[·∫£nh') || lowerMsg.includes('[anh') || lowerMsg.includes('üé® [')) {
          logTarget = 'image';
        }
        // Video-specific keywords (medium priority)
        else if (lowerMsg.includes('vid q') || lowerMsg.includes('video q') ||
                 lowerMsg.includes('extend') || lowerMsg.includes('variants') ||
                 lowerMsg.includes('veo3') || lowerMsg.includes('video generation') ||
                 lowerMsg.includes('video progress')) {
          logTarget = 'video';
        }
        // Image-specific keywords (medium priority)
        else if (lowerMsg.includes('img q') || lowerMsg.includes('image q') ||
                 lowerMsg.includes('seed:') || lowerMsg.includes('continue') ||
                 lowerMsg.includes('whisk') || lowerMsg.includes('image progress')) {
          logTarget = 'image';
        }
        // Single keyword match (low priority) - check which appears first
        else if (lowerMsg.includes('video') || lowerMsg.includes('üé¨')) {
          // Check if 'image' or '·∫£nh' also appears
          const videoPos = Math.min(
            lowerMsg.indexOf('video') >= 0 ? lowerMsg.indexOf('video') : Infinity,
            lowerMsg.indexOf('üé¨') >= 0 ? lowerMsg.indexOf('üé¨') : Infinity
          );
          const imagePos = Math.min(
            lowerMsg.indexOf('image') >= 0 ? lowerMsg.indexOf('image') : Infinity,
            lowerMsg.indexOf('·∫£nh') >= 0 ? lowerMsg.indexOf('·∫£nh') : Infinity,
            lowerMsg.indexOf('üé®') >= 0 ? lowerMsg.indexOf('üé®') : Infinity
          );

          if (videoPos < imagePos) {
            logTarget = 'video';
          } else if (imagePos < Infinity) {
            logTarget = 'image';
          } else {
            logTarget = 'video';
          }
        }
        else if (lowerMsg.includes('·∫£nh') || lowerMsg.includes('image') || lowerMsg.includes('üé®')) {
          logTarget = 'image';
        }
        // General logs go to both
        else {
          logTarget = 'general';
        }
      }

      // Determine which console to use
      let consoleId = 'imageLogConsole'; // default
      if (logTarget === 'video') {
        consoleId = 'videoLogConsole';
      } else if (logTarget === 'image') {
        consoleId = 'imageLogConsole';
      } else if (logTarget === 'general') {
        // For general logs, log to both consoles
        logToConsole('imageLogConsole', timestamp, message, type);
        logToConsole('videoLogConsole', timestamp, message, type);
        console.log(`[${type.toUpperCase()}]`, message);
        return;
      }

      logToConsole(consoleId, timestamp, message, type);
      console.log(`[${type.toUpperCase()}]`, message);
    }

    function logToConsole(consoleId, timestamp, message, type) {
      const logConsole = document.getElementById(consoleId);
      if (!logConsole) return;

      const entry = document.createElement('div');
      entry.className = `log-entry log-${type}`;
      entry.innerHTML = `<span class="log-time">[${timestamp}]</span>${message}`;
      logConsole.appendChild(entry);
      logConsole.scrollTop = logConsole.scrollHeight;
    }

    function updateStatus(element, status) {
      const el = document.getElementById(element);
      if (!el) {
        console.warn(`Element with id '${element}' not found`);
        return;
      }
      el.className = 'status-dot';
      if (status === 'active') el.classList.add('active');
      if (status === 'error') el.classList.add('error');
    }

    function toggleMediaIdMode() {
      const isEnabled = document.getElementById('useMediaIdMode').checked;
      const container = document.getElementById('mediaIdInputContainer');
      container.style.display = isEnabled ? 'block' : 'none';

      if (isEnabled) {
        log('üîë MediaID mode: B·∫≠t - S·∫Ω d√πng mediaID tr·ª±c ti·∫øp (b·ªè qua gen ·∫£nh)', 'info');
      } else {
        log('üì∑ Normal mode: T·∫Øt MediaID mode - Gen ·∫£nh b√¨nh th∆∞·ªùng', 'info');
      }
    }

    function updateStats() {
      document.getElementById('imageCount').textContent = state.imageCount;
      document.getElementById('videoCount').textContent = state.videoCount;
      document.getElementById('imageQueueCount').textContent = state.imageQueue.length;
      document.getElementById('videoQueueCount').textContent = state.videoQueue.length;
      updateActiveQueuesUI();
      updateErrorListUI();
      updateProgress();
      updateVideoProgress();
    }

    function updateProgress() {
      const total = state.imageCount + state.imageQueue.length;
      if (total === 0) {
        document.getElementById('progressBar').style.width = '0%';
        document.getElementById('progressBar').textContent = '0%';
        return;
      }
      const progress = Math.round((state.imageCount / total) * 100);
      document.getElementById('progressBar').style.width = progress + '%';
      document.getElementById('progressBar').textContent = `${progress}% (${state.imageCount}/${total})`;
    }

    function updateVideoProgress() {
      const total = state.videoCount + state.videoQueue.length + state.activeVideoTasks.length;
      if (total === 0) {
        document.getElementById('videoProgressBar').style.width = '0%';
        document.getElementById('videoProgressBar').textContent = '0%';
        return;
      }
      const progress = Math.round((state.videoCount / total) * 100);
      document.getElementById('videoProgressBar').style.width = progress + '%';
      document.getElementById('videoProgressBar').textContent = `${progress}% (${state.videoCount}/${total})`;
    }

    function updateVideoQueueDisplay() {
      const container = document.getElementById('videoQueueDisplay');
      const countDisplay = document.getElementById('videoQueueCountDisplay');

      if (state.videoQueue.length === 0) {
        container.innerHTML = '<div style="font-size: 0.85em; color: #777;">Queue tr·ªëng</div>';
        countDisplay.textContent = '0 videos';
        return;
      }

      countDisplay.textContent = `${state.videoQueue.length} video${state.videoQueue.length > 1 ? 's' : ''}`;

      container.innerHTML = state.videoQueue.map((video, idx) => {
        const videoNum = video.sceneIndex + 1;
        const promptPreview = video.prompt.length > 50 ? video.prompt.substring(0, 50) + '...' : video.prompt;

        return `
          <div class="queue-item" style="display: flex; align-items: flex-start; justify-content: space-between; padding: 8px; margin-bottom: 6px; background: #f9f9f9; border-radius: 4px; border-left: 3px solid #667eea;">
            <div style="flex: 1;">
              <div style="font-weight: 600; color: #667eea; font-size: 0.9em;">Video ${videoNum}</div>
              <div style="font-size: 0.8em; color: #555; margin-top: 2px;">${promptPreview}</div>
              <div style="font-size: 0.75em; color: #999; margin-top: 2px;">·∫¢nh ${video.img1.index + 1} ‚Üí ${video.img2.index + 1}</div>
            </div>
            <button
              onclick="deleteVideoFromQueue(${idx})"
              style="background: #ff4444; color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 0.75em; margin-left: 8px;"
              title="X√≥a video kh·ªèi queue"
            >üóëÔ∏è</button>
          </div>
        `;
      }).join('');
    }

    function deleteVideoFromQueue(index) {
      if (confirm(`X√≥a Video ${state.videoQueue[index].sceneIndex + 1} kh·ªèi queue?`)) {
        const deleted = state.videoQueue.splice(index, 1)[0];
        log(`üóëÔ∏è ƒê√£ x√≥a Video ${deleted.sceneIndex + 1} kh·ªèi queue`, 'info');
        updateStats();
        updateVideoQueueDisplay();
      }
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function randomDelay(minSeconds, maxSeconds) {
      const ms = (minSeconds + Math.random() * (maxSeconds - minSeconds)) * 1000;
      return sleep(ms);
    }

    function updateActiveQueuesUI() {
      const container = document.getElementById('activeQueues');

      const tasks = [
        ...state.activeImageTasks.map(t => `üñºÔ∏è ·∫¢nh ${t.index + 1}: ${t.prompt.substring(0, 30)}...`),
        ...state.activeVideoTasks.map(t => `üé¨ Video ${t.sceneIndex + 1}: ${t.prompt.substring(0, 30)}...`)
      ];

      if (tasks.length === 0) {
        container.innerHTML = '<div style="font-size: 0.85em; color: #777;">Kh√¥ng c√≥ task ƒëang ch·∫°y</div>';
        return;
      }

      container.innerHTML = tasks.map(task => `
        <div class="queue-item">
          <div class="spinner"></div>
          <div>${task}</div>
        </div>
      `).join('');
    }

    function updateErrorListUI() {
      // Update failed images list
      const imagesContainer = document.getElementById('failedImagesList');
      if (state.failedImages.length === 0) {
        imagesContainer.innerHTML = '<div style="font-size: 0.85em; color: #777;">Ch∆∞a c√≥ l·ªói</div>';
      } else {
        imagesContainer.innerHTML = state.failedImages.map((item, idx) => `
          <div class="error-item">
            <div class="error-title">‚ùå ·∫¢nh ${item.index + 1}</div>
            <div class="error-msg">${item.prompt.substring(0, 40)}...</div>
            <div style="font-size: 0.75em; color: #999; margin: 4px 0;">
              L·ªói: ${item.error}<br>
              Attempts: ${item.attempts}
            </div>
            <div style="display: flex; gap: 4px;">
              <button class="btn btn-warning btn-small" onclick="retryFailedImage(${idx})" style="flex: 1;">
                üîÑ Retry
              </button>
              <button class="btn btn-info btn-small" onclick="regenFailedImage(${idx})" style="flex: 1;">
                üé≤ Regen
              </button>
            </div>
          </div>
        `).join('');
      }

      // Update failed videos list
      const videosContainer = document.getElementById('failedVideosList');
      if (state.failedVideos.length === 0) {
        videosContainer.innerHTML = '<div style="font-size: 0.85em; color: #777;">Ch∆∞a c√≥ l·ªói</div>';
      } else {
        videosContainer.innerHTML = state.failedVideos.map((item, idx) => `
          <div class="error-item">
            <div class="error-title">‚ùå Video ${item.sceneIndex + 1}</div>
            <div class="error-msg">${item.prompt ? item.prompt.substring(0, 40) + '...' : 'N/A'}</div>
            <div style="font-size: 0.75em; color: #999; margin: 4px 0;">
              L√Ω do: ${item.reason || item.error}<br>
              ${item.attempts ? `Attempts: ${item.attempts}` : ''}
            </div>
            <div style="display: flex; gap: 4px;">
              <button class="btn btn-warning btn-small" onclick="retryFailedVideo(${idx})" style="flex: 1;">
                üîÑ Retry
              </button>
              <button class="btn btn-info btn-small" onclick="regenFailedVideo(${idx})" style="flex: 1;">
                üé≤ Regen
              </button>
            </div>
          </div>
        `).join('');
      }
    }

    function sortFailedImages() {
      state.failedImages.sort((a, b) => a.index - b.index);
      updateStats();
      log('üî¢ ƒê√£ s·∫Øp x·∫øp failed images theo th·ª© t·ª±', 'info');
    }

    function sortFailedVideos() {
      state.failedVideos.sort((a, b) => a.sceneIndex - b.sceneIndex);
      updateStats();
      log('üî¢ ƒê√£ s·∫Øp x·∫øp failed videos theo th·ª© t·ª±', 'info');
    }

    async function regenAllFailedImages() {
      if (state.failedImages.length === 0) {
        log('‚ö†Ô∏è Kh√¥ng c√≥ ·∫£nh failed ƒë·ªÉ regen', 'warning');
        return;
      }

      if (!confirm(`Regen ${state.failedImages.length} ·∫£nh failed tu·∫ßn t·ª± (1 ·∫£nh 1 l·∫ßn)?`)) {
        return;
      }

      // Sort by index (nh·ªè ƒë·∫øn l·ªõn)
      state.failedImages.sort((a, b) => a.index - b.index);

      log(`\nüîÑ ========== REGEN ALL FAILED IMAGES ==========`, 'info');
      log(`üìä T·ªïng: ${state.failedImages.length} ·∫£nh`, 'info');

      // Clone array ƒë·ªÉ tr√°nh mutation trong loop
      const itemsToRegen = [...state.failedImages];
      state.failedImages = [];  // Clear ngay ƒë·ªÉ kh√¥ng conflict
      updateStats();

      // Gen tu·∫ßn t·ª±, 1 ·∫£nh 1 l·∫ßn
      for (const item of itemsToRegen) {
        log(`\nüîÑ Regen ·∫£nh ${item.index + 1}/${state.imageCount}...`, 'info');

        // Remove (Continue) from prompt and generate with new random seed
        const cleanPrompt = item.prompt.replace(/^\(continue\)\s*/i, '').trim();
        await generateImageWithRetry(cleanPrompt, item.index, 0);

        // Wait a bit between items to avoid spam
        await sleep(1000);
      }

      log(`‚úÖ Regen All ho√†n th√†nh!`, 'success');
      updateStats();
    }

    async function regenAllFailedVideos() {
      if (state.failedVideos.length === 0) {
        log('‚ö†Ô∏è Kh√¥ng c√≥ video failed ƒë·ªÉ regen', 'warning');
        return;
      }

      if (!confirm(`Regen ${state.failedVideos.length} video failed tu·∫ßn t·ª± (1 video 1 l·∫ßn)?`)) {
        return;
      }

      // Sort by sceneIndex (nh·ªè ƒë·∫øn l·ªõn)
      state.failedVideos.sort((a, b) => a.sceneIndex - b.sceneIndex);

      log(`\nüîÑ ========== REGEN ALL FAILED VIDEOS ==========`, 'info');
      log(`üìä T·ªïng: ${state.failedVideos.length} videos`, 'info');

      // Clone array ƒë·ªÉ tr√°nh mutation trong loop
      const itemsToRegen = [...state.failedVideos];
      state.failedVideos = [];  // Clear ngay ƒë·ªÉ kh√¥ng conflict
      updateStats();

      // Gen tu·∫ßn t·ª±, 1 video 1 l·∫ßn
      for (const item of itemsToRegen) {
        log(`\nüîÑ Regen video ${item.sceneIndex + 1}...`, 'info');

        // Reset attempts v√† gen l·∫°i
        item.attempts = 0;
        await generateVideoWithRetry(item);

        // Wait a bit between items to avoid spam
        await sleep(2000);
      }

      log(`‚úÖ Regen All ho√†n th√†nh!`, 'success');
      updateStats();
    }

    async function retryFailedImage(failedIndex) {
      const item = state.failedImages.splice(failedIndex, 1)[0];
      if (item) {
        log(`üîÑ Retry ·∫£nh ${item.index + 1} v·ªõi index c≈©...`, 'info');

        // Call generateImageWithRetry directly with the ORIGINAL index
        // Don't add to queue because queue would assign new index
        await generateImageWithRetry(item.prompt, item.index, 0);

        updateStats();
      }
    }

    async function regenFailedImage(failedIndex) {
      const item = state.failedImages.splice(failedIndex, 1)[0];
      if (item) {
        log(`üé≤ Regen ·∫£nh ${item.index + 1} v·ªõi seed m·ªõi (b·ªè qua Continue)...`, 'info');

        // Remove (Continue) from prompt and generate with new random seed
        const cleanPrompt = item.prompt.replace(/^\(continue\)\s*/i, '').trim();

        // Call generateImageWithRetry with clean prompt (no Continue)
        await generateImageWithRetry(cleanPrompt, item.index, 0);

        updateStats();
      }
    }

    async function regenFailedVideo(failedIndex) {
      const item = state.failedVideos.splice(failedIndex, 1)[0];
      if (item) {
        // For videos, regen is same as retry but we could add different logic if needed
        item.attempts = 0;
        state.videoQueue.push(item);
        log(`üé≤ Regen video ${item.sceneIndex + 1}`, 'info');
        updateStats();

        // CRITICAL: Always call processVideoQueue to ensure it processes the new item
        // Function has internal guard to prevent duplicate processing
        processVideoQueue();
      }
    }

    async function retryFailedVideo(index) {
      const item = state.failedVideos.splice(index, 1)[0];
      if (item) {
        item.attempts = 0; // Reset attempts
        state.videoQueue.push(item);
        log(`üîÑ Retry video ${item.sceneIndex + 1}`, 'info');
        updateStats();

        // CRITICAL: Always call processVideoQueue to ensure it processes the new item
        // Function has internal guard to prevent duplicate processing
        processVideoQueue();
      }
    }

    function retryVideosWaitingForImage(imageIndex) {
      // Find failed videos that need this image
      const videosToRetry = [];

      for (let i = state.failedVideos.length - 1; i >= 0; i--) {
        const failedVideo = state.failedVideos[i];

        // Check if this video was waiting for the image we just generated
        const needsImg1 = failedVideo.img1.index === imageIndex;
        const needsImg2 = failedVideo.img2.index === imageIndex;

        if (needsImg1 || needsImg2) {
          // Check if we now have both images
          const img1 = state.images.find(img => img.index === failedVideo.img1.index);
          const img2 = state.images.find(img => img.index === failedVideo.img2.index);

          if (img1 && img2) {
            // We have both images now! Remove from failed and retry
            const item = state.failedVideos.splice(i, 1)[0];

            // Update with real image objects
            item.img1 = img1;
            item.img2 = img2;
            item.attempts = 0;

            videosToRetry.push(item);
            log(`üîÑ Auto-retry video ${item.sceneIndex + 1} (·∫£nh ${imageIndex + 1} ƒë√£ s·∫µn s√†ng)`, 'info');
          }
        }
      }

      // Add all videos to retry to queue
      if (videosToRetry.length > 0) {
        state.videoQueue.push(...videosToRetry);
        updateStats();

        // Start processing if not already running
        if (!state.videoQueueProcessing) {
          processVideoQueue();
        }
      }
    }

    // ============================================
    // SESSION MANAGEMENT
    // ============================================
    function saveSession() {
      // Create unique session key based on projectId or timestamp
      const sessionKey = state.projectId
        ? `whisk_veo3_session_${state.projectId}`
        : `whisk_veo3_session_${Date.now()}`;

      // CRITICAL: Don't save base64 URLs to avoid localStorage quota exceeded
      // Only save minimal metadata (generationId, prompt, index)
      const sessionData = {
        images: state.images.map(img => ({
          generationId: img.generationId,
          prompt: img.prompt,
          index: img.index,
          seed: img.seed,
          isContinue: img.isContinue,
          timestamp: img.timestamp
        })),
        videos: state.videos.map(vid => ({
          generationId: vid.generationId,
          sceneIndex: vid.sceneIndex,
          prompt: vid.prompt,
          variantIndex: vid.variantIndex,
          savedPath: vid.savedPath,
          timestamp: vid.timestamp
        })),
        // Only save prompts, not full objects
        imageQueue: state.imageQueue,  // Already just strings
        videoQueue: state.videoQueue.map(v => ({
          sceneIndex: v.sceneIndex,
          prompt: v.prompt
        })),
        imageCount: state.imageCount,
        videoCount: state.videoCount,
        projectId: state.projectId,
        sceneId: state.sceneId,
        aspectRatio: state.aspectRatio,
        lastVideoMediaId: state.lastVideoMediaId,
        // Only save essential failed info
        failedImages: state.failedImages.map(f => ({
          prompt: f.prompt,
          index: f.index
        })),
        failedVideos: state.failedVideos.map(f => ({
          sceneIndex: f.sceneIndex,
          prompt: f.prompt
        })),
        timestamp: Date.now()
      };

      try {
        // Clear old sessions to prevent quota buildup
        const allKeys = Object.keys(localStorage);
        const oldSessionKeys = allKeys.filter(k =>
          k.startsWith('whisk_veo3_session_') && k !== sessionKey
        );

        // Keep only 2 most recent sessions
        if (oldSessionKeys.length > 2) {
          oldSessionKeys.slice(0, -2).forEach(k => localStorage.removeItem(k));
          log(`üßπ Cleared ${oldSessionKeys.length - 2} old sessions`, 'info');
        }

        const jsonData = JSON.stringify(sessionData);
        const sizeKB = (jsonData.length / 1024).toFixed(2);

        localStorage.setItem(sessionKey, jsonData);
        const projectInfo = state.projectId ? `Project: ${state.projectId.substring(0, 8)}...` : 'Temporary';
        log(`‚úÖ Session ƒë√£ l∆∞u! (${sizeKB} KB, Key: ${sessionKey.substring(0, 35)}..., ${projectInfo})`, 'success');
      } catch (err) {
        log('‚ùå L·ªói l∆∞u session: ' + err.message, 'error');

        // Try to clear ALL old sessions and retry
        try {
          const allKeys = Object.keys(localStorage);
          const sessionKeys = allKeys.filter(k => k.startsWith('whisk_veo3_session_'));
          sessionKeys.forEach(k => localStorage.removeItem(k));
          log(`üßπ Cleared all ${sessionKeys.length} sessions, retrying...`, 'warning');

          const jsonData = JSON.stringify(sessionData);
          localStorage.setItem(sessionKey, jsonData);
          log(`‚úÖ Session saved after clearing (${(jsonData.length / 1024).toFixed(2)} KB)`, 'success');
        } catch (retryErr) {
          log('‚ùå Still failed after clearing: ' + retryErr.message, 'error');
          log('üí° localStorage is full. Session not saved. Use manual save if needed.', 'info');
        }
      }
    }

    function loadSavedSession() {
      try {
        // Try to find session based on current projectId first
        let sessionKey = state.projectId
          ? `whisk_veo3_session_${state.projectId}`
          : null;

        let savedData = sessionKey ? localStorage.getItem(sessionKey) : null;

        // If not found, try to find any recent session
        if (!savedData) {
          const keys = Object.keys(localStorage).filter(k => k.startsWith('whisk_veo3_session_'));
          if (keys.length > 0) {
            // Get most recent session
            sessionKey = keys[keys.length - 1];
            savedData = localStorage.getItem(sessionKey);
            log(`üìã Load session: ${sessionKey}`, 'info');
          }
        }

        if (!savedData) {
          log('‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y session ƒë√£ l∆∞u', 'warning');
          return;
        }

        const sessionData = JSON.parse(savedData);

        state.images = sessionData.images || [];
        state.videos = sessionData.videos || [];
        state.imageQueue = sessionData.imageQueue || [];
        state.videoQueue = sessionData.videoQueue || [];
        state.imageCount = sessionData.imageCount || 0;
        state.videoCount = sessionData.videoCount || 0;
        state.projectId = sessionData.projectId || null;
        state.sceneId = sessionData.sceneId || null;
        state.aspectRatio = sessionData.aspectRatio || 'IMAGE_ASPECT_RATIO_LANDSCAPE';
        state.lastVideoMediaId = sessionData.lastVideoMediaId || null;
        state.failedImages = sessionData.failedImages || [];
        state.failedVideos = sessionData.failedVideos || [];

        // Update UI
        if (state.projectId) document.getElementById('projectId').value = state.projectId;
        if (state.sceneId) document.getElementById('sceneId').value = state.sceneId;
        document.getElementById('aspectRatio').value = state.aspectRatio;

        // NOTE: Session only contains metadata (generationId, prompt, index), not base64 URLs
        // Galleries won't be restored, but image/video counts and queue are preserved
        // This prevents localStorage quota exceeded error

        updateStats();
        updateProgress();

        const date = new Date(sessionData.timestamp);
        log(`‚úÖ Session ƒë√£ load! (${state.images.length} images, ${state.videos.length} videos metadata, l∆∞u l√∫c: ${date.toLocaleString()})`, 'success');
        log(`‚ö†Ô∏è Galleries kh√¥ng restore (ch·ªâ l∆∞u metadata ƒë·ªÉ tr√°nh quota error)`, 'warning');
      } catch (err) {
        log('‚ùå L·ªói load session: ' + err.message, 'error');
      }
    }

    // Auto-save every 30 seconds when running
    setInterval(() => {
      if (state.isRunning || state.imageQueue.length > 0 || state.videoQueue.length > 0) {
        saveSession();
      }
    }, 30000);

    // ============================================
    // CHROME & TOKEN MANAGEMENT
    // ============================================
    let selectedProfile = '';  // Track selected profile

    // L∆∞u 1 profile th·ªëng nh·∫•t: Chrome profile + Token + Proxy + Project ID
    async function saveUnifiedProfile() {
      const profileName = document.getElementById('newProfileName').value.trim();
      const tokenProxy = document.getElementById('tokenProxy').value.trim();
      const tokenProjectId = document.getElementById('tokenProjectId').value.trim();
      const projectIdInput = document.getElementById('projectId').value.trim();
      const sceneIdInput = document.getElementById('sceneId').value.trim();
      const projectLinkInput = document.getElementById('projectLink').value.trim();

      if (!profileName) {
        alert('‚ö†Ô∏è Vui l√≤ng nh·∫≠p t√™n profile tr∆∞·ªõc khi l∆∞u!');
        log('‚ùå Ch∆∞a nh·∫≠p t√™n profile', 'error');
        return;
      }

      log(`üíæ ƒêang l∆∞u PROFILE (Chrome + Token) v·ªõi t√™n: "${profileName}"...`, 'info');

      let profileSaved = false;
      let tokenSaved = false;

      // 1) L∆∞u Chrome profile (profiles.txt)
      try {
        const resProfile = await fetch('/api/save-profile', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ profileName })
        });
        const dataProfile = await resProfile.json();
        if (dataProfile.success) {
          profileSaved = true;
          log(`‚úÖ Chrome profile "${profileName}" ƒë√£ ƒë∆∞·ª£c l∆∞u!`, 'success');
        } else {
          log('‚ùå L·ªói l∆∞u Chrome profile: ' + dataProfile.error, 'error');
        }
      } catch (err) {
        log('‚ùå L·ªói l∆∞u Chrome profile: ' + err.message, 'error');
      }

      // 2) L∆∞u Token + Proxy + Project (ID/Scene/Link) v√†o tokens.txt
      try {
        const resToken = await fetch('/api/save-credentials', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            tokenName: profileName,
            proxy: tokenProxy || null,
            // ∆Øu ti√™n d√πng Project ID ƒëang active, fallback sang √¥ ri√™ng n·∫øu c√≥
            projectId: projectIdInput || (tokenProjectId || null),
            sceneId: sceneIdInput || null,
            projectLink: projectLinkInput || null
          })
        });
        const dataToken = await resToken.json();
        if (dataToken.success) {
          tokenSaved = true;
          log(`‚úÖ Token cho profile "${profileName}" ƒë√£ ƒë∆∞·ª£c l∆∞u!${tokenProxy ? ' (c√≥ proxy)' : ''}${tokenProjectId ? ' (c√≥ project)' : ''}`, 'success');
        } else {
          log('‚ùå L·ªói l∆∞u token: ' + dataToken.error, 'error');
        }
      } catch (err) {
        log('‚ùå L·ªói l∆∞u token: ' + err.message, 'error');
      }

      if (profileSaved && tokenSaved) {
        // Clear input v√† reload c·∫£ 2 list
        document.getElementById('newProfileName').value = '';
        document.getElementById('tokenProxy').value = '';
        document.getElementById('tokenProjectId').value = '';

        await loadProfileList();
        await loadTokenList();

        log(`üéâ Profile "${profileName}" ƒë√£ s·∫µn s√†ng (Chrome + Token + Proxy + Project)`, 'success');
      } else {
        log('‚ö†Ô∏è L∆∞u profile ch∆∞a ho√†n t·∫•t (xem log chi ti·∫øt ·ªü tr√™n)', 'warning');
      }
    }

    // H√†m c≈© v·∫´n gi·ªØ l·∫°i (n·∫øu c·∫ßn d√πng ri√™ng l·∫ª)
    async function saveProfile() {
      const profileName = document.getElementById('newProfileName').value.trim();

      if (!profileName) {
        alert('‚ö†Ô∏è Vui l√≤ng nh·∫≠p t√™n profile tr∆∞·ªõc khi l∆∞u!');
        log('‚ùå Ch∆∞a nh·∫≠p t√™n profile', 'error');
        return;
      }

      log(`üíæ ƒêang l∆∞u profile: "${profileName}"...`, 'info');
      try {
        const res = await fetch('/api/save-profile', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ profileName })
        });
        const data = await res.json();
        if (data.success) {
          log(`‚úÖ Profile "${profileName}" ƒë√£ ƒë∆∞·ª£c l∆∞u th√†nh c√¥ng!`, 'success');
          // Clear input and reload profile list
          document.getElementById('newProfileName').value = '';
          await loadProfileList();
        } else {
          log('‚ùå L·ªói l∆∞u profile: ' + data.error, 'error');
        }
      } catch (err) {
        log('‚ùå L·ªói: ' + err.message, 'error');
      }
    }

    async function loadProfileList() {
      try {
        const res = await fetch('/api/list-profiles');
        const data = await res.json();
        if (data.success) {
          const selector = document.getElementById('profileSelector');
          selector.innerHTML = '<option value="">-- Ch·ªçn profile --</option>';
          data.profiles.forEach(profile => {
            const option = document.createElement('option');
            option.value = profile;
            option.textContent = profile;
            selector.appendChild(option);
          });
          log(`üìã Loaded ${data.profiles.length} profiles`, 'info');
        }
      } catch (err) {
        log('‚ùå L·ªói load danh s√°ch profiles: ' + err.message, 'error');
      }
    }

    function updateSelectedProfile() {
      selectedProfile = document.getElementById('profileSelector').value;
      if (selectedProfile) {
        log(`üìå ƒê√£ ch·ªçn profile: "${selectedProfile}"`, 'info');
      }
    }

    async function launchChrome() {
      let profile = selectedProfile || document.getElementById('profileSelector').value;

      // N·∫øu kh√¥ng ch·ªçn g√¨ th√¨ d√πng profile m·∫∑c ƒë·ªãnh "default"
      if (!profile) {
        profile = 'default';
        log('‚ÑπÔ∏è Kh√¥ng ch·ªçn profile, d√πng profile m·∫∑c ƒë·ªãnh "default"', 'info');
      }

      log(`üöÄ ƒêang kh·ªüi ƒë·ªông Chrome v·ªõi profile: "${profile}"...`, 'info');
      try {
        const res = await fetch('/api/launch-chrome', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ profile })
        });
        const data = await res.json();
        if (data.success) {
          if (data.alreadyRunning) {
            log(`‚ö†Ô∏è  Profile "${profile}" ƒë√£ c√≥ Chrome ƒëang ch·∫°y r·ªìi!`, 'warning');
          } else {
            log(`‚úÖ Chrome ƒë√£ kh·ªüi ƒë·ªông th√†nh c√¥ng! (Profile: ${profile})`, 'success');
          }
          updateStatus('chromeStatus', 'active');
          if (!data.needsLogin) {
            updateStatus('sessionStatus', 'active');
          }
        } else {
          log('‚ùå L·ªói kh·ªüi ƒë·ªông Chrome: ' + data.error, 'error');
          updateStatus('chromeStatus', 'error');
        }
      } catch (err) {
        log('‚ùå L·ªói k·∫øt n·ªëi server: ' + err.message, 'error');
        updateStatus('chromeStatus', 'error');
      }
    }

    async function captureToken() {
      log('üîë ƒêang b·∫Øt token...', 'info');
      try {
        const res = await fetch('/api/capture-token', { method: 'POST' });
        const data = await res.json();
        if (data.success) {
          log('‚úÖ Token ƒë√£ ƒë∆∞·ª£c b·∫Øt th√†nh c√¥ng!', 'success');
          updateStatus('sessionStatus', 'active');
        } else {
          log('‚ùå L·ªói b·∫Øt token: ' + data.error, 'error');
          updateStatus('sessionStatus', 'error');
        }
      } catch (err) {
        log('‚ùå L·ªói: ' + err.message, 'error');
        updateStatus('sessionStatus', 'error');
      }
    }

    let selectedTokenName = '';  // Track selected token

    async function saveCredentials() {
      const tokenName = document.getElementById('tokenName').value.trim();
      const tokenProxy = document.getElementById('tokenProxy').value.trim();
      const tokenProjectId = document.getElementById('tokenProjectId').value.trim();

      if (!tokenName) {
        alert('‚ö†Ô∏è Vui l√≤ng nh·∫≠p t√™n token tr∆∞·ªõc khi l∆∞u!');
        log('‚ùå Ch∆∞a nh·∫≠p t√™n token', 'error');
        return;
      }

      log(`üíæ ƒêang l∆∞u token v·ªõi t√™n: "${tokenName}"${tokenProxy ? ' (c√≥ proxy)' : ''}${tokenProjectId ? ' (c√≥ project)' : ''}...`, 'info');
      try {
        const res = await fetch('/api/save-credentials', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            tokenName,
            proxy: tokenProxy || null,
            projectId: tokenProjectId || null
          })
        });
        const data = await res.json();
        if (data.success) {
          log(`‚úÖ Token "${tokenName}" ƒë√£ ƒë∆∞·ª£c l∆∞u th√†nh c√¥ng!${tokenProxy ? ' (c√≥ proxy)' : ''}${tokenProjectId ? ' (c√≥ project)' : ''}`, 'success');
          // Clear input and reload token list
          document.getElementById('tokenName').value = '';
          document.getElementById('tokenProxy').value = '';
          document.getElementById('tokenProjectId').value = '';
          await loadTokenList();
        } else {
          log('‚ùå L·ªói l∆∞u token: ' + data.error, 'error');
        }
      } catch (err) {
        log('‚ùå L·ªói: ' + err.message, 'error');
      }
    }

    async function testProxy() {
      const proxyInput = document.getElementById('tokenProxy').value.trim();
      const resultDiv = document.getElementById('proxyTestResult');

      if (!proxyInput) {
        alert('‚ö†Ô∏è Vui l√≤ng nh·∫≠p proxy tr∆∞·ªõc khi test!');
        return;
      }

      // Show loading state
      resultDiv.style.display = 'block';
      resultDiv.style.backgroundColor = '#f0f0f0';
      resultDiv.style.color = '#333';
      resultDiv.innerHTML = '‚è≥ ƒêang test proxy...';

      log(`üîç Testing proxy: ${proxyInput.split(':')[0]}:${proxyInput.split(':')[1]}...`, 'info');

      try {
        const res = await fetch('/api/test-proxy', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ proxy: proxyInput })
        });
        const data = await res.json();

        if (data.success) {
          resultDiv.style.backgroundColor = '#d4edda';
          resultDiv.style.color = '#155724';
          resultDiv.innerHTML = `‚úÖ Proxy ho·∫°t ƒë·ªông!<br>IP: ${data.ip}<br>Country: ${data.country || 'N/A'}<br>Response time: ${data.responseTime}ms`;
          log(`‚úÖ Proxy test successful - IP: ${data.ip}`, 'success');
        } else {
          resultDiv.style.backgroundColor = '#f8d7da';
          resultDiv.style.color = '#721c24';
          resultDiv.innerHTML = `‚ùå Proxy failed: ${data.error}`;
          log(`‚ùå Proxy test failed: ${data.error}`, 'error');
        }
      } catch (err) {
        resultDiv.style.backgroundColor = '#f8d7da';
        resultDiv.style.color = '#721c24';
        resultDiv.innerHTML = `‚ùå Error: ${err.message}`;
        log('‚ùå Proxy test error: ' + err.message, 'error');
      }
    }

    async function testProxyFromToken() {
      const tokenName = selectedTokenName || document.getElementById('tokenSelector').value;
      const resultDiv = document.getElementById('tokenProxyTestResult');

      if (!tokenName) {
        alert('‚ö†Ô∏è Vui l√≤ng ch·ªçn token t·ª´ dropdown!');
        return;
      }

      // Show loading state
      resultDiv.style.display = 'block';
      resultDiv.style.backgroundColor = '#f0f0f0';
      resultDiv.style.color = '#333';
      resultDiv.innerHTML = '‚è≥ ƒêang test proxy c·ªßa token...';

      log(`üîç Testing proxy from token: "${tokenName}"...`, 'info');

      try {
        const res = await fetch('/api/test-proxy', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ tokenName: tokenName })
        });
        const data = await res.json();

        if (data.success) {
          resultDiv.style.backgroundColor = '#d4edda';
          resultDiv.style.color = '#155724';
          resultDiv.innerHTML = `‚úÖ Proxy ho·∫°t ƒë·ªông!<br>IP: ${data.ip}<br>Country: ${data.country || 'N/A'}<br>City: ${data.city || 'N/A'}<br>Response time: ${data.responseTime}ms`;
          log(`‚úÖ Proxy test successful - IP: ${data.ip}`, 'success');
        } else {
          resultDiv.style.backgroundColor = '#f8d7da';
          resultDiv.style.color = '#721c24';
          resultDiv.innerHTML = `‚ùå ${data.error}`;
          log(`‚ùå Proxy test failed: ${data.error}`, 'error');
        }
      } catch (err) {
        resultDiv.style.backgroundColor = '#f8d7da';
        resultDiv.style.color = '#721c24';
        resultDiv.innerHTML = `‚ùå Error: ${err.message}`;
        log('‚ùå Proxy test error: ' + err.message, 'error');
      }
    }

    async function editProxyFromToken() {
      const tokenName = selectedTokenName || document.getElementById('tokenSelector').value;

      if (!tokenName) {
        alert('‚ö†Ô∏è Vui l√≤ng ch·ªçn token t·ª´ dropdown!');
        return;
      }

      // Show edit modal
      const modal = document.getElementById('editProxyModal');
      const proxyInput = document.getElementById('editProxyInput');
      const projectInput = document.getElementById('editProjectIdInput');

      // Load current proxy and projectId
      try {
        const res = await fetch('/api/list-tokens', { method: 'GET' });
        const data = await res.json();

        if (data.success) {
          const token = data.tokens.find(t => t.name === tokenName);
          if (token) {
            // Pre-fill with current values
            proxyInput.value = '';  // Clear first
            projectInput.value = '';  // Clear first
            proxyInput.setAttribute('data-token-name', tokenName);
            modal.style.display = 'block';

            log(`‚úèÔ∏è Editing config for token: "${tokenName}"`, 'info');
          }
        }
      } catch (err) {
        log('‚ùå Error loading token: ' + err.message, 'error');
      }
    }

    async function saveEditedProxy() {
      const tokenName = document.getElementById('editProxyInput').getAttribute('data-token-name');
      const newProxy = document.getElementById('editProxyInput').value.trim();
      const newProjectId = document.getElementById('editProjectIdInput').value.trim();

      if (!tokenName) {
        alert('‚ö†Ô∏è L·ªói: Kh√¥ng t√¨m th·∫•y token!');
        return;
      }

      log(`üíæ Updating config for token: "${tokenName}"...`, 'info');

      try {
        const res = await fetch('/api/edit-proxy', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            tokenName: tokenName,
            proxy: newProxy || null,  // null = remove proxy
            projectId: newProjectId || null  // null = remove projectId
          })
        });
        const data = await res.json();

        if (data.success) {
          alert(`‚úÖ Config ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t!\n${data.message}`);
          log(`‚úÖ ${data.message}`, 'success');

          // Hide modal and reload token list
          cancelEditProxy();
          await loadTokenList();
        } else {
          alert(`‚ùå L·ªói: ${data.error}`);
          log(`‚ùå Edit config failed: ${data.error}`, 'error');
        }
      } catch (err) {
        alert(`‚ùå L·ªói: ${err.message}`);
        log('‚ùå Edit config error: ' + err.message, 'error');
      }
    }

    function cancelEditProxy() {
      const modal = document.getElementById('editProxyModal');
      const input = document.getElementById('editProxyInput');

      modal.style.display = 'none';
      input.value = '';
      input.removeAttribute('data-token-name');
    }

    async function loadCredentials() {
      const tokenName = selectedTokenName || document.getElementById('tokenSelector').value;

      if (!tokenName) {
        alert('‚ö†Ô∏è Vui l√≤ng ch·ªçn token t·ª´ dropdown!');
        log('‚ùå Ch∆∞a ch·ªçn token n√†o', 'error');
        return false;
      }

      log(`üì• ƒêang load token: "${tokenName}"...`, 'info');
      try {
        const res = await fetch('/api/load-credentials', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ tokenName })
        });
        const data = await res.json();
        if (data.success) {
          log(`‚úÖ Token "${tokenName}" ƒë√£ ƒë∆∞·ª£c load th√†nh c√¥ng!`, 'success');
          updateStatus('sessionStatus', 'active');

          // Populate projectId/sceneId/link n·∫øu token c√≥ th√¥ng tin
          if (data.projectId) {
            document.getElementById('projectId').value = data.projectId;
            log(`üìÅ Project ID ƒë√£ ƒë∆∞·ª£c load: ${data.projectId}`, 'info');
          }
          if (data.sceneId) {
            document.getElementById('sceneId').value = data.sceneId;
            log(`üé¨ Scene ID ƒë√£ ƒë∆∞·ª£c load: ${data.sceneId}`, 'info');
          }
          if (data.projectLink) {
            document.getElementById('projectLink').value = data.projectLink;
            log('üîó Project Link ƒë√£ ƒë∆∞·ª£c load t·ª´ profile', 'info');
          }

          return true;
        } else {
          log(`‚ùå L·ªói load token "${tokenName}": ` + data.error, 'error');
          return false;
        }
      } catch (err) {
        log('‚ùå L·ªói: ' + err.message, 'error');
        return false;
      }
    }

    // One-click: Load Profile (Token + Project) + Launch Chrome + Set Project on server
    async function loadProfileAndSession() {
      const selector = document.getElementById('tokenSelector');
      if (!selector || !selector.value) {
        alert('‚ö†Ô∏è Vui l√≤ng ch·ªçn profile/token tr∆∞·ªõc khi load!');
        log('‚ùå Ch∆∞a ch·ªçn profile/token n√†o', 'error');
        return;
      }

      // ƒê·ªìng b·ªô selectedTokenName + Chrome profile
      updateSelectedToken();

      log('üì• ƒêang load Profile (Token + Project) v√† kh·ªüi t·∫°o session...', 'info');

      // 1) Load credentials + fill project fields
      const ok = await loadCredentials();
      if (!ok) {
        log('‚ùå Load credentials th·∫•t b·∫°i, d·ª´ng load profile', 'error');
        return;
      }

      // 2) Kh·ªüi ƒë·ªông Chrome v·ªõi profile t∆∞∆°ng ·ª©ng (n·∫øu ch∆∞a ch·∫°y)
      await launchChrome();

      // 3) G·ª≠i Project ID + Scene ID l√™n server Veo3
      const projectId = document.getElementById('projectId').value.trim();
      const sceneId = document.getElementById('sceneId').value.trim();

      if (!projectId || !sceneId) {
        log('‚ö†Ô∏è Thi·∫øu Project ID ho·∫∑c Scene ID sau khi load profile, vui l√≤ng ki·ªÉm tra l·∫°i', 'warning');
      } else {
        await loadSession();
      }

      log('‚úÖ Profile ƒë√£ ƒë∆∞·ª£c load & session ƒë√£ s·∫µn s√†ng', 'success');
    }

    async function loadTokenList() {
      try {
        const res = await fetch('/api/list-tokens', { method: 'GET' });
        const data = await res.json();

        // Populate dropdown (danh s√°ch profile/token)
        const selector = document.getElementById('tokenSelector');
        selector.innerHTML = '<option value="">-- Ch·ªçn profile/token --</option>';

        if (data.success && data.tokens && data.tokens.length > 0) {
          data.tokens.forEach(token => {
            const proxyLabel = token.hasProxy ? 'üåê proxy' : 'üè† local';
            const displayName = `${token.name} (${proxyLabel})`;

            const option = document.createElement('option');
            option.value = token.name;
            option.textContent = displayName;
            selector.appendChild(option);
          });
          log(`üìã T√¨m th·∫•y ${data.tokens.length} profile/token ƒë√£ l∆∞u`, 'info');
        } else {
          log('üìã Ch∆∞a c√≥ token/profile n√†o ƒë∆∞·ª£c l∆∞u', 'info');
        }
      } catch (err) {
        log('‚ùå L·ªói load danh s√°ch token: ' + err.message, 'error');
      }
    }

    async function loadTokenPool() {
      // Get selected checkboxes
      const checkboxes = document.querySelectorAll('.token-checkbox:checked');
      const tokenNames = Array.from(checkboxes).map(cb => cb.value);

      if (tokenNames.length === 0) {
        alert('‚ö†Ô∏è Vui l√≤ng ch·ªçn √≠t nh·∫•t 1 token!');
        log('‚ùå Ch∆∞a ch·ªçn token n√†o', 'error');
        return;
      }

      log(`‚ö° ƒêang load ${tokenNames.length} tokens v√†o pool...`, 'info');
      try {
        const res = await fetch('/api/load-token-pool', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ tokenNames })
        });
        const data = await res.json();

        if (data.success) {
          log(`‚úÖ Token pool ƒë√£ s·∫µn s√†ng! (${data.tokens.length} tokens)`, 'success');
          document.getElementById('tokenPoolStatus').textContent =
            `‚úÖ Pool: ${data.tokens.join(', ')}`;
        } else {
          log('‚ùå L·ªói load token pool: ' + data.error, 'error');
        }
      } catch (err) {
        log('‚ùå L·ªói: ' + err.message, 'error');
      }
    }

    function updateSelectedToken() {
      selectedTokenName = document.getElementById('tokenSelector').value;
      if (selectedTokenName) {
        log(`‚úÖ ƒê√£ ch·ªçn token: "${selectedTokenName}"`, 'info');

        // ƒê·ªìng b·ªô lu√¥n Chrome profile c√πng t√™n ƒë·ªÉ Kh·ªüi ƒë·ªông Chrome d√πng ƒë√∫ng profile
        const profileSelect = document.getElementById('profileSelector');
        if (profileSelect) {
          const match = Array.from(profileSelect.options).find(opt => opt.value === selectedTokenName);
          if (match) {
            profileSelect.value = selectedTokenName;
          }
        }
        selectedProfile = selectedTokenName;
        log('üîó Chrome profile s·∫Ω d√πng c√πng t√™n v·ªõi token ƒë√£ ch·ªçn', 'info');
      }
    }

    async function openFlowTab() {
      log('üé¨ ƒêang m·ªü Flow tab...', 'info');
      try {
        const res = await fetch('/api/open-flow-tab', { method: 'POST' });
        const data = await res.json();
        if (data.success) {
          log('‚úÖ Flow tab ƒë√£ ƒë∆∞·ª£c m·ªü!', 'success');
        } else {
          log('‚ùå L·ªói m·ªü Flow tab: ' + data.error, 'error');
        }
      } catch (err) {
        log('‚ùå L·ªói: ' + err.message, 'error');
      }
    }

    // ============================================
    // PROJECT MANAGEMENT
    // ============================================
    function parseProjectLink() {
      const link = document.getElementById('projectLink').value.trim();
      if (!link) {
        log('‚ö†Ô∏è Vui l√≤ng paste link project!', 'warning');
        return;
      }

      log('üîç ƒêang parse link...', 'info');

      // Parse project ID: /project/[uuid]
      const projectMatch = link.match(/\/project\/([a-f0-9-]{36})/i);
      if (projectMatch) {
        const projectId = projectMatch[1];
        document.getElementById('projectId').value = projectId;
        log(`‚úÖ Project ID: ${projectId}`, 'success');
      } else {
        log('‚ùå Kh√¥ng t√¨m th·∫•y Project ID trong link!', 'error');
      }

      // Parse scene ID: /scenes/[uuid] (FIXED: support both /scene/ and /scenes/)
      const sceneMatch = link.match(/\/scenes?\/([a-f0-9-]{36})/i) || link.match(/[?&]sceneId=([a-f0-9-]{36})/i);
      if (sceneMatch) {
        const sceneId = sceneMatch[1];
        document.getElementById('sceneId').value = sceneId;
        log(`‚úÖ Scene ID: ${sceneId}`, 'success');
      } else {
        log('‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y Scene ID trong link. Vui l√≤ng nh·∫≠p th·ªß c√¥ng.', 'warning');
      }

      // Auto-save project link to localStorage
      try {
        localStorage.setItem('last_project_link', link);
        log('üíæ Project link ƒë√£ ƒë∆∞·ª£c l∆∞u t·ª± ƒë·ªông', 'info');
      } catch (err) {
        console.error('Failed to save project link:', err);
      }
    }

    async function loadSession() {
      const projectId = document.getElementById('projectId').value.trim();
      const sceneId = document.getElementById('sceneId').value.trim();

      if (!projectId || !sceneId) {
        log('‚ö†Ô∏è Vui l√≤ng nh·∫≠p Project ID v√† Scene ID!', 'warning');
        alert('Vui l√≤ng paste link project v√† parse, ho·∫∑c nh·∫≠p Project ID v√† Scene ID th·ªß c√¥ng!');
        return;
      }

      state.projectId = projectId;
      state.sceneId = sceneId;
      state.aspectRatio = document.getElementById('aspectRatio').value;

      log(`üìÅ ƒêang x√°c nh·∫≠n project...`, 'info');
      try {
        const res = await fetch('/api/veo3/set-project', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ projectId, sceneId })
        });
        const data = await res.json();
        if (data.success) {
          log(`‚úÖ Project ƒë√£ x√°c nh·∫≠n: ${projectId.substring(0, 8)}..., Scene: ${sceneId.substring(0, 8)}...`, 'success');
          updateStatus('sessionStatus', 'active');
        } else {
          log('‚ùå L·ªói x√°c nh·∫≠n project: ' + data.error, 'error');
        }
      } catch (err) {
        log('‚ùå L·ªói: ' + err.message, 'error');
      }
    }

    // ============================================
    // PROMPT PARSING
    // ============================================
    function parseImagePrompts() {
      const text = document.getElementById('imagePrompts').value.trim();
      if (!text) return [];

      const lines = text.split('\n').filter(line => line.trim());
      const prompts = [];

      for (const line of lines) {
        // Check if prompt has (Continue) - preserve it!
        const hasContinue = /^\(continue\)/i.test(line.trim());

        // Remove numbering patterns but KEEP (Continue)
        let cleaned = line
          .replace(/^·∫£nh\s*\d+[:.]\s*/i, '')      // "·∫£nh 2: "
          .replace(/^pic\s*\d+[:.]\s*/i, '')      // "pic 4: "
          .replace(/^\d+\.\s*/, '')               // "1. "
          .replace(/^#\d+[:.]\s*/i, '')           // "#1:" or "#1."
          .replace(/^prompt\s*\d+[:.]\s*/i, '')   // "Prompt 1:" or "prompt 1."
          .trim();

        if (cleaned) {
          prompts.push(cleaned);
        }
      }

      return prompts;
    }

    function parseVideoPrompts() {
      const text = document.getElementById('videoPrompts').value.trim();
      if (!text) return [];

      const lines = text.split('\n').filter(line => line.trim());
      return lines;
    }

    function submitImagePrompts() {
      // Validate project names
      const imageProjectName = document.getElementById('imageProjectName').value.trim();
      if (!imageProjectName) {
        alert('‚ö†Ô∏è Vui l√≤ng nh·∫≠p T√™n Project ·∫£nh (folder) tr∆∞·ªõc khi submit!');
        log('‚ùå Thi·∫øu t√™n project ·∫£nh!', 'error');
        return;
      }

      const allPrompts = parseImagePrompts();

      // NEW LOGIC: m·ªói l·∫ßn Submit ch·ªâ l·∫•y ph·∫ßn ƒëu√¥i m·ªõi th√™m v√†o textarea
      // state.imagePromptCursor = s·ªë d√≤ng prompt ƒë√£ submit ·ªü c√°c l·∫ßn tr∆∞·ªõc
      const startIndex = state.imagePromptCursor || 0;
      const newPrompts = allPrompts.slice(startIndex);

      if (newPrompts.length === 0) {
        log(`‚ö†Ô∏è Kh√¥ng c√≥ prompts m·ªõi ƒë·ªÉ th√™m (ƒë√£ submit ${state.imagePromptCursor} d√≤ng, textarea hi·ªán c√≥ ${allPrompts.length} d√≤ng)`, 'warning');
        return;
      }

      state.imageQueue.push(...newPrompts);
      state.imagePromptCursor = allPrompts.length;

      log(`‚úÖ ƒê√£ th√™m ${newPrompts.length} image prompts m·ªõi v√†o queue (t·ªïng prompt trong textarea: ${allPrompts.length})`, 'success');

      // Keep textarea content for tracking (don't clear)

      updateStats();

      // Start processing if not already running
      if (!state.imageQueueProcessing) {
        processImageQueue();
      }
    }

    function submitVideoPrompts() {
      const newPrompts = parseVideoPrompts();
      if (newPrompts.length === 0) {
        log('‚ö†Ô∏è Kh√¥ng c√≥ video prompts m·ªõi ƒë·ªÉ th√™m', 'warning');
        return;
      }

      // CRITICAL FIX: Update prompts for videos in queue (not yet generated)
      let updatedCount = 0;

      // Update existing queued videos with new prompts
      for (let i = 0; i < Math.min(state.videoQueue.length, newPrompts.length); i++) {
        const oldPrompt = state.videoQueue[i].prompt;
        const newPrompt = newPrompts[i];

        if (oldPrompt !== newPrompt) {
          state.videoQueue[i].prompt = newPrompt;
          updatedCount++;
          log(`üîÑ [Video ${state.videoQueue[i].sceneIndex + 1}] Prompt updated: "${newPrompt.substring(0, 40)}..."`, 'info');
        }
      }

      // If there are more new prompts than existing queue items, add them
      if (newPrompts.length > state.videoQueue.length) {
        // Need to create new video tasks for the additional prompts
        // This requires having image pairs available
        const startIndex = state.videoQueue.length;
        for (let i = startIndex; i < newPrompts.length; i++) {
          const img1 = state.images[i];
          const img2 = state.images[i + 1];

          if (img1 && img2) {
            state.videoQueue.push({
              img1,
              img2,
              prompt: newPrompts[i],
              sceneIndex: i,
              attempts: 0
            });
            updatedCount++;
            log(`‚ûï [Video ${i + 1}] Added new video with prompt: "${newPrompts[i].substring(0, 40)}..."`, 'success');
          } else {
            log(`‚ö†Ô∏è [Video ${i + 1}] Kh√¥ng th·ªÉ th√™m - thi·∫øu ·∫£nh (c·∫ßn ·∫£nh ${i + 1} v√† ${i + 2})`, 'warning');
            break;
          }
        }
      }

      if (updatedCount > 0) {
        log(`‚úÖ Video prompts ƒë√£ c·∫≠p nh·∫≠t: ${updatedCount} videos`, 'success');
        updateStats();
        updateVideoQueueDisplay();

        // Start video queue if not already processing
        if (!state.videoQueueProcessing) {
          processVideoQueue();
        }
      } else {
        log(`‚ÑπÔ∏è Kh√¥ng c√≥ thay ƒë·ªïi trong video prompts`, 'info');
      }
    }

    // ============================================
    // IMAGE GENERATION WITH RETRY
    // ============================================

    // Generate image with optional reference (copied from index2)
    async function generateSingleWithReference(prompt, aspectRatio, seed, refImage) {
      const payload = { prompt, aspectRatio };
      if (seed) payload.seed = seed;

      // CRITICAL: Add laneName from selected lane to use specific token
      const selectedLaneName = document.getElementById('selectedLane').value;
      if (selectedLaneName) {
        payload.laneName = selectedLaneName;
      }

      const useReference = refImage;

      if (useReference) {
        // CRITICAL: editImage API requires:
        // - caption: prompt of PREVIOUS image (reference)
        // - userInstruction: CURRENT prompt
        // - seed: null (not used)
        const editPayload = {
          prompt: prompt,  // userInstruction (current prompt)
          captionPrompt: useReference.captionPrompt || prompt,  // caption (previous prompt)
          referenceImage: useReference.imageUrl,
          aspectRatio: aspectRatio,
          generationId: useReference.generationId,
          seed: null  // CRITICAL: seed is null for editImage
        };

        // Add laneName if selected
        if (selectedLaneName) {
          editPayload.laneName = selectedLaneName;
        }

        console.log(`Using editImage API with caption: "${editPayload.captionPrompt.substring(0, 30)}..." and instruction: "${prompt.substring(0, 30)}..."`);

        const res = await fetch('/api/edit', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(editPayload)
        });
        return await res.json();
      } else {
        const res = await fetch('/api/generate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        return await res.json();
      }
    }

    async function generateImageWithRetry(prompt, index, attempts = 0) {
      const taskInfo = { prompt, index };
      state.activeImageTasks.push(taskInfo);
      updateStats();

      try {
        // Check if prompt has (Continue) - support multiple formats:
        // - "(Continue) prompt"
        // - "·∫¢nh 2: (Continue) prompt"
        // - "3. (Continue) prompt"
        // - "#1. prompt"
        const isContinue = /\(continue\)/i.test(prompt);

        // Strip all prefixes and (Continue) marker
        let cleanPrompt = prompt;
        if (isContinue) {
          // Remove patterns like "·∫¢nh 2:", "3.", "#1.", etc., then remove (Continue)
          cleanPrompt = prompt
            .replace(/^(·∫¢nh\s+\d+:\s*)/i, '')  // Remove "·∫¢nh X:"
            .replace(/^#?\d+\.\s*/, '')         // Remove "#X." or "X."
            .replace(/\(continue\)\s*/i, '')    // Remove "(Continue)"
            .trim();
        }

        // Append common image prompt if exists
        const commonPrompt = document.getElementById('commonImagePrompt').value.trim();
        if (commonPrompt) {
          cleanPrompt = cleanPrompt + '. ' + commonPrompt;
        }

        let referenceImage = null;

        // If (continue) and we have a previous image, use it as reference
        if (isContinue) {
          // CRITICAL FIX: Find closest AVAILABLE previous image
          // If image 7 failed, image 8 (Continue) should use image 6 as reference
          let referenceIndex = index - 1;
          let prevImage = null;

          while (referenceIndex >= 0 && !prevImage) {
            prevImage = state.images.find(img => img.index === referenceIndex);
            if (!prevImage) {
              referenceIndex--; // Try previous index
            }
          }

          if (prevImage && prevImage.url && prevImage.generationId) {
            if (prevImage.index === index - 1) {
              log(`\nüé® [·∫¢nh ${index + 1}] ƒêang gen (CONTINUE t·ª´ ·∫£nh ${prevImage.index + 1}, attempt ${attempts + 1}/${MAX_RETRIES}): "${cleanPrompt.substring(0, 50)}..."`, 'info');
            } else {
              // Fallback to earlier image
              log(`\nüé® [·∫¢nh ${index + 1}] ƒêang gen (CONTINUE t·ª´ ·∫£nh ${prevImage.index + 1} - ·∫£nh ${index} kh√¥ng c√≥, attempt ${attempts + 1}/${MAX_RETRIES}): "${cleanPrompt.substring(0, 50)}..."`, 'info');
            }

            // CRITICAL: For editImage API, we need:
            // - caption: prompt of PREVIOUS image (reference)
            // - userInstruction: CURRENT prompt (cleanPrompt)
            // - seed: null (not used in edit mode)
            referenceImage = {
              imageUrl: prevImage.url,
              generationId: prevImage.generationId,
              captionPrompt: prevImage.prompt  // Prompt of previous image
            };
          } else {
            log(`‚ö†Ô∏è [·∫¢nh ${index + 1}] Kh√¥ng t√¨m th·∫•y ·∫£nh tr∆∞·ªõc ƒë·ªÉ Continue, d√πng seed m·ªõi`, 'warning');
          }
        }

        if (!isContinue) {
          log(`\nüé® [·∫¢nh ${index + 1}] ƒêang gen (attempt ${attempts + 1}/${MAX_RETRIES}): "${cleanPrompt.substring(0, 50)}..."`, 'info');
        }

        // Use generateSingleWithReference (like index2)
        const seed = Math.floor(Math.random() * 1000000);
        const data = await generateSingleWithReference(
          cleanPrompt,
          state.aspectRatio,
          seed,
          referenceImage
        );

        if (data.success) {
          const logMsg = referenceImage
            ? `‚úÖ [·∫¢nh ${index + 1}] Gen th√†nh c√¥ng (Continue t·ª´ ·∫£nh ${index})!`
            : `‚úÖ [·∫¢nh ${index + 1}] Gen th√†nh c√¥ng! Seed: ${seed}`;
          log(logMsg, 'success');

          const imageData = {
            url: data.imageUrl,
            prompt: cleanPrompt,
            seed: seed,
            generationId: data.generationId,
            index: index,
            timestamp: Date.now(),
            isContinue: isContinue,
            uploadedMediaId: null  // Will be set when uploaded to Veo3
          };

          state.images.push(imageData);

          // Only increment imageCount if this is a NEW image (not a retry)
          // For retry, index < imageCount, so don't increment again
          if (index >= state.imageCount) {
            state.imageCount++;
          }

          updateStats();
          addImageToGallery(imageData);

          // Auto-save image
          await autoSaveImage(imageData);

          // Save mediaID to file
          await saveMediaIdToFile(imageData);

          // Remove from active tasks
          const taskIdx = state.activeImageTasks.findIndex(t => t.index === index);
          if (taskIdx >= 0) state.activeImageTasks.splice(taskIdx, 1);
          updateStats();

          // Check if we can create video tasks
          checkAndCreateVideoTasks();

          // CRITICAL: Retry any failed videos that were waiting for this image
          retryVideosWaitingForImage(index);

          return imageData;
        } else {
          throw new Error(data.error || 'Unknown error');
        }
      } catch (err) {
        log(`‚ùå [·∫¢nh ${index + 1}] L·ªói: ${err.message}`, 'error');

        // Remove from active tasks
        const taskIdx = state.activeImageTasks.findIndex(t => t.index === index);
        if (taskIdx >= 0) state.activeImageTasks.splice(taskIdx, 1);

        // Retry logic
        if (attempts < MAX_RETRIES - 1) {
          log(`üîÑ [·∫¢nh ${index + 1}] Retry sau 2s...`, 'warning');
          await sleep(2000);
          return generateImageWithRetry(prompt, index, attempts + 1);
        } else {
          // Max retries reached, add to failed list
          log(`‚ùå [·∫¢nh ${index + 1}] ƒê√£ th·∫•t b·∫°i sau ${MAX_RETRIES} l·∫ßn th·ª≠`, 'error');
          state.failedImages.push({
            prompt,
            index,
            error: err.message,
            attempts: MAX_RETRIES
          });

          // CRITICAL: Still increment imageCount to reserve this index
          // This keeps index synchronized with prompt position
          state.imageCount++;

          // CRITICAL: Auto-pause workflow when image fails after max retries
          // This forces user to manually fix before continuing
          if (state.isRunning && !state.paused) {
            state.paused = true;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('resumeBtn').disabled = false;
            log(`‚è∏Ô∏è AUTO-PAUSE: ·∫¢nh ${index + 1} ƒë√£ th·∫•t b·∫°i sau ${MAX_RETRIES} l·∫ßn. Workflow t·∫°m d·ª´ng ƒë·ªÉ user x·ª≠ l√Ω.`, 'error');
            log(`üí° H√£y Retry ho·∫∑c Regen ·∫£nh ${index + 1}, sau ƒë√≥ ·∫•n RESUME ƒë·ªÉ ti·∫øp t·ª•c.`, 'info');
          }

          updateStats();
          return null;
        }
      }
    }

    async function autoSaveImage(imageData) {
      const basePath = document.getElementById('imageSavePath').value.trim();
      const projectName = document.getElementById('imageProjectName').value.trim();

      if (!basePath || !projectName) {
        log(`‚ö†Ô∏è Ch∆∞a c√†i ƒë·∫∑t ƒë∆∞·ªùng d·∫´n l∆∞u ·∫£nh. Skip auto-save.`, 'warning');
        return;
      }

      const refName = `${imageData.index + 1}`; // 1, 2, 3, 4...

      log(`üíæ ƒêang l∆∞u ·∫£nh ${refName}.jpg...`, 'info');

      try {
        const res = await fetch('/api/save-reference', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            imageUrl: imageData.url,
            refFolderPath: basePath,
            projectName: projectName,
            refName: refName,
            isRegen: false
          })
        });

        const data = await res.json();

        if (data.success) {
          log(`‚úÖ ·∫¢nh ƒë√£ l∆∞u: ${data.path}`, 'success');
          imageData.savedPath = data.path;
        } else {
          log(`‚ùå L·ªói l∆∞u ·∫£nh: ${data.error}`, 'error');
        }
      } catch (err) {
        log(`‚ùå L·ªói l∆∞u ·∫£nh: ${err.message}`, 'error');
      }
    }

    async function saveMediaIdToFile(imageData) {
      const basePath = document.getElementById('imageSavePath').value.trim();
      const projectName = document.getElementById('imageProjectName').value.trim();

      if (!basePath || !projectName || !imageData.generationId) {
        return; // Skip if no path or no generationId
      }

      try {
        const res = await fetch('/api/save-media-id', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            folderPath: basePath,
            projectName: projectName,
            index: imageData.index + 1, // 1-based index
            mediaId: imageData.generationId
          })
        });

        const data = await res.json();

        if (data.success) {
          log(`üìù MediaID ${imageData.index + 1} ƒë√£ l∆∞u v√†o file txt`, 'info');
        }
      } catch (err) {
        // Silent fail - kh√¥ng ·∫£nh h∆∞·ªüng workflow ch√≠nh
      }
    }

    function addImageToGallery(imageData) {
      const gallery = document.getElementById('imageGallery');
      const item = document.createElement('div');
      item.className = 'gallery-item';
      item.innerHTML = `
        <img src="${imageData.url}" alt="Image ${imageData.index + 1}">
        <div class="gallery-item-info">
          <div><span class="label">·∫¢nh ${imageData.index + 1}:</span> ${imageData.isContinue ? 'üîÑ ' : ''}${imageData.prompt.substring(0, 25)}...</div>
          <div><span class="label">${imageData.isContinue ? 'Continue t·ª´' : 'Seed'}:</span> ${imageData.isContinue ? `·∫¢nh ${imageData.index}` : imageData.seed}</div>
          ${imageData.savedPath ? `<div><span class="label">üíæ</span> ƒê√£ l∆∞u</div>` : ''}
        </div>
      `;
      gallery.appendChild(item);
    }

    // ============================================
    // VIDEO GENERATION WITH RETRY
    // ============================================
    function checkAndCreateVideoTasks() {
      // Check if we have consecutive image pairs that don't have videos yet
      const allVideoPrompts = parseVideoPrompts();
      const useFixedPrompt = document.getElementById('useFixedVideoPrompt').checked;
      const fixedPrompt = useFixedPrompt && allVideoPrompts.length > 0 ? allVideoPrompts[0] : null;

      // CRITICAL FIX: Count how many unique video scenes have been generated
      // This helps us skip old prompts when user pastes again
      const uniqueScenes = new Set(state.videos.map(v => v.sceneIndex));
      const videosGenerated = uniqueScenes.size;

      // Only take NEW prompts (skip prompts for already generated videos)
      const videoPrompts = allVideoPrompts.slice(videosGenerated);

      // CRITICAL: Loop based on imageCount (prompts processed), not state.images.length
      // This ensures we create video tasks even when images are missing/failed
      const maxScenes = state.imageCount > 0 ? state.imageCount - 1 : 0;

      for (let sceneIndex = 0; sceneIndex < maxScenes; sceneIndex++) {
        // Try to find images by index (may not exist if failed)
        const img1 = state.images.find(img => img.index === sceneIndex);
        const img2 = state.images.find(img => img.index === sceneIndex + 1);

        // Check if video task already exists for this pair
        const alreadyQueued = state.videoQueue.some(v => v.sceneIndex === sceneIndex);
        const alreadyGenerated = state.videos.some(v => v.sceneIndex === sceneIndex);
        const currentlyGenerating = state.activeVideoTasks.some(v => v.sceneIndex === sceneIndex);
        const alreadyFailed = state.failedVideos.some(v => v.sceneIndex === sceneIndex);

        if (!alreadyQueued && !alreadyGenerated && !currentlyGenerating && !alreadyFailed) {
          // Determine prompt
          let videoPrompt;
          if (fixedPrompt) {
            videoPrompt = fixedPrompt;
          } else {
            // Map sceneIndex to the correct prompt index
            const promptIndex = sceneIndex - videosGenerated;
            if (promptIndex >= 0 && promptIndex < videoPrompts.length) {
              videoPrompt = videoPrompts[promptIndex];
            } else {
              // No prompt available, skip
              continue;
            }
          }

          // Create video task even if images are missing
          // generateVideoWithRetry will handle missing images and add to failedVideos
          state.videoQueue.push({
            img1: img1 || { index: sceneIndex, url: null }, // Placeholder if missing
            img2: img2 || { index: sceneIndex + 1, url: null }, // Placeholder if missing
            prompt: videoPrompt,
            sceneIndex,
            attempts: 0
          });

          if (!img1 || !img2) {
            const missingImgs = [];
            if (!img1) missingImgs.push(`·∫£nh ${sceneIndex + 1}`);
            if (!img2) missingImgs.push(`·∫£nh ${sceneIndex + 2}`);
            log(`üìã [Video ${sceneIndex + 1}] Th√™m v√†o queue (thi·∫øu ${missingImgs.join(', ')})`, 'warning');
          } else {
            log(`üìã [Video ${sceneIndex + 1}] Th√™m v√†o queue (·∫¢nh ${img1.index + 1} + ${img2.index + 1})`, 'info');
          }
        }
      }

      updateStats();

      // Start video processing if not already running
      if (!state.videoQueueProcessing) {
        processVideoQueue();
      }
    }

    async function generateVideoWithRetry(task) {
      const { img1, img2, prompt, sceneIndex, attempts = 0 } = task;

      // Check if images still exist (not failed/deleted)
      const hasImg1 = state.images.some(img => img.index === img1.index);
      const hasImg2 = state.images.some(img => img.index === img2.index);

      if (!hasImg1 || !hasImg2) {
        const missingImages = [];
        if (!hasImg1) missingImages.push(`·∫¢nh ${img1.index + 1}`);
        if (!hasImg2) missingImages.push(`·∫¢nh ${img2.index + 1}`);

        log(`‚ùå [Video ${sceneIndex + 1}] Thi·∫øu ·∫£nh tham chi·∫øu: ${missingImages.join(', ')}`, 'error');

        state.failedVideos.push({
          img1,
          img2,
          prompt,
          sceneIndex,
          error: `Thi·∫øu ·∫£nh tham chi·∫øu: ${missingImages.join(', ')}`,
          reason: `Thi·∫øu ·∫£nh tham chi·∫øu: ${missingImages.join(', ')}`,
          attempts: 0
        });
        updateStats();
        return null;
      }

      state.activeVideoTasks.push(task);
      updateStats();

      try {
        log(`\nüé¨ [Video ${sceneIndex + 1}] ƒêang gen (attempt ${attempts + 1}/${MAX_RETRIES}) t·ª´ ·∫£nh ${img1.index + 1} + ${img2.index + 1}...`, 'info');
        log(`üìù [Video ${sceneIndex + 1}] Prompt: "${prompt.substring(0, 50)}..."`, 'info');

        // Check for continue/extend
        const isContinue = /^\(continue\)/i.test(prompt);

        if (isContinue && state.lastVideoMediaId) {
          let cleanPrompt = prompt.replace(/^\(continue\)\s*/i, '').trim();

          // Append common video prompt if exists
          const commonVideoPrompt = document.getElementById('commonVideoPrompt').value.trim();
          if (commonVideoPrompt) {
            cleanPrompt = cleanPrompt + '. ' + commonVideoPrompt;
          }

          const videos = await extendVideo(state.lastVideoMediaId, cleanPrompt, sceneIndex);

          if (videos && videos.length > 0) {
            // Success
            const taskIdx = state.activeVideoTasks.findIndex(t => t.sceneIndex === sceneIndex);
            if (taskIdx >= 0) state.activeVideoTasks.splice(taskIdx, 1);
            updateStats();
            return videos;
          } else {
            throw new Error('Extend video failed');
          }
        } else {
          // Normal video generation
          let cleanPrompt = prompt.replace(/^\(continue\)\s*/i, '').trim();

          // Append common video prompt if exists
          const commonVideoPrompt = document.getElementById('commonVideoPrompt').value.trim();
          if (commonVideoPrompt) {
            cleanPrompt = cleanPrompt + '. ' + commonVideoPrompt;
          }

          // BREAKTHROUGH: Use Whisk's generationId directly as mediaID!
          // No need to upload - Whisk's mediaID works directly with Veo3
          const mediaId1 = img1.generationId;
          const mediaId2 = img2.generationId;

          if (!mediaId1 || !mediaId2) {
            throw new Error(`·∫¢nh thi·∫øu generationId (img1: ${!!mediaId1}, img2: ${!!mediaId2})`);
          }

          log(`üöÄ [Video ${sceneIndex + 1}] D√πng tr·ª±c ti·∫øp mediaID t·ª´ Whisk (b·ªè qua upload)`, 'info');

          // Generate multiple variants (gen all, but only preview variant A)
          const numVariants = 2;
          const seeds = Array.from({ length: numVariants }, () => Math.floor(Math.random() * 65536));

          log(`üìä [Video ${sceneIndex + 1}] Gen ${numVariants} variants (l∆∞u t·∫•t c·∫£, preview variant A)...`, 'info');

          const videoRes = await fetch('/api/veo3/generate-start-end', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              projectId: state.projectId,
              sceneId: state.sceneId,
              startImageMediaId: mediaId1,
              endImageMediaId: mediaId2,
              prompt: cleanPrompt,
              aspectRatio: state.aspectRatio.replace('IMAGE_', 'VIDEO_'),
              seeds: seeds
            })
          });

          // Check for 429 rate limit
          if (videoRes.status === 429) {
            throw new Error('Rate limit 429: Too many requests');
          }

          const videoData = await videoRes.json();

          if (videoData.success && videoData.operations && videoData.operations.length > 0) {
            log(`‚úÖ [Video ${sceneIndex + 1}] ƒê√£ b·∫Øt ƒë·∫ßu gen ${videoData.operations.length} variants! ƒêang poll...`, 'success');

            // Poll ALL variants
            const videos = [];
            for (let i = 0; i < videoData.operations.length; i++) {
              const operation = videoData.operations[i];
              const video = await pollVideoStatus(operation.operation.name, sceneIndex, i);

              if (video) {
                videos.push({
                  ...video,
                  sceneIndex: sceneIndex,
                  variantIndex: i,
                  prompt: cleanPrompt
                });
              }
            }

            if (videos.length > 0) {
              // Auto-download ALL variants (but only preview variant A in gallery)
              await autoDownloadVideos(videos, sceneIndex, cleanPrompt);

              state.lastVideoMediaId = videos[0].mediaId;

              // Remove from active tasks
              const taskIdx = state.activeVideoTasks.findIndex(t => t.sceneIndex === sceneIndex);
              if (taskIdx >= 0) state.activeVideoTasks.splice(taskIdx, 1);

              // CRITICAL: Remove from failedVideos if exists (in case of retry success)
              const failedIdx = state.failedVideos.findIndex(v => v.sceneIndex === sceneIndex);
              if (failedIdx >= 0) {
                state.failedVideos.splice(failedIdx, 1);
                log(`‚úÖ [Video ${sceneIndex + 1}] ƒê√£ x√≥a kh·ªèi failed list sau retry th√†nh c√¥ng`, 'success');
              }

              updateStats();

              return videos;
            } else {
              throw new Error('Poll all videos failed');
            }
          } else {
            throw new Error(videoData.error || 'Unknown error');
          }
        }
      } catch (err) {
        log(`‚ùå [Video ${sceneIndex + 1}] L·ªói: ${err.message}`, 'error');

        // Remove from active tasks
        const taskIdx = state.activeVideoTasks.findIndex(t => t.sceneIndex === sceneIndex);
        if (taskIdx >= 0) state.activeVideoTasks.splice(taskIdx, 1);

        // Check if error is 429 (rate limit)
        const is429 = err.message.includes('429') || err.message.toLowerCase().includes('rate limit');

        if (is429) {
          // CRITICAL: Block all new video generation on 429
          state.videoGenerationBlocked = true;
          log(`üö´ [Video ${sceneIndex + 1}] 429 detected! Blocking new requests...`, 'error');
        }

        // Retry logic
        if (attempts < MAX_RETRIES - 1) {
          let retryDelay;
          if (is429) {
            // 429 retry delays: 10s, 20s, 30s
            const retryDelays = [10000, 20000, 30000];
            retryDelay = retryDelays[attempts] || 30000;
          } else {
            retryDelay = 3000;
          }
          const delaySeconds = Math.round(retryDelay / 1000);

          log(`üîÑ [Video ${sceneIndex + 1}] ${is429 ? '‚ö†Ô∏è Rate limit (429)! ' : ''}Retry l·∫ßn ${attempts + 1} sau ${delaySeconds}s...`, 'warning');
          await sleep(retryDelay);
          task.attempts = attempts + 1;

          const result = await generateVideoWithRetry(task);

          // Unblock after retry completes (whether success or fail)
          if (is429) {
            state.videoGenerationBlocked = false;
            log(`‚úÖ Unblocked video generation after retry`, 'info');
          }

          return result;
        } else {
          // Max retries reached, add to failed list
          log(`‚ùå [Video ${sceneIndex + 1}] ƒê√£ th·∫•t b·∫°i sau ${MAX_RETRIES} l·∫ßn th·ª≠`, 'error');
          state.failedVideos.push({
            img1,
            img2,
            prompt,
            sceneIndex,
            error: err.message,
            attempts: MAX_RETRIES
          });
          updateStats();

          // Unblock if this was 429
          if (is429) {
            state.videoGenerationBlocked = false;
            log(`‚úÖ Unblocked video generation after max retries`, 'info');
          }

          return null;
        }
      }
    }

    async function autoDownloadVideos(videos, sceneIndex, prompt) {
      const basePath = document.getElementById('videoSavePath').value.trim();
      const projectName = document.getElementById('videoProjectName').value.trim();

      if (!basePath || !projectName) {
        log(`‚ö†Ô∏è Ch∆∞a c√†i ƒë·∫∑t ƒë∆∞·ªùng d·∫´n l∆∞u video. Skip auto-download.`, 'warning');
        // Still add variant A to gallery for preview
        for (const video of videos) {
          if (video.variantIndex === 0) {
            addVideoToGallery(video, sceneIndex, prompt);
          }
        }
        return;
      }

      log(`üì• ƒêang t·∫£i ${videos.length} videos v·ªÅ m√°y...`, 'info');

      for (const video of videos) {
        // All variants: a, b, c, d...
        const variantLetter = String.fromCharCode(97 + video.variantIndex); // a, b, c, d
        const filename = `${sceneIndex + 1}${variantLetter}.mp4`; // 1a.mp4, 1b.mp4, 2a.mp4, 2b.mp4...

        // Determine output directory based on variant
        let outputDir = basePath + '\\' + projectName;
        if (video.variantIndex > 0) {
          // Variants b, c, d go to Tuy chon B/C/D folders
          const folderLetter = String.fromCharCode(66 + video.variantIndex - 1); // B, C, D
          outputDir += `\\Tuy chon ${folderLetter}`;
        }

        log(`üì• ƒêang t·∫£i ${filename}...`, 'info');

        try {
          const res = await fetch('/api/veo3/download-video', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              fifeUrl: video.url,
              mediaId: video.mediaId,
              sceneIndex: sceneIndex,
              variantIndex: video.variantIndex,
              outputDir: outputDir
            })
          });

          const data = await res.json();

          if (data.success) {
            log(`‚úÖ Video ${filename} ƒë√£ l∆∞u: ${outputDir}`, 'success');
            video.savedPath = `${outputDir}\\${filename}`;

            // Only add variant A to gallery for preview (keep UI clean)
            if (video.variantIndex === 0) {
              addVideoToGallery(video, sceneIndex, prompt);
            }

            state.videos.push(video);
            state.videoCount++;
            updateStats();
          } else {
            log(`‚ùå L·ªói t·∫£i ${filename}: ${data.error}`, 'error');
          }
        } catch (err) {
          log(`‚ùå L·ªói t·∫£i ${filename}: ${err.message}`, 'error');
        }
      }
    }

    async function extendVideo(previousMediaId, videoPrompt, sceneIndex) {
      log(`üîÑ [Video ${sceneIndex + 1}] ƒêang extend t·ª´ video tr∆∞·ªõc...`, 'info');

      try {
        const res = await fetch('/api/veo3/extend-video', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            clientContext: {
              projectId: state.projectId,
              tool: 'PINHOLE',
              userPaygateTier: 'PAYGATE_TIER_TWO'
            },
            requests: [{
              textInput: { prompt: videoPrompt },
              videoInput: {
                mediaId: previousMediaId,
                startFrameIndex: 168,
                endFrameIndex: 191
              },
              videoModelKey: 'veo_3_1_extend_fast_landscape_ultra',
              aspectRatio: state.aspectRatio.replace('IMAGE_', 'VIDEO_'),
              seed: Math.floor(Math.random() * 65536),
              metadata: { sceneId: state.sceneId }
            }]
          })
        });

        const data = await res.json();

        if (data.success && data.operations && data.operations.length > 0) {
          log(`‚úÖ [Video ${sceneIndex + 1}] Extend ƒë√£ b·∫Øt ƒë·∫ßu! ƒêang poll...`, 'success');

          const operation = data.operations[0];
          const video = await pollVideoStatus(operation.operation.name, sceneIndex, 0);

          if (video) {
            video.sceneIndex = sceneIndex;
            video.variantIndex = 0;
            video.isExtended = true;
            video.prompt = videoPrompt;

            await autoDownloadVideos([video], sceneIndex, videoPrompt);

            state.lastVideoMediaId = video.mediaId;
            return [video];
          }
        }

        return null;
      } catch (err) {
        log(`‚ùå [Video ${sceneIndex + 1}] L·ªói extend: ${err.message}`, 'error');
        return null;
      }
    }

    async function uploadImageToVeo3(imageData) {
      // CRITICAL: Check if already uploaded to avoid spamming Google API
      if (imageData.uploadedMediaId) {
        log(`‚ôªÔ∏è D√πng l·∫°i mediaId ƒë√£ upload (·∫£nh ${imageData.index + 1}): ${imageData.uploadedMediaId.substring(0, 20)}...`, 'info');
        return imageData.uploadedMediaId;
      }

      try {
        log(`üì§ ƒêang upload ·∫£nh ${imageData.index + 1} l√™n Veo3...`, 'info');

        const res = await fetch(imageData.url);
        const blob = await res.blob();
        const base64 = await blobToBase64(blob);

        const uploadRes = await fetch('/api/veo3/upload-cropped-image', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            imageBase64: base64,
            aspectRatio: state.aspectRatio.replace('IMAGE_', 'VIDEO_')
          })
        });

        const data = await uploadRes.json();

        if (data.success) {
          // CRITICAL: Save uploadedMediaId to avoid re-uploading
          imageData.uploadedMediaId = data.mediaId;
          log(`‚úÖ Upload th√†nh c√¥ng ·∫£nh ${imageData.index + 1}, mediaId: ${data.mediaId.substring(0, 20)}...`, 'success');
          return data.mediaId;
        } else {
          log(`‚ùå L·ªói upload ·∫£nh ${imageData.index + 1}: ${data.error}`, 'error');
          return null;
        }
      } catch (err) {
        log(`‚ùå L·ªói upload ·∫£nh ${imageData.index + 1}: ${err.message}`, 'error');
        return null;
      }
    }

    function blobToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }

    async function pollVideoStatus(operationName, sceneIndex, variantIndex, maxAttempts = 120) {
      const variantLetter = String.fromCharCode(97 + variantIndex);
      const videoLabel = `${sceneIndex + 1}${variantLetter}`;

      for (let i = 0; i < maxAttempts; i++) {
        await sleep(10000); // Poll every 10 seconds

        try {
          const res = await fetch('/api/veo3/check-status', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              operations: [{ operation: { name: operationName } }]
            })
          });

          const data = await res.json();

          if (data.success && data.operations && data.operations.length > 0) {
            const op = data.operations[0];

            if (op.status === 'MEDIA_GENERATION_STATUS_SUCCESSFUL' || op.status === 'SUCCESSFUL') {
              log(`‚úÖ [Video ${videoLabel}] Ho√†n th√†nh!`, 'success');
              return op.video;
            }

            if (op.status === 'MEDIA_GENERATION_STATUS_FAILED' || op.status === 'FAILED') {
              log(`‚ùå [Video ${videoLabel}] Th·∫•t b·∫°i!`, 'error');
              return null;
            }

            if (i % 6 === 0) { // Log every minute
              log(`‚è≥ [Video ${videoLabel}] Poll #${i + 1}: ${op.status}`, 'info');
            }
          }
        } catch (err) {
          log(`‚ùå [Video ${videoLabel}] L·ªói poll: ${err.message}`, 'error');
        }
      }

      log(`‚è∞ [Video ${videoLabel}] Timeout sau ${maxAttempts} l·∫ßn`, 'error');
      return null;
    }

    function addVideoToGallery(video, sceneIndex, prompt) {
      const gallery = document.getElementById('videoGallery');
      const item = document.createElement('div');
      item.className = 'gallery-item';

      const videoLabel = `${sceneIndex + 1}a`; // Always variant A

      item.innerHTML = `
        <video src="${video.url}" controls></video>
        <div class="gallery-item-info">
          <div><span class="label">Video ${videoLabel}:</span> ${video.isExtended ? 'Extended' : `·∫¢nh ${sceneIndex + 1}+${sceneIndex + 2}`}</div>
          <div style="font-size: 0.7em;">${prompt.substring(0, 30)}...</div>
          ${video.savedPath ? `<div><span class="label">üíæ</span> ƒê√£ l∆∞u</div>` : ''}
        </div>
      `;
      gallery.appendChild(item);
    }

    // ============================================
    // PARALLEL QUEUE PROCESSING
    // ============================================
    async function processImageQueue() {
      if (state.imageQueueProcessing) return;
      state.imageQueueProcessing = true;

      log('üîÑ Image queue processor started', 'info');

      while (state.isRunning || state.imageQueue.length > 0) {
        // Check if paused
        if (state.paused) {
          await sleep(1000);
          continue;
        }

        if (state.imageQueue.length > 0) {
          const prompt = state.imageQueue.shift();
          const index = state.imageCount; // Use current count as index

          await generateImageWithRetry(prompt, index);
          updateProgress();

          await sleep(2000); // Small delay between images
        } else {
          // No images in queue, wait a bit
          await sleep(1000);
        }

        updateStats();
      }

      state.imageQueueProcessing = false;
      log('‚èπÔ∏è Image queue processor stopped', 'info');
    }

    async function processVideoQueue() {
      if (state.videoQueueProcessing) return;
      state.videoQueueProcessing = true;

      log('üîÑ Video queue processor started (sequential with delay)', 'info');

      while (state.isRunning || state.videoQueue.length > 0 || state.activeVideoTasks.length > 0) {
        // Check if paused
        if (state.paused) {
          await sleep(1000);
          continue;
        }

        // Check if blocked by 429
        if (state.videoGenerationBlocked) {
          log('‚è∏Ô∏è Video generation blocked (429), waiting for retry...', 'warning');
          await sleep(2000);
          continue;
        }

        // Check if we need to wait for delay after last completion
        if (state.lastVideoCompletedAt !== null) {
          const timeSinceCompletion = Date.now() - state.lastVideoCompletedAt;
          const requiredDelay = 5000; // 5 seconds minimum

          if (timeSinceCompletion < requiredDelay) {
            const remainingDelay = requiredDelay - timeSinceCompletion;
            log(`‚è≥ ƒê·ª£i ${Math.round(remainingDelay / 1000)}s sau khi video ho√†n th√†nh...`, 'info');
            await sleep(remainingDelay);
          }

          // Add random delay 5-7s
          const randomDelaySeconds = 5 + Math.random() * 2;
          log(`‚è≥ Random delay ${randomDelaySeconds.toFixed(1)}s tr∆∞·ªõc khi gen video m·ªõi...`, 'info');
          await sleep(randomDelaySeconds * 1000);

          state.lastVideoCompletedAt = null; // Reset after delay
        }

        // Calculate available slots
        const availableSlots = MAX_PARALLEL_VIDEOS - state.activeVideoTasks.length;

        if (availableSlots > 0 && state.videoQueue.length > 0) {
          const task = state.videoQueue.shift(); // Take 1 video at a time

          // If this is the first video, no delay
          // If this is the second video (to fill 2 slots), add delay 5-8s
          if (state.activeVideoTasks.length === 1) {
            const delaySeconds = 5 + Math.random() * 3; // 5-8s
            log(`‚è≥ Delay ${delaySeconds.toFixed(1)}s tr∆∞·ªõc khi g·ª≠i l·ªánh gen video ${task.sceneIndex + 1}...`, 'info');
            await sleep(delaySeconds * 1000);
          }

          // Start video generation (await to handle completion)
          await generateVideoWithRetry(task);

          // After video completes, mark timestamp
          state.lastVideoCompletedAt = Date.now();
        } else {
          // No slots or no tasks, wait a bit
          await sleep(1000);
        }

        updateStats();
      }

      state.videoQueueProcessing = false;
      log('‚èπÔ∏è Video queue processor stopped', 'info');
    }

    // ============================================
    // WORKFLOW CONTROL
    // ============================================
    async function startWorkflow() {
      if (!state.projectId || !state.sceneId) {
        log('‚ö†Ô∏è Vui l√≤ng x√°c nh·∫≠n project tr∆∞·ªõc!', 'warning');
        alert('Vui l√≤ng parse link project v√† x√°c nh·∫≠n tr∆∞·ªõc khi start!');
        return;
      }

      // Validate project names
      const imageProjectName = document.getElementById('imageProjectName').value.trim();
      const videoProjectName = document.getElementById('videoProjectName').value.trim();

      if (!imageProjectName || !videoProjectName) {
        alert('‚ö†Ô∏è Vui l√≤ng nh·∫≠p T√äN PROJECT (folder) cho c·∫£ ·∫¢nh v√† Video tr∆∞·ªõc khi start!');
        log('‚ùå Thi·∫øu t√™n project! ·∫¢nh: ' + (imageProjectName || 'EMPTY') + ', Video: ' + (videoProjectName || 'EMPTY'), 'error');
        return;
      }

      // Check if MediaID mode is enabled
      const useMediaIdMode = document.getElementById('useMediaIdMode').checked;

      if (useMediaIdMode) {
        // MediaID Mode: Skip image generation, use mediaIDs directly
        await startMediaIdWorkflow();
      } else {
        // Normal Mode: Generate images first
        const imagePrompts = parseImagePrompts();

        if (imagePrompts.length === 0 && state.imageQueue.length === 0) {
          log('‚ö†Ô∏è Vui l√≤ng nh·∫≠p image prompts ho·∫∑c click Submit!', 'warning');
          return;
        }

        state.isRunning = true;
        state.paused = false;

        // Add initial prompts to queue n·∫øu ƒë√¢y l√† l·∫ßn ch·∫°y ƒë·∫ßu ti√™n (ch∆∞a submit g√¨)
        if (imagePrompts.length > 0 && state.imageCount === 0 && state.imageQueue.length === 0 && state.imagePromptCursor === 0) {
          const newPrompts = imagePrompts.slice(0);

          state.imageQueue.push(...newPrompts);
          state.imagePromptCursor = imagePrompts.length;
          log(`‚úÖ Added ${newPrompts.length} initial prompts t·ª´ textarea v√†o queue`, 'success');
          // Keep textarea for tracking (don't clear)
        }

        document.getElementById('startBtn').disabled = true;
        document.getElementById('stopBtn').disabled = false;
        document.getElementById('pauseBtn').disabled = false;
        document.getElementById('resumeBtn').disabled = true;

        log(`\nüöÄ ========== B·∫ÆT ƒê·∫¶U WORKFLOW ==========`, 'success');
        log(`üìä Image queue: ${state.imageQueue.length} prompts`, 'info');
        log(`üîÑ Parallel processing: Images & Videos run independently`, 'info');
        updateStats();

        // Start both queues in parallel
        processImageQueue();
        processVideoQueue();
      }
    }

    async function startMediaIdWorkflow() {
      const mediaIdListText = document.getElementById('mediaIdList').value.trim();
      const videoPrompts = parseVideoPrompts();

      if (!mediaIdListText) {
        alert('‚ö†Ô∏è Vui l√≤ng nh·∫≠p MediaID List!');
        log('‚ùå MediaID mode: Ch∆∞a nh·∫≠p mediaID n√†o', 'error');
        return;
      }

      if (videoPrompts.length === 0) {
        alert('‚ö†Ô∏è Vui l√≤ng nh·∫≠p Video Prompts!');
        log('‚ùå MediaID mode: Ch∆∞a nh·∫≠p video prompt n√†o', 'error');
        return;
      }

      // Parse mediaIDs
      const mediaIds = mediaIdListText.split('\n')
        .map(line => line.trim())
        .filter(line => line.length > 0);

      if (mediaIds.length < 2) {
        alert('‚ö†Ô∏è C·∫ßn √≠t nh·∫•t 2 mediaID ƒë·ªÉ t·∫°o video!');
        log('‚ùå MediaID mode: C·∫ßn √≠t nh·∫•t 2 mediaID', 'error');
        return;
      }

      log(`\nüöÄ ========== B·∫ÆT ƒê·∫¶U MEDIAID WORKFLOW ==========`, 'success');
      log(`üîë T√¨m th·∫•y ${mediaIds.length} mediaIDs`, 'info');
      log(`üìù T√¨m th·∫•y ${videoPrompts.length} video prompts`, 'info');

      // Create fake image objects from mediaIDs (no actual images, just metadata)
      state.images = mediaIds.map((mediaId, index) => ({
        url: null,  // No image URL in mediaID mode
        prompt: `MediaID ${index + 1}`,
        seed: 0,
        generationId: mediaId,  // This is the key - use mediaID as generationId
        index: index,
        timestamp: Date.now(),
        isContinue: false,
        uploadedMediaId: mediaId  // Also set this for consistency
      }));

      state.imageCount = mediaIds.length;

      // Queue videos based on prompts
      for (let i = 0; i < videoPrompts.length; i++) {
        const img1 = state.images[i];
        const img2 = state.images[i + 1];

        if (!img1 || !img2) {
          log(`‚ö†Ô∏è Video ${i + 1}: Kh√¥ng ƒë·ªß ·∫£nh (c·∫ßn ·∫£nh ${i + 1} v√† ${i + 2})`, 'warning');
          break;
        }

        state.videoQueue.push({
          img1,
          img2,
          prompt: videoPrompts[i],
          sceneIndex: i,
          attempts: 0
        });
      }

      log(`‚úÖ ƒê√£ queue ${state.videoQueue.length} videos t·ª´ mediaIDs`, 'success');

      state.isRunning = true;
      state.paused = false;

      document.getElementById('startBtn').disabled = true;
      document.getElementById('stopBtn').disabled = false;
      document.getElementById('pauseBtn').disabled = false;
      document.getElementById('resumeBtn').disabled = true;

      updateStats();

      // Start video queue only (no image generation)
      processVideoQueue();
    }

    function stopWorkflow() {
      // Stop and RESET to beginning
      state.isRunning = false;
      state.paused = false;

      // Clear all queues - will restart from image 1
      state.imageQueue = [];
      state.videoQueue = [];
      state.activeImageTasks = [];
      state.activeVideoTasks = [];

      // Reset counters to restart from beginning
      state.images = [];
      state.videos = [];
      state.imageCount = 0;
      state.videoCount = 0;
      state.imagePromptCursor = 0;
      state.videoPromptCursor = 0;

      // CRITICAL: Clear failed items from sidebar
      state.failedImages = [];
      state.failedVideos = [];

      // Clear galleries
      document.getElementById('imageGallery').innerHTML = '';
      document.getElementById('videoGallery').innerHTML = '';

      document.getElementById('startBtn').disabled = false;
      document.getElementById('stopBtn').disabled = true;
      document.getElementById('pauseBtn').disabled = true;
      document.getElementById('resumeBtn').disabled = true;

      updateStats();
      log('‚èπÔ∏è STOP: ƒê√£ d·ª´ng v√† reset v·ªÅ ƒë·∫ßu, s·∫Ω gen l·∫°i t·ª´ ·∫£nh 1', 'warning');
    }

    function pauseWorkflow() {
      state.paused = true;
      document.getElementById('pauseBtn').disabled = true;
      document.getElementById('resumeBtn').disabled = false;
      log('‚è∏Ô∏è PAUSE: T·∫°m d·ª´ng workflow', 'warning');
    }

    function resumeWorkflow() {
      state.paused = false;
      document.getElementById('pauseBtn').disabled = false;
      document.getElementById('resumeBtn').disabled = true;
      log('‚ñ∂Ô∏è RESUME: Ti·∫øp t·ª•c workflow', 'success');

      // CRITICAL: Restart queue processors if they stopped
      // If already running, they will return early due to internal guards
      if (!state.imageQueueProcessing && (state.imageQueue.length > 0 || state.isRunning)) {
        processImageQueue();
      }
      if (!state.videoQueueProcessing && (state.videoQueue.length > 0 || state.isRunning)) {
        processVideoQueue();
      }
    }

    // TEST: Generate video directly from mediaID
    // ============================================
    async function testGenerateVideoFromMediaId() {
      const mediaId1 = document.getElementById('testMediaId1').value.trim();
      const mediaId2 = document.getElementById('testMediaId2').value.trim();
      const prompt = document.getElementById('testVideoPrompt').value.trim();
      const previewDiv = document.getElementById('testVideoPreview');

      if (!mediaId1 || !mediaId2 || !prompt) {
        alert('Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß MediaID 1, MediaID 2 v√† Prompt!');
        return;
      }

      if (!state.projectId || !state.sceneId) {
        alert('Vui l√≤ng parse v√† x√°c nh·∫≠n project tr∆∞·ªõc!');
        return;
      }

      previewDiv.innerHTML = '‚è≥ ƒêang gen video t·ª´ mediaID...';
      log('üß™ TEST: Gen video t·ª´ mediaID tr·ª±c ti·∫øp (kh√¥ng upload)...', 'info');

      try {
        // Generate video with single variant for testing
        const numVariants = 1;
        const seed = Math.floor(Math.random() * 65536);

        log(`üß™ TEST: G·ªçi API Veo3 v·ªõi mediaID1=${mediaId1.substring(0, 20)}..., mediaID2=${mediaId2.substring(0, 20)}...`, 'info');

        const videoRes = await fetch('/api/veo3/generate-start-end', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            projectId: state.projectId,
            sceneId: state.sceneId,
            startImageMediaId: mediaId1,
            endImageMediaId: mediaId2,
            prompt: prompt,
            aspectRatio: state.aspectRatio.replace('IMAGE_', 'VIDEO_'),
            seeds: [seed]
          })
        });

        if (videoRes.status === 429) {
          throw new Error('Rate limit 429: Too many requests');
        }

        const videoData = await videoRes.json();

        if (videoData.success && videoData.operations && videoData.operations.length > 0) {
          log(`üß™ TEST: ƒê√£ b·∫Øt ƒë·∫ßu gen video! ƒêang poll...`, 'success');

          const operation = videoData.operations[0];
          const video = await pollVideoStatus(operation.operation.name, 0, 0);

          if (video) {
            log(`‚úÖ TEST: Gen video th√†nh c√¥ng!`, 'success');

            // Build outputDir from savePath + projectName
            const basePath = document.getElementById('videoSavePath').value.trim();
            const projectName = document.getElementById('videoProjectName').value.trim() || 'Test';

            let outputDir = null;
            if (basePath && projectName) {
              // Will be: basePath\projectName
              outputDir = `${basePath}\\${projectName}`;
            }

            // Download video for preview
            const downloadRes = await fetch('/api/veo3/download-video', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                fifeUrl: video.url,
                mediaId: video.mediaId,
                sceneIndex: 0,
                variantIndex: 0,
                outputDir: outputDir
              })
            });

            const downloadData = await downloadRes.json();

            if (downloadData.success) {
              previewDiv.innerHTML = `
                <div style="color: green; font-weight: bold; margin-bottom: 8px;">‚úÖ Th√†nh c√¥ng!</div>
                <video src="${video.url}" controls style="width: 100%; max-height: 300px; border-radius: 4px;"></video>
                <div style="margin-top: 8px; font-size: 0.85em;">
                  <div>üìù Prompt: ${prompt}</div>
                  <div>üíæ ƒê√£ l∆∞u: ${downloadData.path}</div>
                  <div style="color: #0a0; font-weight: bold; margin-top: 8px;">üéâ MediaID t·ª´ Whisk c√≥ th·ªÉ d√πng tr·ª±c ti·∫øp cho Veo3!</div>
                </div>
              `;
            } else {
              previewDiv.innerHTML = `
                <div style="color: green; font-weight: bold; margin-bottom: 8px;">‚úÖ Gen th√†nh c√¥ng!</div>
                <video src="${video.url}" controls style="width: 100%; max-height: 300px; border-radius: 4px;"></video>
                <div style="margin-top: 8px; font-size: 0.85em;">
                  <div>üìù Prompt: ${prompt}</div>
                  <div style="color: orange;">‚ö†Ô∏è L∆∞u file th·∫•t b·∫°i: ${downloadData.error}</div>
                  <div style="color: #0a0; font-weight: bold; margin-top: 8px;">üéâ MediaID t·ª´ Whisk c√≥ th·ªÉ d√πng tr·ª±c ti·∫øp cho Veo3!</div>
                </div>
              `;
            }
          } else {
            throw new Error('Poll video failed');
          }
        } else {
          throw new Error(videoData.error || 'Unknown error');
        }
      } catch (err) {
        log(`‚ùå TEST: L·ªói gen video: ${err.message}`, 'error');
        previewDiv.innerHTML = `<div style="color: red;">‚ùå L·ªói: ${err.message}</div>`;
      }
    }

    function clearAll() {
      if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a t·∫•t c·∫£?')) {
        state.images = [];
        state.videos = [];
        state.imageCount = 0;
        state.videoCount = 0;
        state.lastVideoMediaId = null;
        state.imageQueue = [];
        state.videoQueue = [];
        state.failedImages = [];
        state.failedVideos = [];
        state.activeImageTasks = [];
        state.activeVideoTasks = [];
        state.imagePromptCursor = 0;
        state.videoPromptCursor = 0;
        document.getElementById('imageGallery').innerHTML = '';
        document.getElementById('videoGallery').innerHTML = '';
        document.getElementById('logConsole').innerHTML = '';
        updateStats();
        updateProgress();
        log('üóëÔ∏è ƒê√£ x√≥a t·∫•t c·∫£ d·ªØ li·ªáu', 'info');
      }
    }

    // ============================================
    // ============================================
    // CHROME & LANES FUNCTIONS
    // ============================================
    async function launchChromeIndex3() {
      // Index3 always uses temp session (empty profile)
      const profile = '';
      try {
        log('üöÄ ƒêang kh·ªüi ƒë·ªông Chrome (temp session)...', 'info');
        const res = await fetch('/api/launch-chrome', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ profile })
        });
        const data = await res.json();
        if (data.success) {
          log('‚úÖ Chrome ƒë√£ kh·ªüi ƒë·ªông (temp session)! H√£y login v√†o Google Labs Flow.', 'success');
        } else {
          log(`‚ùå ${data.error}`, 'error');
        }
      } catch (err) {
        log(`‚ùå L·ªói: ${err.message}`, 'error');
      }
    }

    async function captureTokenIndex3() {
      try {
        log('üîë ƒêang b·∫Øt token...', 'info');
        const res = await fetch('/api/capture-token');
        const data = await res.json();
        if (data.success) {
          log('‚úÖ ƒê√£ b·∫Øt token th√†nh c√¥ng!', 'success');
          showLaneStatus('‚úÖ Token ƒë√£ ƒë∆∞·ª£c capture cho session hi·ªán t·∫°i', 'success');
        } else {
          log(`‚ùå ${data.error}`, 'error');
          showLaneStatus(`‚ùå ${data.error}`, 'error');
        }
      } catch (err) {
        log(`‚ùå L·ªói: ${err.message}`, 'error');
        showLaneStatus(`‚ùå ${err.message}`, 'error');
      }
    }

    async function loadLaneIndex3() {
      const laneName = document.getElementById('selectedLane').value;
      if (!laneName) {
        showLaneStatus('‚ÑπÔ∏è ƒêang d√πng session hi·ªán t·∫°i', 'info');
        return;
      }

      try {
        // This would load the lane credentials into current session
        // For now, just show status
        showLaneStatus(`‚úÖ ƒê√£ ch·ªçn lane: ${laneName}`, 'success');
        log(`üìå Chuy·ªÉn sang lane: ${laneName}`, 'info');
      } catch (err) {
        showLaneStatus(`‚ùå ${err.message}`, 'error');
      }
    }

    function showLaneStatus(message, type) {
      const statusDiv = document.getElementById('laneStatus');
      statusDiv.textContent = message;
      statusDiv.style.display = 'block';

      if (type === 'success') {
        statusDiv.style.background = 'rgba(86, 171, 47, 0.1)';
        statusDiv.style.color = '#56ab2f';
        statusDiv.style.border = '1px solid #56ab2f';
      } else if (type === 'error') {
        statusDiv.style.background = 'rgba(235, 51, 73, 0.1)';
        statusDiv.style.color = '#eb3349';
        statusDiv.style.border = '1px solid #eb3349';
      } else {
        statusDiv.style.background = 'rgba(102, 126, 234, 0.1)';
        statusDiv.style.color = '#667eea';
        statusDiv.style.border = '1px solid #667eea';
      }
    }

    async function loadLanesDropdown() {
      try {
        const res = await fetch('/api/list-tokens');
        const data = await res.json();

        const select = document.getElementById('selectedLane');
        if (data.success && data.tokens && data.tokens.length > 0) {
          data.tokens.forEach(lane => {
            const option = document.createElement('option');
            option.value = lane.name;
            option.textContent = lane.name;
            select.appendChild(option);
          });
          log(`üìã ƒê√£ load ${data.tokens.length} lanes t·ª´ tokens.xlsx`, 'info');
        }
      } catch (err) {
        log(`‚ö†Ô∏è Kh√¥ng th·ªÉ load lanes: ${err.message}`, 'warning');
      }
    }

    // ============================================
    // INITIALIZATION
    // ============================================
    window.onload = async function() {
      log('üé® Ch√†o m·ª´ng ƒë·∫øn v·ªõi Whisk + Veo3 Auto Workflow v2!', 'success');
      log('', 'info');
      log('üìã T√çNH NƒÇNG M·ªöI:', 'info');
      log('‚îÄ'.repeat(60), 'info');
      log('‚úÖ Parallel queues: Image & Video ch·∫°y song song', 'info');
      log('‚úÖ Retry 3 l·∫ßn t·ª± ƒë·ªông khi g·∫∑p l·ªói', 'info');
      log('‚úÖ Error sidebar: Track failed items + retry th·ªß c√¥ng', 'info');
      log('‚úÖ Submit buttons: Th√™m prompts m·ªçi l√∫c kh√¥ng c·∫ßn d·ª´ng', 'info');
      log('‚úÖ Session save/load: Ph√≤ng m·∫•t ƒëi·ªán', 'info');
      log('‚úÖ Fixed video prompt: D√πng 1 prompt cho t·∫•t c·∫£', 'info');
      log('‚úÖ Gallery: Ch·ªâ hi·ªán variant A cho g·ªçn', 'info');
      log('‚îÄ'.repeat(60), 'info');
      log('', 'info');

      // Load lanes dropdown
      await loadLanesDropdown();

      // Load last project link if available
      try {
        const lastLink = localStorage.getItem('last_project_link');
        if (lastLink) {
          document.getElementById('projectLink').value = lastLink;
          log('üìã ƒê√£ load Project Link tr∆∞·ªõc ƒë√≥', 'info');
        }
      } catch (err) {
        console.error('Failed to load last project link:', err);
      }

      // Check Chrome status
      try {
        const res = await fetch('/api/chrome-status');
        const data = await res.json();
        if (data.chromeReady) {
          updateStatus('chromeStatus', 'active');
          updateStatus('sessionStatus', 'active');
          log('‚úÖ Chrome v√† session ƒë√£ s·∫µn s√†ng!', 'success');
        }
      } catch (err) {
        log('‚ö†Ô∏è Kh√¥ng th·ªÉ k·∫øt n·ªëi server. Vui l√≤ng kh·ªüi ƒë·ªông server tr∆∞·ªõc.', 'warning');
      }

      // Load saved profiles and tokens
      await loadProfileList();
      await loadTokenList();

      updateStats();
    };
  </script>
</body>
</html>